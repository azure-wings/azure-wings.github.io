{"/":{"title":"azure-wiki","content":"\n\u003e Wiki made by azurewings\n\n## Index\n\n### üìö Academic\n- [Mathematics](index/Mathematics.md)\n- [Computer science](index/Computer%20science.md)\n- [Business administration](index/Business%20administration.md)\n- [Economics](index/Economics.md)\n### üìÅ Archives\n- [Books](index/Books.md)\n- [Movies](index/Movies.md)","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Books":{"title":"Books","content":"\n\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Business-administration":{"title":"Business administration","content":"\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Computer-science":{"title":"Computer science","content":"\n**Computer science** is the study of computation, automation, and information.\n\n## Basic mathematics\n- [Mathematical logic](notes/Mathematical%20logic.md)\n- [Set theory](notes/Set%20theory.md)\n\n## Data structures and algorithms\n- Data structures\n- Algorithms\n\t- Algorithm analysis\n- Combinatorial optimization\n\n## Theoretical computer science\n- Formal languages\n- Automata theory\n- Theory of computation\n\n## Programming language theory and formal methods\n- [Programming language theory](notes/Programming%20language%20theory.md)\n- Type theory\n- Compilers\n\n## Databases and data mining\n- [Database systems](notes/Database%20systems.md)\n\n## Computer systems\n- Digital systems\n- [Computer architecture](notes/Computer%20architecture.md)\n- [Operating systems](notes/Operating%20systems.md)\n- Computer network\n\n## Computer graphics and visualisation\n- [Computer graphics](notes/Computer%20graphics.md)\n\n## [Artificial intelligence](notes/Artificial%20intelligence.md)","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Economics":{"title":"Economics","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Mathematics":{"title":"Mathematics","content":"\n**Mathematics** is a study of abstract concepts such as numbers, quantities, spaces, changes, structures, etc., based on strict logic.\n\n## Algebra\n- [Linear algebra](notes/Linear%20algebra.md)\n- [Abstract algebra](notes/Abstract%20algebra.md)\n\n## Analysis\n- Real analysis\n- [Vector analysis](notes/Vector%20analysis.md)\n- Functional analysis\n- Fourier analysis\n\n## Topology / Geometry\n- [Topology](notes/Topology.md)\n- Differential geometry\n\n## Probability / Statistics\n- Probability theory\n- [Statistics](notes/Statistics.md)\n\n## Discrete\n- Mathematical logic\n- Set theory\n- Category theory\n- Graph theory\n\n## Computational mathematics\n- [Approximation theory](notes/Approximation%20theory.md)\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/index/Movies":{"title":"Movies","content":"\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Abstract-algebra":{"title":"Abstract algebra","content":"\n**Abstract algebra** is the study of algebraic structures such as groups, rings, [fields](notes/Field.md), modules, [vector spaces](notes/Vector%20space.md), lattices, and algebras.\n\n## Group theory\n- [Group](notes/Group.md)\n\n## Ring theory\n\n## Modules and vector spaces\n\n## Field theory\n\n## Galois theory\n\n## Finite groups","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Abstract-syntax":{"title":"Abstract syntax","content":"\n**Abstract syntax** formally express multiple components and subcomponents the program consists of.\n\n## Abstract Syntax Tree (AST)\nAbstract syntax are often described in the form of trees.\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Additional-basic-operations":{"title":"Additional basic operations","content":"\n## Rename operation\n\nSQL allows renaming relations and attributes using the `AS` clause.\n\n```sql\nold_name AS new_name\n```\n\nThe keyword `AS` is optional and may be omitted.\n\n## String operation\n\nSQL includes a string matching operator for comparisons on character strings.\\\n\n```sql\nLIKE some_string\n```\n\nThe operator `LIKE` uses patterns; they can be described using two special characters: `%` and `_`.\n\n- `%`: Matches any string.\n- `_`: Matches any character.\n\nPatterns are case-sensitive. SQL supports a variety of string operations such as:\n\n- `str1 || str2`: Concatenate `str1` and `str2`.\n- `UPPER(str)`, `LOWER(str)`: Converting from lower to upper / upper to lower cases.\n- `LENGTH(str)`: Finding the length of `str`.\n- `SUBSTR(str, start, length)`: Extracting substring.\n\n### Escape Character\n\nFor patterns to include the special pattern characters (% and _), SQL allows the specification of an **escape character** defined using the `ESCAPE` keyword.\n\n```sql\nLIKE some_string ESCAPE escape_character\n```\n\nFor example,\n\n- `LIKE 'ab\\%cd%' ESCAPE '\\'` matches all strings beginning with `'ab%cd'`.\n- `LIKE 'ab\\\\cd%' ESCAPE '\\'` matches all strings beginning with `'ab\\cd'`.\n\n## Ordering the display of tuples\n\nThe `ORDER BY` clause causes the tuples in the results of a query to appear in sorted order.\n\n```sql\nORDER BY some_attribute\n```\n\nWe may specify `DESC` for descending order or `ASC` for ascending order; ascending order is the default setting.\n\n`ORDER BY` can sort on multiple attributes.\n\n## `WHERE` clause predicates\n\nSQL includes a `BETWEEN` comparison operator to simplify `WHERE` clauses.\n\n```sql\nWHERE some_attribute BETWEEN start_val AND end_val\n```\n\nSQL allows the use of the notation `(v_1, ... , v_n)` to denote a tuple of arity `n` containing values `v_1`, ‚Ä¶ , `v_n`.\n\nThe comparison operator can be used on tuples, and the ordering is defined lexicographically.\n\n- e.g., `(a_1, a_2) \u003c= (b_1, b_2)` is true if both `a_1 \u003c= b_1` and `a_2 \u003c= b_2`.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Aggregate-functions":{"title":"Aggregate functions","content":"\n**Aggregate functions** are functions that take a collection of values as input, and return a single value.\n\nSQL offers five aggregate functions:\n\n- Average: `AVG`\n- Minimum: `MIN`\n- Maximum: `MAX`\n- Total: `SUM`\n- Count: `COUNT`\n\nThe input to `AVG` and `SUM` must be a collection of numbers.\n\n## Aggregation with Grouping\n\n`GROUP BY` clause uses the given attributes to form groups.\n\n```sql\nGROUP BY some_attributes\n```\n\n- **Example**\n    \n    Find the average salary of instructors in each department.\n    \n    ```sql\n    SELECT   dept_name,\n    \t\t\t\t AVG(salary) AS avg_salary\n    FROM     instructor\n    GROUP BY dept_name\n    ```\n    \n\nAttributes in `SELECT` statement that is outside of aggregate functions **must** appear in the `GROUP BY` clause; otherwise the query is treated as erroneous.\n\n## `HAVING` Clause\n\nSQL applies predicated in the `HAVING` clause **after** the formation of groups, whereas predicates in the `WHERE` clause are applied **before** the group formation.\n\n```sql\nGROUP BY some_attributes\nHAVING   predicate\n```\n\nA typical query containing aggregation, `GROUP BY`, and/or `HAVING` clauses is defined by the following sequence of operations.\n\n1. The `FROM` clause is first  evaluated to get a relation.\n2. If a `WHERE` clause is present, the predicate in the `WHERE` clause is applied on the result relation of the `FROM` clause.\n3. Tuples satisfying the `WHERE` predicate are then placed into groups by the `GROUP BY` clause (if present).\nOtherwise the entire set of tuples satisfying `WHERE` clause‚Äôs predicate is treated as one single group.\n4. The `HAVING` clause (if present) is applied to **each group**, the groups that do not satisfying the `HAVING` predicate are removed.\n5. The `SELECT` clause uses the remaining groups to generate tuples of the result of the query, applying the aggregate functions to get a single result tuple for each group.\n\n## Aggregation with `NULL` Values\n\n- All aggregate functions except `COUNT` ignore `NULL` values in their input collection.\n- The `COUNT` of an empty collection is defined to be `0`.\n- All other aggregate operations return a value `NULL` when applied to an empty collection.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Algorithms":{"title":"Algorithms","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Alternating-multilinear-form":{"title":"Alternating multilinear form","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Approximation-theory":{"title":"Approximation theory","content":"\n**Approximation theory** is concerned with how functions can best be _approximated_ with simpler functions, and with quantitatively characterising the errors introduced thereby.\n\n- [Weierstrass approximation theorem](notes/Weierstrass%20approximation%20theorem.md)\n- ","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Artificial-intelligence":{"title":"Artificial intelligence","content":"\n**Artificial intelligence** is is intelligence demonstrated by machines, as opposed to the **natural intelligence** displayed by animals including humans.\n\n## Basics\n### Mathematics\n- [Linear algebra](notes/Linear%20algebra.md)\n- [Vector analysis](notes/Vector%20analysis.md)\n- [Statistics](notes/Statistics.md)\n\n## Goals\n### Planning\n- [Automated planning and scheduling](notes/Automated%20planning%20and%20scheduling.md)\n\n### Learning\n- [Machine learning](notes/Machine%20learning.md)\n\n### Natural language processing\n- [Natural language processing](notes/Natural%20language%20processing.md)\n\n### Perception\n- [Computer vision](/notes/Computer%20vision.md)\n- [Speech recognition](notes/Speech%20recognition.md)","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Atomic-operation":{"title":"Atomic operation","content":"\n## Definition\nAn **atomic operation** is an _indivisible_ operation that _cannot be ineterleaved_ or split by other operations.\n\n## Examples\n- On most modern architectures, a `load` or `store` of a 32-bit word from or to memory is an atomic operation.\n- However, depending on the hardware implementation, a `load` or `store` of a 64-bit word may not be atomic.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Basic-structure-of-SQL-queries":{"title":"Basic Structure of SQL Queries","content":"\n## Basic Query Structure\n\nA typical SQL query has the following form.\n\n```sql\nSELECT  A_1, ... , A_n\nFROM    r_1, ... , r_m\nWHERE   p\n```\n\n- `A_i`: Attributes\n- `R_i`: Relations\n- `P`: Predicate\n\nThe result of an SQL query is a relation.\n\n### `SELECT` Clause\n\n- The `SELECT` clause lists the attributes desired in the result of a query.\\\nIt corresponds to the projection operation $\\Pi$ of the [[notes/Relational algebra]].\\\nNote that SQL names are case insensitive.\n    \n- The `DISTINCT` keyword inserted after `SELECT` eliminates all duplicates.\\\nThe `ALL` keyword, on the other hand, explicitly specifies that duplicates should not be removed, although it is the default of `SELECT` clause.\n    \n- A `*` in the `SELECT` clause denotes all attributes.\n- An attribute can be a literal **without** `FROM` clause.\\\nThe result is a table with one column and a single row with the literal value.\n    \n- An attribute can be a literal **with** `FROM` clause.\\\nThe result is a table with one column and rows (number equal to the number of rows on the table), each row with the literal value.\n    \n- `SELECT` clause can contain arithmetic expressions (`+`, `-`, `*`, `/`) operating on constants or attributes of tuples.\n\n### `FROM` Clause\n\n- The `FROM` clause lists the relations involved in the query.\\\nIt corresponds to the Cartesian product $\\times$ of the [[notes/Relational algebra]].\n    \n\n### `WHERE` Clause\n\n- The `WHERE` clause specifies conditions that the resulting relation must satisfy.\\\nIt corresponds to the selection operation $\\sigma$ of the [[notes/Relational algebra]].\n    \n- SQL allows the use of the logical connectives `AND`, `OR`, and `NOT`.\n- The operands of the logical connectives can be expressions involving the comparison operators, `\u003c`, `\u003c=`, `\u003e`, `\u003e=`, `=`, and `\u003c\u003e`.\\\nComparisons can be applied to results of arithmetic expressions.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Basis":{"title":"Basis","content":"\n## Definition\n\u003eLet $V$ be a [vector space](notes/Vector%20space.md) and $\\beta$ be a subset of $V$.\\\n\u003eIf $\\beta$ is [linearly independent](notes/Linear%20independence.md) and [spans](notes/Span.md) $V$, then $\\beta$ is a **basis** of $V$.\\\n\u003eWe can also say that $\\beta$ forms a basis for $V$.\n\n## Theorems\n### Theorem 1\n\u003eLet $V$ be a vector space over a [field](notes/Field.md) $F$, and $\\def\\v#1{\\mathbf{#1}} \\v{u}\\_1, \\cdots, \\v{u}\\_n$ be $n$ distinct vectors of $V$.\\\n\u003eThen $\\def\\v#1{\\mathbf{#1}} \\beta = \\\\{ \\v{u}\\_1, \\cdots, \\v{u}\\_n \\\\}$ forms a basis for $V$ if and only if an arbitrary vector $\\mathbf{v} \\in V$ can be **uniquely** written as a linear combination of vectors of $\\beta$.\\\n\u003eIn other words, $\\exists! a\\_1, \\cdots, a\\_n \\in F$ such that $\\def\\v#1{\\mathbf{#1}} \\v{v} = \\sum\\limits^n\\_{i=1} a\\_i\\v{u}\\_i$.\n\n### Proof\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Bernstein-polynomial":{"title":"Bernstein polynomial","content":"\nA **Bernstein polynomial** is a polynomial that is a [linear combination](notes/Linear%20combination.md) of Bernstein [basis](notes/Basis.md) polynomials.\n\n## Definition\nThe $n‚Ää+1$ **Bernstein basis polynomials** of degree $n$ are defined as\n\u003e $b_{\\nu, n}(x) = \\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}, \\qquad \\text{where}\\; \\nu = 0, \\cdots, n$.\n\nThe name is from the fact that the Bernstein basis polynomials of degree $n$ form a [basis](notes/Basis.md) for the [vector space](notes/Vector%20space.md) $\\mathbb{P}_n$, a space which consists of polynomials with degree at most $n$. \n\nA **Bernstein polynomial** is a linear combination of Bernstein basis polynomials:\n\u003e $B_n(x) = \\sum\\limits_{\\nu = 0}^n \\beta_\\nu b_{\\nu, n}(x)$\n\nwhere the coefficients $\\beta_\\nu$ are called **Bernstein coefficients**.\n\n## Examples\n### Approximation of continuous functions\nLet $f$ be a continuous funciton on the interval $[0,1]$. Let $\\beta_\\nu = f\\left(\\dfrac{\\nu}{n}\\right)$.\nWe can denote the corresponding Bernstein polynomial as $B_n(x; f)$.\nThe corresponding Bernstein polynomial becomes:\n$$\n\\begin{aligned}\nB_n(x; f) \u0026= \\sum\\limits_{\\nu = 0}^n f\\left(\\dfrac{\\nu}{n}\\right)b_{\\nu, n}(x)\\\\\n\u0026= \\sum\\limits_{\\nu = 0}^n f\\left(\\dfrac{\\nu}{n}\\right)\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}.\n\\end{aligned}\n$$\n\n\n## Properties\n### Property #1\n\u003e $B_n(x; \\mathbb{1}) = 1$\n\n### Property #2\n\u003e $B_n(x;x) = x$\n\n### Property #3\n\u003e $B_n(x;x^2) = x^2 + \\dfrac{1}{n}(x - x^2)$\n\n### Property #4\n\u003e $B_n(x; af + g) = aB_n(x; f) + B_n(x;g)$\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Bounded-buffer-problem":{"title":"Bounded buffer problem","content":"\n## Definition\n```\n+----------+                    +----------+\n|          |    +----------+    |          |\n| Producer |---\u003e|  Buffer  |---\u003e| Consumer |\n|          |    +----------+    |          |\n+----------+                    +----------+\n```\n\n- The producer puts objects into a shared buffer.\n- The consumer takes them out.\n- There must be a synchronisation to coordinate between the producer and the consumer.\n- The producer and the consumer should not need to work in [lock](Lock.md) step; there is a fixed-size buffer between them.\n\t- The access to this buffer must be synchronised.\n\t- The producer must wait if the buffer is full.\n\t- The consumer must wait if the buffer is empty.\n\n## Implementation Example\n- **Producer**\n```C\nfor (int i = 0; i\u003cMAX_LOOP; i++)\n{\n  try_put (i);\n}\n```\n\n- **Consumer**\n```C\nwhile (true)\n{\n  int tmp = try_get ();\n  printf (\"%d\\n\", tmp);\n}\n```\n\nInitially, the buffer is a _queue_ with `front = tail = 0`, and the lock is initially `free`. Let `MAX` be the maximum capacity of the buffer. Then, the `try_put ()` and `try_get ()` can be implemented as follows.\n\n- **`try_put`**\n```C\ntry_put (item)\n{\n  lock.acquire ();\n  if ((tail - front) \u003c size)    // Buffer is not full\n  {\n\tbuffer[tail % MAX] = item;\n\ttail++;\n  }\n  lock.release ();\n}\n```\n\n- **`try_get`**\n```C\ntry_get ()\n{\n  item = NULL;\n  lock_acquire ();\n  if (front \u003c tail)            // Buffer is not empty\n  {\n\titem = buffer[front % MAX];\n\tfront++;\n  }\n  lock_release ();\n  return item;\n}\n```\n\nHere, the shared states are `buffer`, `front`, and `tail`.\n\nHowever, one cannot assure that the `buffer` is empty when `try_get ()` returns `NULL`.\n- If a producer generates an item between `lock_release ()` and `return`, even though the `buffer` is not empty, `try_get ()` returns `NULL`.\n- For a thread to know when the `buffer` is empty, there must be _[another primitive](Condition%20variable.md)_ for the purpose.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Cauchy-Schwartz-inequality":{"title":"Cauchy-Schwartz Inequality","content":"## Theorem\nFor any vectors $\\mathbf{x},\\mathbf{y} \\in \\mathbb{R}^n$,\n$$\n|\\mathbf{x}^\\top\\mathbf{y}| \\leq \\|\\mathbf{x}\\|_2\\|\\mathbf{y}\\|_2.\n$$\n\n## Generalization\nSee [H√∂lder's inequality](notes/H%C3%B6lder's%20inequality.md).\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Comparison-between-processes-and-threads":{"title":"Comparison between processes and threads","content":"\n## Comparison\n|                        | [Processes](notes/Process.md)                 | [Threads](notes/Thread.md)                                                    |\n| ---------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |\n| Switch Overhead        | High (CPU state + Memory, I/O state)        | Low (CPU state only)                                                        |\n| Creation Cost          | High                                        | Low                                                                         |\n| CPU Protection         | Yes                                         | Yes                                                                         |\n| Memory, I/O Protection | Yes                                         | No                                                                          |\n| Sharing Overhead       | High (Involves at leas a context switch)    | Low (Because thread switch overhead is low; may not need to switch context) |\n| Sharing Security       | High (One process cannot corrupt the other) | Low (A thread can write the memory used by another thread)                  |\n\n## Diagrams\n![process-diagram](/notes/images/process-diagram.png)\n\n![processes-diagram](/notes/images/processes-diagram.png)\n\n![threads-diagram](/notes/images/threads-diagram.png)\n\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Computer-architecture":{"title":"Computer architecture","content":"\n**Computer architecture** is a set of rules and methods that describe the functionality, organisation, and implementation of computer systems.\n\n## Computer Abstractions\n- [Performance](notes/Performance.md)\n\n## Instructions\n- [MIPS Assembly language](notes/MIPS%20Assembly%20language.md)\n\t- Representation of MIPS instructions in the computer\n- \n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Computer-graphics":{"title":"Computer graphics","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Computer-vision":{"title":"Computer vision","content":"\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Concrete-syntax":{"title":"Concrete syntax","content":"\n**Concrete syntax** determines whether a certain string is a program or not.\n\n## Intuition\nLet $C$ be the set of all characters. Then, the set of all strings $S$ can be defined as\n$$\nS = \\lbrace c_1c_2\\cdots c_n : c_i \\in C \\rbrace.\n$$\nConcrete syntax defines which strings are considered as programs. Let $P$ be the set of all possible programs. In other words,\n$$\nP = \\lbrace p: p \\;\\text{is a program} \\rbrace.\n$$\nIt is clear that $P \\subseteq S$. Concrete syntax determines which elements $s \\in S$ are in $P$. \n\nHowever, $P$ is (in most cases) an infinite set. Hence a sophisticated way to define concrete syntax is required.\n\n## Backus-Naur Form (BNF)\nBNF is one of the most popular method to define a concrete syntax. It consists of three concepts: **terminals**, **non-terminals**, and **expressions**.\n\n### Terminals\nA terminal is a string. `\"00\"`, `\"abc\"` are examples of terminals. Simple!\n\n### Non-terminals\nA non-terminal, also called a **metavariable**, denotes a set of strings. In BNF, it is denoted as a name between a pair of angle brackets. `\u003cdigit\u003e`,`\u003cexpression\u003e` are examples of non-terminals.\n\n### Expressions\nAn expression is an enumeration of one or more terminals/nonterminals. The followings are all examples of expressions.\n- `\"abc\"`\n- `\"0\"` `\"1\"`\n- `\u003cdigit\u003e`\n- `\u003cdigit\u003e` `\u003cnumber\u003e`\n- `\"-\"` `\u003cnumber\u003e`\n\nNow, it is possible to construct a concrete syntax in BNF. In BNF, a definition of a set is denoted as:\n\n`[nonterminal] ::= [expression] | [expression] | ...`\n\nwhere the vertical bars separates distinct expressions.\n\nAn example of BNF can be given as:\n```\n\u003cdigit\u003e  ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\u003cnat\u003e    ::= \u003cdigit\u003e | \u003cdigit\u003e \u003cnat\u003e\n\u003cnumber\u003e ::= \u003cnat\u003e | \"-\" \u003cnat\u003e\n```","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Condition-variable":{"title":"Condition variable","content":"\n## Definition\nA **condition variable** is a synchronisation object that lets a [thread](notes/Thread.md) efficiently wait for a change to shared state that is protected by a [lock](notes/Lock.md).\n\n## APIs\nA condition variable has three methods.\n\n- **`CV::wait(Lock *lock*)`**\n\t- This call [atomically](notes/Atomic%20operation.md) **releases the lock** and **suspends execution of the calling thread**, placing the calling thread on the condition variable's waiting list.\n\t- Later, when the calling thread is awakened, the lock is re-acquired before returning from the `wait` call.\n\n- **`CV::signal()`**\n\t- This call takes **one** thread off the condition variable's wait list and marks it as eligible to run (i.e., it puts the thread on the scheduler's ready list).\n\t- If no threads are on the waiting list, `signal` has no effect.\n\n- **`CV::broadcast()`**\n\t- This call takes **all** threads off the condition variable's waiting list and marks them as eligible to run.\n\t- If no threads are on the waiting list, `broadcast` has no effect.\n\n## Properties\n### Memoryless\n- The conditional variable itself has _no internal state_ other than a **queue** of waiting threads.\n\t- Condition variables do not need their own state because they are always used inside shared objects that have their own state.\n- If no threads are currently on the condition variable's waiting list, a `signal` or `broadcast` has no effect.\n- The condition variable has no _memory_ of earlier calls to `signal` or `broadcast`.\n\n### [Atomic](notes/Atomic%20operation.md)  Lock Release\n- A thread always calls `wait` while holding a lock. The call to `wait` atomically releases the lock and puts the thread on the condition variable's waiting list.\n\t- Atomicity ensures that there is no separation between checking the shared object's state, deciding to wait, adding the waiting thread to the condition variable's queue and releasing the lock, so that some other thread can access the shared object.\n\n### Non-immediate Return\n- When a waiting thread is re-enabled, it is moved to the [scheduler](notes/Scheduler.md)'s ready queue with no special priority, and the scheduler may run it at some later time.\n- Furthermore, when the thread finally does run, it must re-acquire the lock, which means that other threads may have acquired and released the lock in the meantime, between the `signal` / `broadcast` occurs and when the waiter re-acquires the lock.\n- Even if the desired predicate were true when `signal` / `broadcast` was called, it may no longer be true when `wait` returns.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Coordinates":{"title":"Coordinates","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Cramers-rule":{"title":"Cramer's rule","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Critical-section":{"title":"Critical section","content":"\n## Definition\nA **critical section** is a sequence of code that _atomically_ accesses shared state.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Database-systems":{"title":"Database systems","content":"\nA **database** is an organised collection of interrelated data that models some aspect of the real world.\nA **database management system**(DBMS) is a collection of interrelated data and a set of programs to access those data.\n\n## Introduction\n- [[notes/Purpose of database systems]]\n- [[notes/View of data]]\n\n## Relational languages\n- [[notes/Structure of relational databases]]\n- [[notes/Keys]]\n- [[notes/Relational query language]]\n- [[notes/Relational algebra]]\n## SQL\n### Introductory\n- [[notes/Overview of SQL]]\n- [[notes/SQL data definition]]\n- [[notes/Basic structure of SQL queries]]\n- [[notes/Additional basic operations]]\n- [[notes/Set operations in SQL]]\n- [[notes/Null values in SQL]]\n- [[notes/Aggregate functions]]\n- [[notes/Nested subqueries]]\n- [[notes/Modification of the database]]\n\n### Intermediate\n- [[notes/Join expressions]]\n\n### Advanced","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Deadlock":{"title":"Deadlock","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Determinant":{"title":"Determinant","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Dimension":{"title":"Dimension","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Dual-mode-operation":{"title":"Dual-mode operation","content":"\n\n## Definition\n**Dual-mode operation** of a kernel consists of two modes: **user mode** and **kernel mode**. \n\n- In **user mode**, the processor checks each instruction before executing it to verify that it is permitted to be performed by that process.\n- In **kernel mode**, the operating system executes it with protection checks turned off.\n\n## Hardware Requirements\nThe following three things must be supported by the hardware in order to accomplish dual-mode operation.\n\n1. **Privileged Instructions**: All potentially unsafe instructions are prohibited when executing in user mode.\n2. **Memory Protection**: All memory accesses outside of a process's valid memory region are prohibited when executing in user mode.\n3. **Timer Interrupts**: The kermnel must have a way to periodically regain control from the current process, regardless of what the process does.\n\n### Privileged Instructions\nInstructions that are available in kernel mode, but not in user mode, are called **privileged instructions**. The followings are examples of privileged instructions.\n\n- Changing the set of memory locations an application can access\n- Disabling processor interrupts\n- Changing an application's prvilige level\n- Jumping into kernel code\n\nIf an application attempts to execute an instruction that is prvileged, **processor exception** is caused. This causes the processor to transfer control to an **exception handler** in the operating system kernel.\n\nHowever, in some cases, applications must execute a privileged instruction. In such cases, applications are allowed to use a special instruction called **system call**. Processes can indirectly change their privilege level by executing a system call to transfer control into the kernel at a fixed location defined by the operating system.\n\n### Memory Protection\nTo make memory sharing safe, an application must be prevented from reading/writing other applications' memory. Most modern processors introduce **virtual memory** to accomplish this.\n\nWith virtual memory, every process's memory starts at the same location (e.g., zero). The hardware translates these virtual addresses into physical memory locations. At runtime, **memory-management unit (MMU)** relocates each `load`/`store` instructions; if the given virtual address is illegal, MMU raises a **segmentation fault**.\n\n### Timer Interrupts\nIf the user program enters an infinite loop (process monopolising CPU), or if the user simply becomes impatient and wants the system to stop the application, then the operating system must be able to regain control from applications. Operating system also needs to regain control of the processor in normal operations for multi-tasking.\n\nA physical timer included in the computer system delivers a hardware signal (interrupt) to the processor with a predefined frequency set by the kernel. (Each timer interrupts only one processor.) When the timer interrupt occurs, the hardware transfers from the user process to the kernel (interrupt handler) running in kernel mode.\n\n However, interrupts can be temporarily deferred by the kernel. This is crucial for the implementation of [mutual exclusion].","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Field":{"title":"Field","content":"\n## Definition\nA field $F$ is a set on which two operations $+$ (_addition_) and $\\cdot$ (_multiplication_) are defined so that the followings hold.\n\nFor any $x, y, z \\in F$,\n\u003e **(A1)** $x + y = y + x$  „ÄÄ(Commutativity of addition)\n\u003e \n\u003e **(A2)** $(x + y) + z = x + (y + z)$ „ÄÄ(Associativity of addition)\n\u003e\n\u003e **(A3)** $\\exists ! 0 \\in F$ such that  $\\forall x \\in F: x + 0 = x$ „ÄÄ(Existence of additive identity)\n\u003e \n\u003e **(A4)** $\\forall x \\in F: \\exists ! (-x) \\in F$ such that $x + (-x) = 0$ „ÄÄ(Existence of additive inverse)\n\u003e \n\u003e **(M1)** $xy = yx$ „ÄÄ(Commutativity of multiplication)\n\u003e \n\u003e **(M2)** $(xy)z = x(yz)$ „ÄÄ(Associativity of multiplication)\n\u003e\n\u003e **(M3)** $\\exists ! 1 \\in F$ such that $\\forall x \\in F: 1x = x$ „ÄÄ(Existence of multiplicative identity)\n\u003e \n\u003e **(M4)**  $\\forall x \\in F \\setminus \\{0\\}: \\exists ! x^{-1} \\in F$ such that $xx^{-1} = 1$ „ÄÄ(Existence of multiplicative inverse)\n\u003e \n\u003e **(D)** $x(y + z) = xy + xz$ „ÄÄ(Distributivity of multiplication over addition)\n\n\n## Examples\n- The set of rational numbers $(\\mathbb{Q})$, real numbers $(\\mathbb{R})$, and complex numbers $(\\mathbb{C})$ are fields.\n- The set $B = \\{0, 1\\}$ with boolean addition / multiplication is a field.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Fundamental-theorem-of-linear-algebra":{"title":"Fundamental theorem of linear algebra","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Group":{"title":"Group","content":"\r\n## Definition\r\nA **group** is an ordered pair $(G, \\cdot)$ where $G$ is a set and $\\cdot$ is a binary operation on $G$ satisfying the following axioms:\r\n\r\nFor any $x, y, z \\in G$:\r\n\u003e**(1)** $(x\\cdot y)\\cdot z = x\\cdot (y\\cdot z) \\quad$ (Associativity)\r\n\u003e\r\n\u003e**(2)** $\\exist e \\in G$ such that $\\forall x \\in G: x\\cdot e = e \\cdot x = x \\quad$ (Existence of identity element)\r\n\u003e\r\n\u003e**(3)** $\\forall x \\in G: \\exists ! x^{-1} \\in V$ such that $x\\cdot x^{-1} = x^{-1}\\cdot x = e \\quad$ (Existence of inverse element)\r\n\r\nFurthermore, $(G, \\cdot)$ is called **Abelian** if the following holds:\r\n\u003e**(A)** $x\\cdot y = y \\cdot x \\quad$ (Commutativity)","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/H%C3%B6lders-inequality":{"title":"H√∂lder's Inequality","content":"### Theorem\nFor any vectors $\\mathbf{x},\\mathbf{y} \\in \\mathbb{R}^n$ and for any $p,q \\geq 1$ such that $\\frac{1}{p} + \\frac{1}{q} = 1$, it holds that\n$$\n|\\mathbf{x}^\\top\\mathbf{y}| \\leq \\sum\\limits_{i=1}^n|x_iy_i| \\leq \\|\\mathbf{x}\\|_p\\|\\mathbf{y}\\|_q.\n$$\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Implementation-of-mode-transfer":{"title":"Implementation of mode transfer","content":"\n## Importance\nThe context switch ([mode transfer](notes/Mode%20transfer.md)) must be carefully crafted, and it relies on _hardware support_. To avoid confusion and reduce the possibility of error, m most operating systems have a common sequence of instructions both for entering the kernel and for returning to user level, regardeless of te cause.\n\nAt a minimum, this common sequence must provide the followings.\n\n- **Limited entry into the kernel**: User programs cannot be allowed to jump to arbitrary locations in the kernel.\n- **Atomic changes to processor state**: Transitioning between kernel and user mode is [atomic](notes/Atomic%20operation.md); _the mode, program counter, stack and memory protection_ are all changed _\u003cu\u003eat the same time\u003c/u\u003e (with a single instruction).\n-  **Transparent, restatable execution**: The operating system must be able to restore the state of the user program exactly as it was before the context switch.\n\n## Interrupt Vector\nWhen an interrupt, processor exception or system call trap occurs, the operating system must take different actions depending on what the event is. To this end, the processor has a special register that points to an area of kernel memory called the **interrupt vector table** set up by the kernel.\n\nThe interrupt vector table is an array of pointers, with each entry pointing to the first instruction of a different handler procedure in the kernel. An **interrupt handler** is the term used for the procedure called by kernel on an interrupt.\n\n![interrupt-vector-table](/notes/images/interrupt-vector-table.png)\n\n## Interrupt Stack\n**Interrupt stack** is a region of _kernel_ memory pointed by a special, privileged register. When an interrupt, processor exception, or system call trap causes a context switch into the kernel, the hardware changes the stack pointer to point to the base of the kernel's interrupt stack. The _hardware_ automatically saves some of the interrupted process's registers by pushing them onto the interrupt stack before calling the kernel's handler.\n\nWhen the kernel handler handler runs, it pushes any remaining registers onto the stack before pereforming its work. When returning from the interrupt, processor exception or system call trap, the reverse occurs. The handler pops the saved registers and the hardware restores the registers it saved, returning back to the point where the processor was interrupted. When returning from a system call, the value of the saved program counter _must be incremented_.\n\nOn a multiprocessor, each processor needs to have its own interrupt stack so that the kernel can handle simultaneous system calls and exceptions aacross multiple processors.\n\n### Two Stacks per Process\nMost operating system kernels go one step further and allocate a kernel interrupt stack for every user-level process. This makes it easier to switch to a new process inside an interrupt or system call handler.\n\n![interrupt-stack](/notes/images/interrupt-stack.png)\n\n- If the process is running on the processor in user mode, its kernel stack is empty.\n- If the process is running on the processor in kernel mode (regardless of cause), its kernel stack is in use, containing the saved registers from the suspended user-level computations and the current state of the kernel handler.\n- If the process is available to run but is waiting on the processorm its kernel stack contains the registers and state to be restored when the process is resumed.\n- If the process is waiting for an I/O event to complete, its kernel stack contains the suspended computation to be resumed when the I/O finishes.\n\n## Interrupt Masking\nIn certain regions of the kernel such as interrupt handlers or a scheduler, taking an interrupt could cause confusion. In such cases, the hardware provides a _privileged instruction_ to temporarily defer the delivery of an interrupt until it is safe to do so.\n\nIf multiple interrupts arrive while interrupts are disabled, the hardware delivers them in turn when interrupts are re-enabled. However, due to the limited buffering of hardwares, some interrupts may be lost.\n\nIf the processor takes an interrupt in kernel mode with interrupts enabled, it is safe to use the current stack pointer rather than resetting it to the base of the interrupt stack.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Inner-product":{"title":"Inner product","content":"\n## Definition\nAn inner product on a [vector space](notes/Vector%20space.md) $V$ over a [field](notes/Field.md) is a function $\\langle \\cdot,\\cdot\\rangle:V^2 \\to F$ that satisfies the followings:\n\nFor arbitrary $\\mathbf{x}, \\mathbf{y}, \\mathbf{z} \\in V$ and $c \\in \\mathbb{R}$,\n\u003e **(1)** $\\langle a\\mathbf{x}+\\mathbf{y},\\mathbf{z}\\rangle = a\\langle \\mathbf{x},\\mathbf{z}\\rangle + \\langle \\mathbf{y},\\mathbf{z}\\rangle$ „ÄÄ(Linearity for the first argument)\n\u003e\n\u003e **(2)** $\\langle \\mathbf{x},\\mathbf{y}\\rangle = \\overline{\\langle \\mathbf{y},\\mathbf{x}\\rangle}$ „ÄÄ(Conjugate symmetry)\n\u003e\n\u003e **(3)**  $\\langle \\mathbf{x},\\mathbf{x}\\rangle \\geq 0;$ $\\langle\\mathbf{x},\\mathbf{x}\\rangle = 0$ if and only if $\\mathbf{x}=\\mathbf{0}$ „ÄÄ(Positive semidefiniteness)\n\n## Examples\n### Standard inner product\n#### Definition\nA standard inner space in $\\mathbb{R}^n$ is defined for $\\mathbf{x} = (x_1, \\cdots, x_n)$ and $\\mathbf{y} = (y_1, \\cdots, y_n)$ as\n$$\n\\langle\\mathbf{x},\\mathbf{y}\\rangle = \\mathbf{x}^\\top\\mathbf{y} = \\sum\\limits_{i=1}^n x_iy_i.\n$$\nNote that for the Euclidean [norm](notes/Norm.md),\n$$\n\\lVert \\mathbf{x} \\rVert_2 = \\sqrt{\\langle\\mathbf{x},\\mathbf{x}\\rangle}.\n$$\n\n#### Angle between vectors\nThe standard inner product on $\\mathbb{R}^n$ is related to the angle between two vectors $\\mathbf{x}, \\mathbf{y}$. Let $\\theta$ be the angle between the two vectors and let $\\mathbf{z}=\\mathbf{x}-\\mathbf{y}$.\nThen, applying the second law of cosine gives\n$$\n\\lVert \\mathbf{z} \\rVert_2^2 = \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\lVert \\mathbf{x} \\rVert_2\\lVert \\mathbf{y}\\rVert_2\\cos\\theta.\n$$\nNow substitute $\\mathbf{z}=\\mathbf{x}-\\mathbf{y}$.\n\n$$\\begin{align*}\n\\lVert \\mathbf{x}-\\mathbf{y} \\rVert_2^2 \u0026= (\\mathbf{x}-\\mathbf{y})^\\top(\\mathbf{x}-\\mathbf{y}) \\\\\n\u0026= \\mathbf{x}^\\top \\mathbf{x} + \\mathbf{y}^\\top\\mathbf{y} -2\\mathbf{x}^\\top\\mathbf{y} \\\\\n\u0026= \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\mathbf{x}^\\top\\mathbf{y} \\\\\n\u0026= \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\lVert \\mathbf{x} \\rVert_2 \\lVert \\mathbf{y} \\rVert_2\\cos\\theta\n\\end{align*}$$\n\nHence,\n$$\n\\cos\\theta = \\dfrac{\\mathbf{x}^\\top\\mathbf{y}}{\\lVert \\mathbf{x} \\rVert_2 \\lVert \\mathbf{y} \\rVert_2}.\n$$","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Isomorphism":{"title":"Isomorphism","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Join-expressions":{"title":"Join expressions","content":"\n## Natural join\nThe **natural join** operation operates on two relations and produces a relation as a result.\n\nIt matches tuples with the same values for **all common attributes**, and retains only one copy of each common attribute.\n```sql\nr_1 NATURAL JOIN r_2\n```\nUnlike the Cartesian product of two relations, natural join considers only those pairs of tuples with the same value on those attributes that appear on the schema of both relations.\n\nIt is an **equi-join** which occurs **implicitly** by comparing all the same name columns in both relations.\n\n## Join conditions\nTo prevent equating attributes erroneously, SQL supports the specification of the join condition.\n\n### `USING` construct\nThe operation `JOIN ... USING` requires a list of attribute names to be specified.\n```sql\nr_1 JOIN r_2 USING(A_1, ... , A_n)\n```\n- `r_i`: Relation\n- `A_i`: Attribute\n\nThe operation is equivalent to:\n```sql\nSELECT  *\nFROM    r_1,\n        r_2\nWHERE   r_1.A_1 = r_2.A_1\nAND     ...\nAND     r_1.A_n = r_2.A_n\n```\nIt is an **equi-join**, and causes duplicate attributes to be **removed** from the resultset.\n\n### `ON` construct\nThe `ON` condition allows a general predicate over the relaions being joined.\\\nThis predicate is wwritten like a `WHERE` clause predicate.\n```sql\nr_1 JOIN r_2 ON p\n```\n- `r_i`: Relation\n- `p`: Predicate\nThe operation is equivalent to:\n```sql\nSELECT  *\nFROM    r_1,\n        r_2\nWHERE   p\n```\nIt is a **theta join**, and it allows duplicate attributes to appear in the resultset.\\\n**Example**\n- All attributes about all students, along with all the courses that they have took\n```sql\nSELECT  *\nFROM    student\nJOIN    takes\nON      student.ID = takes.ID\n```\n- Note that the above query has **two** occurrences for the attribute `ID`, and the relation name of origin must be specified to disambiguate the two.\n\n#### Comparison of `ON` and `USING`\nIn a nutshell, `ON` can be used for most joins, but `USING` is a handy shorthand for the situation where _the column names are the same_.\n\nThe following queries are quivalent.\n```sql\nSELECT  I.title, R.name\nFROM    albums I\nINNER JOIN  artists R\nON      R.artist_id = I.artist_id;\n```\n```sql\nSELECT  title, name\nFROM    albums\nINNER JOIN  artists\nUSING(artist_id);\n```\n\n## Outer join\nThe **outer join** is an extension of the join operation that **avoids loss of information**.\n\nIt computes the join operation, and then adds tuples from one relation that does not match tuples in the other relation to the result of the join, using `NULL` values.\n\nThere are three forms of outer join:\n- **`LEFT OUTER JOIN`**\n\n  Preserves tuples only in the relation named to the left of the `LEFT OUTER JOIN` operation.\n- **`RIGHT OUTER JOIN`**\n  \n  Preserves tuples only in the relation named to the right of the `RIGHT OUTER JOIN` operation.\n- **`FULL OUTER JOIN`**\n  \n  Preserves tuples in both relations.\n\n\n\nIn constrast, the join operations that do not preserve nonmatched tuples are called `INNER JOIN` operations.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Keys":{"title":"Keys","content":"\nWe must have a way to specify how tuples within a given relation are distinguished; no two tuples in a relation are allowed to have exactly the same value for all attributes.\n\nLet $K \\subseteq R$, where $R$ is a [relation schema](Structure%20of%20Relational%20Databases%209c04c2584af142379f668c5078a9d46d.md) for the relation $r$.\n\n- **Superkey**: $K$ is a **superkey** of $R$ if value for $K$ are sufficient to identify a unique tuple of each possible relation instance $r(R)$.\n    - i.e., $\\forall \\;t_1, t_2 \\in R: t_1 \\neq t_2 \\Rightarrow t_1.K \\neq t_2.K$\n- **Candidate key**: A superkey $K$ is a **candidate** key if $|K|$ is at its minimum value.\n- **Primary key**: One of the candidate keys is selected to be the **primary key**.\n    - Usually the most efficient one in terms of computation cost is chosen.\n    - Primary key is chosen by the database designer as the principal means of identifying tuples within a relation.\n    - Also referred to as the **primary key constraint**.\n\nLet $A_i$ be an attribute of relations $r_i$.\n\n- A **foreign-key constraint** from attribute(s) $*A_1$* of relation $*r_1*$ to the primary-key $A_2$ **of relation $*r_2*$ states that on any database instance, the value of $A_1$ **for each tuple in $*r_1*$ must also be the value of $A_2$ **for some tuple in $*r_2*$.\n    - i.e., $\\forall \\, t_1 \\in R_1: \\exists \\,t_2 \\in R_2$ such that $t_1.A_1 = t_2.A_2$\n- Attribute set $A_1$ **is called a **foreign key** from $*r_1*$, referencing $*r_2*$.\n    - The relation $*r_1*$ is also called the **referencing relation**; $r_2$ is also called the **referenced relation**.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Linear-algebra":{"title":"Linear algebra","content":"\nLinear algebra is the branch of mathematics concerning linear equations, linear transformations (maps), and their representations in vector spaces and through matrices.\n\n## Vector Space\n- [Field](notes/Field.md)\n- [Vector space](notes/Vector%20space.md)\n\t- [Subspace](notes/Subspace.md)\n- [Linear combination](notes/Linear%20combination.md)\n\t- [Span](notes/Span.md)\n- [Linear independence](notes/Linear%20independence.md)\n- [Basis](notes/Basis.md)\n\t- [Dimension](notes/Dimension.md)\n- [Coordinates](notes/Coordinates.md)\n\n## Linear Transformation\n- [Linear transformation](notes/Linear%20transformation.md)\n- [Isomorphism](notes/Isomorphism.md)\n- [Fundamental theorem of linear algebra](notes/Fundamental%20theorem%20of%20linear%20algebra.md)\n\n## Determinant\n- [Multilinear form](notes/Multilinear%20form.md)\n\t- [Alternating multilinear form](notes/Alternating%20multilinear%20form.md)\n- [Determinant](notes/Determinant.md)\n\t- [Properties of determinant](notes/Properties%20of%20determinant.md)\n- [Cramer's rule](notes/Cramer's%20rule.md)\n\n## Characteristic Polynomial\n\n## Decomposition Theorems\n\n## Inner Product Space\n- [Inner product](notes/Inner%20product.md)","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Linear-combination":{"title":"Linear combination","content":"\n## Definition\nLet $V$ be a vector space over the field $F$.\nLet $S$ be a nonempty subset of $V$.\nA nonempty vector $\\mathbf{v} \\in V$  is called a **linear combination** of vectors of $S$ if there exist a finite number of vectors $\\mathbf{u}_1, \\cdots, \\mathbf{u}_n$ and scalars $a_i, \\cdots, a_n$ such that\n\n$$\\mathbf{v} = \\sum\\limits\\_{i=1}^na\\_i\\mathbf{u}\\_i.$$\n\nThen, $\\mathbf{v}$ is called a linear combination of vectors $\\mathbf{u}\\_1, \\cdots, \\mathbf{u}\\_n$, and call $a\\_i, \\cdots, a\\_n$ the **coefficients** of the linear combination.\n\n## Observations\n### Observation 1\n\u003eIn any vector space $V$, $0\\mathbf{v} = \\mathbf{0}$ for any $\\mathbf{v} \\in V$.\n\u003e\n\u003eThus the zero vector is a linear combination of any nonempty subset of $V$.\n\n## Related Concepts\n- [Span](notes/Span.md): The set of all linear combinations of some set of vectors","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Linear-independence":{"title":"Linear independence","content":"\n## Definition\nA subset $S$ of a vector space $V$ is called **linearly dependent** if\nthere exist a finite number of distinct vectors $\\mathbf{u}_1, \\cdots, \\mathbf{u}_n$ in $S$\nand scalars $a_1, \\cdots, a_n$, _not all zero_, such that\n\n$$\\sum\\limits\\_{i=1}^n a\\_i\\mathbf{u}\\_i = \\mathbf{0}.$$\n\nIn this case we also say that the vectors of $S$ are linearly dependent.\n\nA subset $S$ of a vector space $V$ that is not linearly dependent is called **linearly independent**.\nWe also say that the vectors of $S$ are linearly independent.\n\n## Theorems\n### Theorem 1\n\u003eLet $V$ be a vector space over a field $F$, and let $S_1 \\subseteq S_2 \\subseteq V$.\n\u003e\n\u003eIf $S_1$ is linearly dependent, then $S_2$ is also linearly dependent.\n\n### Proof\nSince $S\\_1$ is linearly dependent, we can choose some vectors $\\def\\v#1{\\mathbf{#1}} \\v{v}\\_1, \\cdots, \\v{v}\\_n$ such that for some scalars $a\\_1, \\cdots, a\\_n$,\n\n$$\n\\def\\v#1{\\mathbf{#1}}\n\\sum\\limits\\_{i = 1}^n a\\_i\\v{v}\\_i = \\v{0}.\n$$\n\nThen, since $S\\_1 \\subseteq S\\_2$, we know that $\\v{v}\\_i \\in S\\_2$ for all $i = 1, \\cdots, n$. Hence by definition the vectors of $S\\_2$ are linearly dependent.\n$$\\tag*{$||$}$$ \n\n### Corollary\n\u003eLet $V$ be a vector space over a field $F$, and let $S_1 \\subseteq S_2 \\subseteq V$.\n\u003e\n\u003eIf $S_2$ is linearly independent, then $S_1$ is also linearly independent.\n\n### Theorem 2\n\u003eLet $S$ be a linearly independent subset of a vector space $V$, \n\u003eand let $\\mathbf{v}$ be a vector in $V$ that is not in $S$.\n\u003e\n\u003eThen $S \\cup \\{\\mathbf{v}\\}$ is linearly dependent \n\u003eif and only if $\\mathbf{v} \\in \\text{span}(S)$.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Linear-transformation":{"title":"Linear transformation","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Lock":{"title":"Lock","content":"\n## Definition\nA **lock** is a synchronisation variable that provides **mutual exclusion** - when one thread holds a lock, no other thread can hold it.\n\n## APIs\nA lock enables mutual exclusion by providing two methods: `Lock::acquire()` and `Lock::release()`. These methods are defined as follows:\n\n- A lock can be in one of two states: `busy` or `free`.\n- A lock is initially in the `free` state.\n- **`Lock::acquire()`**\n\t- The caller thread **waits** until the lock is `free` and then atomically makes the lock `busy`.\n\t- Checking the state of a lock and setting the state to `busy` are, together, an [atomic operation](notes/Atomic%20operation.md).\n\t- Even if multiple threads try to acquire the lock, at most one thread will succeed.\n- **`Lock::release()`** \n\t- This call makes the lock `free`.\n\t- If there are pending `acquire()` operations, this state change causes one of them to proceed.\n\n## Properties\nA lock should ensure the three properties: **mutual exclusion**, **progress**, and **bounded waiting**. Mutual exclusion ensures [safety](notes/Too%20much%20milk%20problem###Safety), while progress and bounded waiting ensures [liveliness](notes/Too%20much%20milk%20problem###Liveliness).\n\n### Mutual Exclusion\nAt most **one** thread can hold the lock.\n\n### Progress\nIf no thread holds the lock and any thread attempts to acquire the lock, then eventually some thread succeeds in acquiring the lock.\n\n### Bounded Waiting\nIf a thread $T$ attempts to acquire a lock, then there exists a bound on the number of times other threads can successfully acquire the lock before $T$ does.\n\n## Rules for Using Locks\n- **Lock is initially free**.\n- **Always acquire lock before accessing shared data.\n- **Always release after finishing with shared data**.\n- **Never access shared data without acquiring lock**.\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/MIPS-Assembly-language":{"title":"MIPS Assembly language","content":"\n## Operands and operations\n### MIPS Operands\n- **Registers**(2^5 = 32):  `$s0-$s7, $t0-$t9, $zero, $a0-$a3, $v0-$v1, $gp, $fp, $sp, $ra, $at`\n- **Memory words** (2^30): `Memory[X]`\n\n### MIPS assembly language\n| **Category**  | **Instruction**       | **Example**         | **Meaning**              |\n| ------------- | --------------------- | ------------------- | ------------------------ |\n| Arithmetic    | Add                   | `add $s1, $s2, $s3` | `$s1 = $s2 + $s3`        |\n|               | Subtraction           | `sub $s1, $s2, $s3` | `$s1 = $s2 - $s3`        |\n|               | Add immediate         | `addi $s1, $s2, 20` | `$s1 = $s2 + 20`         |\n| Data Transfer | Load word             | `lw $s1, 20($s2)`   | `$s1 = Memory[$s2 + 20]` |\n|               | Store word            | `sw $s1, 20($s2)`   | `Memory[$s2 + 20] = $s1` |\n|               | Load half             | `lh`                |                          |\n|               | Load half unsigned    | `lhu`               |                          |\n|               | Store half            | `sh`                |                          |\n|               | Load byte             | `lb`                |                          |\n|               | Load byte unsigned    | `lbu`               |                          |\n|               | Store byte            | `sb`                |                          |\n|               | Load linked word      | `ll`                |                          |\n|               | Store condition. word | `sc`                |                          |\n|               | Load upper immediate  | `lui $s1, 20`       | `$s1 = 20\u003c\u003c16`           |\n| Logical       | AND                   | `and $s1, $s2, $s3` | `$s1 = $s2 \u0026 $s3`        |\n|               | OR                    | `or $s1, $s2, $s3`  | `$s1 = $s2 | $s3`        |\n|               | NOR                   | `nor $s1, $s2, $s3` | `$s1 = ~($s2 | $s3)`     |\n|               |                       |                     |                          |\n","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Machine-learning":{"title":"Machine learning","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Mathematical-logic":{"title":"Mathematical logic","content":"","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Mode-transfer":{"title":"Mode transfer","content":"\nThe operating system must provide a way to safely transfer between user mode and kernel mode. \n\n## User to Kernel Mode\nThere are three reasons for the kernel to take control from a user process: **interrupts**, **processor exceptions**, and **system calls**.\n\n### Interrupts\nAn **interrupt** is an asynchronous signal to the processor that some external event has occurred that may require its attention. The followings are examples of interrupts.\n\n- Processor timer\n- I/O requests (keyboard, mouse, network, ...)\n\nA processor checks for whether an interrupt has arrived as it executes and, if so, it completes or stalls any instructions that are in progress. On a multiprocessor, an interrupt is taken on only one of the processors. Each different type of interrupt requires its own **interrupt handler**.\n\n### Processor Exceptions\nA **processor exception** is a hadware event caused by (unexpected or malicious) user program behaviour that causes a transfer of control to the kernel. The followings are examples of processor exceptions.\n\n- Performing privileged instruction\n- Accessing memory outside accessible memory region (Segmentation fault)\n- Dividing by zero\n- Writing to read-only memory\n- Accessing a word of memory with a non-aligned address\n- Setting a breakpoint in a program\n\nOn a multiprocessor, the exception only stops execution on the processor triggering the exception. The kernel then needs to send interprocessor interrupts to stop execution of the parallel program on other processors.\n\n### System Calls\nUser programs can voluntarily transition into the operating system kernel that the kernel perform an operation on the user's behalf. A **system call** is any procedure provided by the kernel that can be called from user level. The followings are examples of system calls.\n\n- System call to send/receive packets over the network\n- System call to create/delete files\n- System call to read/write data into files\n- System call to create new user process\n\nTo protect the kernel from misbehaving user programs, it is essential that the hardware transfers control on a ststem call to a _pre-defined_ address. Even with system calls, user processes cannot be allowed to jump to arbitrary places in the kernel.\n\n## Kernel to User Mode\n### New Process\nTo start a new process, the kernel copies the program into memorym, sets the program counter to the first instruction of the process, sets the stack pointer to the base of the user stack, and switches to user mode.\n\n### Resume After an Interrupt, Processor Exception, or System Call\nWhen the kernel finishes handling th erequest, it resumes the execution of the interrupted process by restoring its program counter, restoring its registers, and changing the mode back to user level.\n\n### Switch to Different Process\nThe kernel save the process state of the old process in the process's control block. The kernel can then resume a different process by loading its state from the process's control block into the processor and then switching to user mode.\n\n### User-level Upcall\nMany operating systems provide user programs with the ability to receive any asynchronous notification or events.","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Modification-of-the-database":{"title":"Modification of the database","content":"\n## Deletion\nA delete request can only delete whole tuples; deleting values on only particular attributes is not allowed.\n```sql\nDELETE FROM r\nWHERE       p\n```\n- `r`: Relation\n- `p`: Predicate\n\nThe `DELETE` statement first finds all tuples `t` in `r` for which `P(t)` is true, and then deletes them from `r`.\\\nNote that `DELETE` command operates on only one relation.\n\n**Examples**\n- Delete all tuples from `instructor` table\n```sql\nDELETE FROM instructor;\n```\n- Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building\n```sql\nDELETE FROM instructor\nWHERE       dept_name IN\n(\n    SELECT  dept_name\n    FROM    department\n    WHERE   building = 'Watson'\n);\n```\n- Delete all instructors whose salary is less than the average salary of all instructors\n```sql\nDELETE FROM instructor\nWHERE       salary \u003c\n(\n    SELECT  AVG(salary)\n    FROM    instructor\n);\n```\nSQL first computes the average salary and find all tuples to delete, then delete all corresponding tuples from the relation (**without** recomputing or retesting the tuples).\n\n## Insertion\nTo insert data into a relation, either a tuple to be inserted, or the query whose result is a set of tuples to be inserted, must be specified.\n```sql\nINSERT INTO r\n```\n- `r`: Relation\n\n**Examples**\n- Insert a new tuple to `course`\n```sql\nINSERT INTO course\n    VALUES('CS360', 'Introduction to Database', 'SoC', 3)\n```\n- Make each student in the Music department who has earned more than 144 credit as an instructor in the Music department with a salary of 18000\n```sql\nINSERT INTO instructor\n(\n    SELECT  ID,\n            name,\n            dept_name,\n            18000\n    FROM    student\n    WHERE   dept_name = 'MUSIC'\n            AND tot_credit \u003e 144\n); \n```\nThe `SELECT` - `FROM` - `WHERE` statement is **evaluated fully before** any of its results are inserted into the relation.\n\n## Update\nA value in a tuple can be changed without changing _all_ values in the tuple with the `UPDATE` statement.\n```sql\nUPDATE  r\nSET     A = (Some Value)\nWHERE   p\n```\n- `r`: Relation\n- `A`: Attribute\n- `p`: Predicate\n\n**Examples**\n- Give a 5% salary raise to those instructors who earn less than 70000\n```sql\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c 70000;\n```\n- Give a 5% salary raise to instructors whose salary is less than the average of all instructors\n```sql\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c\n(\n    SELECT  AVG(salary)\n    FROM    instructor\n);\n```\nNote that the order of `UPDATE` statements is very important.\\\nConsider the following query.\n```sql\n-- Update 1\nUPDATE  instructor\nSET     salary = salary * 1.03\nWHERE   salary \u003e 100000\n-- Update 2\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c= 100000\n```\nIf the order of the two updates are changed, the results whould not be as desired.\\\nTo prevent order related problems, `CASE` construct is provided by SQL.\n\n### `CASE` construct\n`CASE` construct can be used in any place where a value is expected.\n```sql\nCASE\n    WHEN  P_1 THEN  R_1\n    ...\n    WHEN  P_n THEN  R_n\n    ELSE            R_0\nEND\n```\n- `P_i`: Predicates\n- `R_i`: Resulting value\n  \nThe error-prone query above can be re-written using `CASE` construct.\n```sql\nUPDATE  instructor\nSET     salary =\n(\n    CASE\n        WHEN salary \u003c= 100000 THEN salary * 1.05\n        ELSE salary * 1.03\n    END\n);\n```\n### Updates with scalar subqueries\nScalar subqueries are also useful in SQL update statements, where they can be used in `SET` clause.\n\n**Example**\n- Recompute and update `tot_credit` for all students to the credits of courses successfully completed by the student (successfully completed means `grade` is not `F` nor `NULL`)\n```sql\nUPDATE  student S\nSET     tot_credit =\n(\n    SELECT  SUM(credits)\n    FROM    takes JOIN course USING(course_id)\n    WHERE   S.ID = takes.ID AND\n            (\n                takes.grade \u003c\u003e 'F' AND\n                takes.grade IS NOT NULL\n            )\n);\n```","lastmodified":"2022-10-16T02:38:57.105338229Z","tags":null},"/notes/Multilinear-form":{"title":"Multilinear form","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Nested-subqueries":{"title":"Nested subqueries","content":"\nA **subquery** is a `SELECT` - `FROM` - `WHERE` expression that is nested within another query.\n\nSQL provides a mechanism for the nesting of subqueries.\n\n## Set membership\n\nSQL allows testing tuples for membership in a relation, using `IN` or `NOT IN` clause.\n\n**Examples**\n- Name all instructors whose name is neither ‚ÄúMozart‚Äù nor ‚ÄúEinstein‚Äù\n\n```sql\nSELECT  DISTINCT name\nFROM    instructor\nWHERE   name NOT IN ('Mozart', 'Einsten');\n```\n\n- Find all the courses taught in the Fall 2009 semester, but not in the Spring 2010 semester\n\n```sql\nSELECT  DISTINCT course_id\nFROM    section\nWHERE   semester = 'Fall' AND year = 2009 AND course_id NOT IN\n(\n\tSELECT  course_id\n\tFROM    section\n\tWHERE   semester = 'Spring' AND year = 2010\n);\n```\n\n- Find the total number of distinct students who have taken course sections taught by the instructor with ID `10101`\n- As seen in the example query below, it is possible to test for membership in an arbitrary relation.\n\n```sql\nSELECT  COUNT(DISTINCT ID)\nFROM    takes\nWHERE   (course_id, sec_id, semester, year) IN\n(\n    SELECT  course_id, sec_id, semester, year\n\tFROM    teaches\n\tWHERE   teaches.ID = 10101\n);\n```\n    \n\n## Set comparison\n\n### `SOME` clause\n\n`SOME` clause can check if the predicate is satisfied by at least one tuple in the relation.\n\n- `F \u003ccomp\u003e SOME r` $\\Leftrightarrow$\n$\\exists \\, t \\in r$  such that $(F\\;\\texttt{\u003ccomp\u003e}\\; t)$, where $\\texttt{\u003ccomp\u003e} \\in \\{\u003c, \\leq, \u003e, \\geq, =, \\neq\\}$\n- `= SOME` $\\Leftrightarrow$ `IN`, however `\u003c\u003e SOME` $\\not\\Leftrightarrow$ `NOT IN`\n\n**Example**    \nFind names of instructors with salary greater than that of some (at least one) instructor in the Biology department\n\n```sql\nSELECT  DISTINCT T.name\nFROM    instructor AS T,\n\t\t\t\tinstructor AS S\nWHERE   T.salary \u003e S.salary AND S.dept_name = 'Biology';\n```\n\n```sql\n-- Using SOME clause\nSELECT  name\nFROM    instructor\nWHERE   salary \u003e SOME\n(\n    SELECT  salary\n    FROM    instructor\n\tWHERE   dept_name = 'Biology'\n);\n```\n    \n\n### `ALL` clause\n\n`ALL` clause can check if the predicate is satisfied by all of the tuples in the relation.\n\n- `F \u003ccomp\u003e ALL r` $\\Leftrightarrow$\n$\\forall\\, t \\in r$ such that $(F \\;\\texttt{\u003ccomp\u003e}\\; t)$, where  $\\texttt{\u003ccomp\u003e} \\in \\{\u003c, \\leq, \u003e, \\geq, =, \\neq\\}$\n- `\u003c\u003e ALL` $\\Leftrightarrow$ `NOT IN`, however `= ALL` $\\not\\Leftrightarrow$ `IN`\n\n**Example**    \nFind the names of all instructors whose salary is greater the salary of all instructors in the Biology department\n\n```sql\nSELECT  name\nFROM    instructor\nWHERE   salary \u003e ALL\n(\n    SELECT  salary\n\tFROM    instructor\n\tWHERE   dept_name = 'Biology'\n);\n```\n    \n\n## Test for empty relations\n\nThe `EXISTS` construct returns the value `TRUE` if the argument subquery is nonempty.\n\n- `EXISTS r` $\\Leftrightarrow$ $r \\neq \\emptyset$\n- `NOT EXISTS r` $\\Leftrightarrow$ $r = \\emptyset$\n\n**Example**\n\n- Find all students who have taken all courses offered in the Biology department\n\n```sql\nSELECT  DISTINCT S.ID,\n\t\t    S.name\nFROM    student AS S\nWHERE   NOT EXISTS\n(\n\tSELECT  course_id\n\tFROM    course\n\tWHERE   dept_name = 'Biology'\n\tEXCEPT\n\tSELECT  T.course_id\n\tFROM    takes AS T\n\tWHERE   S.ID = T.ID\n);\n```\n\n- Note that $X - Y = \\emptyset \\Leftrightarrow X \\subseteq Y$\n- This query **cannot** be written using `= ALL` and its variants\n## Test for the absence of duplicate tuples\n\nThe `UNIQUE` construct tests whether a subquery has any duplicate tuples in its result.\n\nIt evaluates to `TRUE` if a given subquery contains no duplicates.\n\n**Example**\n    \n- Find all courses that were offered at most once in 2017\n\n```sql\nSELECT  T.course_id\nFROM    course AS T\nWHERE   UNIQUE\n(\n\tSELECT  R.course_id\n\tFROM    course AS R\n\tWHERE   T.course_id = R.course_id AND\n\t\t\tR.year = 2017\n);\n```\n    \n\n## Subqueries in the `FROM` clause\nSince any `SELECT` - `FROM` - `WHERE` clause returns a relation as a result, it can be inserted into another `SELECT` - `FROM` - `WHERE` aanywhere that a relation can appear.\n\n**Example**\n\nFind the average instructors' salaries of those departments where the average salary is greater than 42000\n```sql\nSELECT  dept_name,\n        avg_salary\nFROM\n(\n    SELECT  dept_name,\n            AVG(salary) AS avg_salary\n    FROM    instructor\n    GROUP BY dept_name\n)\nWHERE   avg_salary \u003e 42000;\n```\n- Since the subquery in the `FROM` clause computes the average salary, `HAVING` query is not required; the predicate is rather inside the `WHERE` clause of the outer query.\n- The above query is equivalent to\n```sql\nSELECT  dept_name,\n        AVG(salary) AS avg_salary\nFROM    instructor\nGROUP BY dept_name\nHAVING  avg_salary \u003e 42000\n```\n\n## `WITH` clause\nThe `WITH` clause provides a way of defining a temporary relation whose definition is available **only** to the query in which the `WITH` clause occurs.\n\n**Examples**\n- Find all departments with the maximum budget\n```sql\nWITH    max_budget(value) AS\n(\n    SELECT  MAX(budget)\n    FROM    department\n)\nSELECT  department.dept_name\nFROM    department,\n        max_budget\nWHERE   department.budget = max_budget.value\n```\n- Find all departments where the total salary is greater than the average of the total salary at all departments\n```sql\nWITH    dept_total(dept_name, value) AS\n(\n    SELECT  dept_name,\n            SUM(salary)\n    FROM    departments\n    GROUP BY dept_name\n),\n        dept_total_avg(value) AS\n(\n    SELECT AVG(value)\n    FROM   dept_total\n)\nSELECT  dept_name\nFROM    dept_total,\n        dept_total_avg\nWHERE   dept_total.value \u003e dept_total_avg.value;\n```\n\n## Scalar subquery\nScalar subqeury is used where a **single value** is expected. It incurs a runtime error if the subquery returns more than one result tuple.\n\n**Example**\n- Find all departments, along with the number of instructors, in each department\n```sql\nSELECT  dept_name,\n(\n    SELECT  COUNT(*)\n    FROM    instructor\n    WHERE   department.dept_name = instructor.dept_name\n    GROUP BY dept_name\n)       AS num_instructors\nFROM    department;\n```","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Norm":{"title":"Norm","content":"## Intuition\nWIP\n\n## Definition\nA function $\\lVert\\cdot\\rVert: V\\to \\mathbb{R}$ is a norm if it satisfies the followings:\n\nFor arbitrary $\\mathbf{x},\\mathbf{y}\\in V$ and $c \\in \\mathbb{R}$,\n\n\u003e **(1)**    $\\lVert\\mathbf{x}+\\mathbf{y}\\rVert \\leq \\lVert\\mathbf{x}\\rVert + \\lVert\\mathbf{y}\\rVert$ „ÄÄ(Subadditivity)\n\u003e\n\u003e **(2)**    $\\lVert c\\mathbf{x}\\rVert = |c|\\lVert\\mathbf{x}\\rVert$ „ÄÄ(Absolute homogeneity)\n\u003e\n\u003e **(3)**    $\\lVert\\mathbf{x}\\rVert\\geq 0;$ $\\lVert\\mathbf{x}\\rVert = 0$ if and only if $\\mathbf{x}=\\mathbf{0}$ „ÄÄ(Positive semidefiniteness)\n\n## $L_p$-Norms\n### Definition\nFor $\\mathbf{x} = (x_1, \\cdots, x_n) \\in \\mathbb{R}^n$, an $L^p$-norm when $1\\leq p \u003c \\infty$ is defined as:\n\n$$\\lVert\\mathbf{x}\\rVert_p := \\left( \\sum\\limits_{i=1}^n |x_i|^p\\right)^{1/p}$$\n\nFor $p = \\infty$, the $L_\\infty$-norm is defined as:\n\n$$\\lVert\\mathbf{x}\\rVert_\\infty := \\sup\\limits_i |x_i|.$$\n\nFor $p=0$, the $L_0$-\"norm\"[^-1] is defined as:\n$$\\lVert\\mathbf{x}\\rVert_0 := \\text{card}(\\mathbf{x}) = \\sum\\limits_{i=1}^n \\mathbb{I}(x_i \\neq 0)$$\n\nwhere\n\n$$\\mathbb{I}(x_i \\neq 0) :=\n\\begin{cases}\n1 \\qquad \\text{if„ÄÄ} x_i \\neq 0\\\\\n0 \\qquad\\text{otherwise.}\n\\end{cases}$$\n\nThe $L_2$-norm is also called the Euclidean norm.\n\n## Unit Balls\nThe set of all vectors with $L_p$-norm less than or equal to $1$,\n$$\\mathcal{B}_p = \\lbrace\\mathbf{x} \\in \\mathbb{R}^n:\\lVert\\mathbf{x}\\rVert_p \\leq 1 \\rbrace$$\nis called the unit $L_p$-norm ball.\nThe following figure shows the shapes of the $\\mathcal{B}_p$ balls in $\\mathbb{R}^2$ for $p\\in \\{1/2, 1, 1.1, 4/3, 2, \\infty\\}$.\n\n![various-unit-balls](/notes/images/various-unit-balls.png)\n\n[^-1]: This is a slight abuse in the term as $L^0$-\"norm\" does not satisfy the second property(absolute homogeneity). This is justified as $$\\text{card}(\\mathbf{x}) = \\lim\\limits_{p \\to 0}\\left( \\sum\\limits_{i=1}^n |x_i|^p\\right)^{1/p}.$$","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Null-values-in-SQL":{"title":"Null values in SQL","content":"\n**`NULL` values** signifies an unknown value or that a value does not exist.\n\n## Arithmetic operations\n\nThe result of **any** arithmetic expression involving `NULL` is `NULL`.\n\n## Comparison operations\n\nSQL treats as `UNKNOWN` the result of **any** comparison involving a `NULL` value, other than `IS NULL` and `IS NOT NULL`.\n\nThe predicate in a `WHERE` clause can involve Boolean operations such as `AND`, `OR`, and `NOT`.\n\n- **`AND`**\n    - `TRUE AND UNKNOWN` = `UNKNOWN`\n    - `FALSE AND UNKNOWN` = `FALSE`\n    - `UNKNOWN AND UNKNOWN` = `UNKNOWN`\n- **`OR`**\n    - `UNKNOWN OR TRUE` = `TRUE`\n    - `UNKNOWN OR FALSE` = `UNKNOWN`\n    - `UNKNOWN OR UNKNOWN` = `UNKNOWN`\n- **`NOT`**\n    - `NOT UNKNOWN` = `UNKNOWN`\n\nThe result of `WHERE` clause predicate is treated as `FALSE` if the value evaluates to `UNKNOWN`.\n\n## `IS NULL` and `IS NOT NULL`\n\nThe predicate `IS NULL` can be used to check for `NULL` values.\n\nThe predicate `IS NOT NULL` succeeds if the value on which it is applied is not `NULL`.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Operating-systems":{"title":"Operating systems","content":"\n## Kernels and Processes\n- [Process](notes/Process.md)\n- [Dual-mode operation](notes/Dual-mode%20operation.md)\n- [Mode transfer](notes/Mode%20transfer.md)\n\t- [Implementation of mode transfer](notes/Implementation%20of%20mode%20transfer.md)\n\t- [x86 Mode transfer](notes/x86%20Mode%20Transfer.md)\n- [Secure system call](notes/Secure%20system%20call.md)\n- [System upcalls](notes/System%20upcalls.md)\n\n## Concurrency and Threads\n- [Thread](notes/Thread.md)\n\t- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)\n\t- [Thread data structures](notes/Thread%20data%20structures.md)\n\t- [Thread life cycle](notes/Thread%20life%20cycle.md)\n\t- [Thread models](notes/Thread%20models.md)\n\n## Synchronisation\n- [Atomic operation](notes/Atomic%20operation.md)\n- [Critical section](notes/Critical%20section.md)\n- [Race condition](notes/Race%20condition.md)\n\t- [Too much milk problem](notes/Too%20much%20milk%20problem.md)\n\t- [Bounded buffer problem](notes/Bounded%20buffer%20problem.md)\n- [Lock](notes/Lock.md)\n- [Condition variable](notes/Condition%20variable.md)\n- [Semaphore](notes/Semaphore.md)\n- [Deadlock](notes/Deadlock.md)\n\n## Scheduling\n- [Separation of mechanism and policy](notes/Separation%20of%20mechanism%20and%20policy.md)\n- ","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Overview-of-SQL":{"title":"Overview of SQL","content":"\n## SQL Parts\n\n- **Data-Definition Language (DDL)**\n    \n    Provides commands for defining relation schemas, deleting relations, and modifying relation schemas.\n    \n- **Data-Manipulation Language (DML)**\n    \n    Provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database.\n    \n- **Integrity**\n    \n    Provides commands for specifying integrity constraints that the data stored in the database must satisfy.\n    \n- **View Definition**\n    \n    Provides commands for defining views.\n    \n- **Transaction Control**\n    \n    Provides commands for specifying the beginning and ending of transactions.\n    \n- **Embedding SQL \u0026 Dynamic SQL**\n    \n    Define how SQL statements can be embedded within general-purpose programming languages.\n    \n- **Authorisation**\n    \n    Provides commands for specifying access rights to relations and views.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Parser":{"title":"Parser","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Performance":{"title":"Performance","content":"\n## Defining Performance\n- **Response time (execution time)**: The time between start and completion of a task\n- **Throughput (Bandwidth)**: The number of tasks completed per unit time\n\n## Measuring Performance\n- **Clock cycle** (s): The time for one clock period (usually the processor clock) - constant\n- **Clock rate** (Hz): The inverse of clock period\n- **CPU execution time**: The time CPU spends computing for a certain task (does not include time spent waiting for I/O or running other programs)\n$$\n\\begin{align*}\n\\text{CPU time} \u0026= \\text{CPU clock cycles} \\times \\text{Clock cycle time}\\\\\n\u0026= \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}\n\\end{align*}\n$$\n- **CPI (Clock cycles per instruction)**: The average number of clock cycles per instruction for a program or program fragment.\n$$\n\\begin{align*}\n\\text{CPU clock cycles} = \\text{Total number of instructions} \\times \\text{CPI}\n\\end{align*}\n$$\nTherefore, we have the following.\n$$\n\\begin{align*}\n\\text{CPU time} \u0026= \\frac{\\text{Instruction count} \\times \\text{CPI}}{\\text{Clock rate}}\n\\end{align*}\n$$\n","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Process":{"title":"Process","content":"\nA **process** is an instance of a program; it is the execution of a program with restricted rights. Processes provide the illusion of an infinite number of _machines_. Each program can have zero, one, or more processes executing it. For each instance of a program, there is a process with its own copy of the program in memory.\n\nThe operating system keeps track of the processes on the computer using a data structure called the **process control block** (PCB).\n\n\n## Comparison with [threads](notes/Thread.md)\n- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Programming-language-theory":{"title":"Programming language theory","content":"\n**Programming language theory** (**PLT**) is a branch of [computer science](index/Computer%20science.md) that deals with the design, implementation, analysis, characterisation, and classification of formal languages known as programming languages and of their individual features.\n\n## Syntax and Semantics\n- [Syntax](notes/Syntax.md)\n\t- [Concrete syntax](notes/Concrete%20syntax.md)\n\t- [Abstract syntax](notes/Abstract%20syntax.md)\n\t- [Parser](notes/Parser.md)\n- [Semantic](notes/Semantic.md)\n- Identifier\n\t- Interpreter\n\n## Functions\n- First-order function\n- First-class function\n- Recursion\n\n## Mutability\n- Box\n- Mutable variable\n","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Properties-of-determinant":{"title":"Properties of determinant","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Purpose-of-database-systems":{"title":"Purpose of database systems","content":"\nIn the early days, [database](notes/Database%20systems.md) applications were built directly on top of file systems, which leads to several disadvantages.\n\n- **Data redundancy and inconsistency**: Data is stored in multiple file formats, resulting in duplication of information in different files. In addition, this may lead to data inconsistency, where the various copies of the same data no longer agree.\n- **Difficulty in accessing data**: Conventional file-processing environments do not allow needed data to be retrieved in a convenient and efficient manner.\n- **Data isolation**: Because data are scattered in _various files_, and files may be in _different formats_, writing new application programs to retrieve the appropriate data is difficult.\n- **Integrity problems**: The data values stored in the database must satisfy certain types of _integrity constraints_(e.g., `account_balance \u003e= 0`). Without database systems, these integrity constraints become buried in the program code, making it hard to add new constrains or change existing ones.\n- **Atomicity problems**: Failures may leave data in an inconsistent state with only partial updates carried out; data update must be _[atomic](notes/Atomic%20operation.md)_. It is difficult to ensure atomicity in a conventional file-processing system.\n- **Concurrent access anomalies**: For the sake of overall performance, many systems allow concurrent access to data. However, uncontrolled concurrent access can lead to data inconsistencies.\n- **Security problems**: Not every user of the database system should be able to access all the data. It is hard to provide user access to som, but not all, data in conventional file-processing environments.\n\n[Database systems](notes/Database%20systems.md) offer solutions to all of the above problems.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Race-condition":{"title":"Race condition","content":"\n## Definition\nA **race condition** is a situation where multiple process access and manipulate _the same data_ concurrently, and the outcome of the execution depends on _the particular order_ (interleaving) of such accesses.\n\n## Example\nSuppose that initially `y = 12`, and a program with two threads that do the following is run.\n\n| Thread A    | Thread B    |\n| ----------- | ----------- |\n| `x = y + 1` | `y = y * 2` |\n\n- If thread A reads `y` before thread B updates `y`, the result is `x = 13`.\n- Otherwise, the result is `x = 25`.\n\nSuppose that initially `x = 0`, and a program with two threads that do the following is run.\n\n| Thread A    | Thread B     |\n| ----------- | ------------ |\n| `x = 1`     | `y = 2`      |\n| `x = y + 1` | `y = y * 2*` |\n\n- If thread A runs to completion and then thread B starts and runs to completion, the result is `x = 1`.\n- If thread B runs to completion and then thread A starts and runs to completion, the result is `x = 5`.\n- If thread B executes `y = 2` and interleaves - thread A starts and runs to completion - and thread B executes `y = y * 2`, the result is `x = 3`.\n- If thread A executes `x = 1` and interleaves - thread B starts and runs to completion - and thread A executes `x = y + 1`, the result is `x = 5`.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Relational-algebra":{"title":"Relational algebra","content":"\nA **relational algebra** is a procedural [query language](Relational%20Query%20Language%2009b57cd8794a4887bb519f82b7ce98e7.md) consisting of a set of operations that take one or two relations as input and produce a new relation as their result.\n\nThere are six basic operators: $\\sigma$(Selection), $\\Pi$(Projection), $\\cup$(Union), $-$(Set difference), $\\times$(Cartesian product), and $\\rho$(Rename).\n\nNote that there are **equivalent queries**; there may be multiple ways to write a query in relational algebra.\n\n## Selection\n\nThe unary selection operator $\\sigma$ selects tuples that satisfy a given predicate.\n\n- $\\sigma_p(r)$, where $p$ is a selection predicate and $r$ is a relation.\n    - e.g., $\\sigma_{\\texttt{dept\\_name=\"Physics\"}}(\\texttt{Instructor})$\n- Comparisons uses $=, \\neq, \u003e, \\geq, \u003c, \\leq$ in the selection predicate.\n- Predicates are combined using $\\wedge, \\vee, \\neg$.\n- The select predicate may include comparisons between two different attributes.\n\n---\n\n## Projection\n\nThe unary projection operator $\\Pi$ returns its argument relation with certain attributes removed.\n\n- $\\Pi_{A_1, \\cdots, A_k}(r)$, where $A_i$s are attributes and $r$ is a relation.\n    - e.g., $\\Pi_{\\texttt{ID,name,salary}}(\\texttt{Instructor})$\n- Duplicate rows are removed from the result\n\n---\n\n## Cartesian Product\n\nThe binary cartesian operator $\\times$ combines information from two relations.\n\n It constructs a tuple of the result out of *each possible pair of tuples*.\n\n- $r_1 \\times r_2$, where $r_1$ and $r_2$ are relations.\n    - e.g., $\\texttt{Instructor} \\times \\texttt{Teaches}$\n- To distinguish between attributes present in both relations, attach the name of the originating relation to the name of the attribute.\n    - e.g., $\\texttt{Instructor}.\\texttt{ID}, \\texttt{Teaches}.\\texttt{ID}$\n\n### Join\n\nJoin operator $\\bowtie$ is a composition of a cartesian product followed by a selection operation.\n\nIt returns only those tuples that satisfy some predicate(s), among all possible combinations of tuples from the two relations.\n\nIt does *not* belong to the six basic operations.\n\n- $r_1\\bowtie_\\theta r_2 := \\sigma_\\theta(r_1\\times r_2)$, where $r_1(R_1)$, $r_2(R_2)$ are relations, and $\\theta$ is a predicate on attributes on the schema $R_1 \\cup R_2$.\n    - e.g., $\\texttt{Instructor} \\bowtie_{\\texttt{Instructor.ID=Teaches.ID}}\\texttt{Teaches}$\n\n---\n\n## Union\n\nThe binary union operator $\\cup$ combines two relations.\n\nIt returns all tuples that are present in at least one of the relations.\n\nTwo relations *must* satisfy the condition $[(*)](Relational%20Algebra%20d48d3c6b16584d9f96d66cfc182e0d6f.md)$.\n\n- $r_1 \\cup r_2$, where $r_1$ and $r_2$ are relations.\n    - e.g., Find all courses taught in fall 2017, or in spring 2018, or in both:\n    $\\Pi_{\\texttt{course\\_ID}}(\\sigma_{\\texttt{semester=\"Fall\"}\\wedge\\texttt{year=2017}}(\\texttt{Section})) \\cup \\Pi_{\\texttt{course\\_ID}}(\\sigma_{\\texttt{semester=\"Spring\"}\\wedge\\texttt{year=2018}}(\\texttt{Section}))$\n\n### Intersection\n\nThe binary union operator $\\cap$ combines two relations.\n\nIt returns all tuples that are present in both of the relations.\n\nTwo relations *must* satisfy the condition $[(*)](Relational%20Algebra%20d48d3c6b16584d9f96d66cfc182e0d6f.md)$.\n\n- $r_1 \\cap r_2$, where $r_1$ and $r_2$ are relations.\n\n---\n\n## Set Difference\n\nThe binary union operator $-$ combines two relations.\n\nIt returns all tuples that are present in the preceding relation, but not in the succeeding relation.\n\nTwo relations *must* satisfy the condition $[(*)](Relational%20Algebra%20d48d3c6b16584d9f96d66cfc182e0d6f.md)$.\n\n- $r_1 - r_2$, where $r_1$ and $r_2$ are relations.\n\n---\n\n## Rename\n\nThe unary rename operator $\\rho$ assigns a name to the results of relational algebra expressions.\n\nIt returns the result of the expression under the given name.\n\n- $\\rho_{x(A_1, \\cdots, A_k)}(E)$, where $A_i$s are attributes, $E$ is a relational algebra expression, and $x$ is a name.\n\n### Assignment\n\nAssignment operation $\\leftarrow$ assigns a relational algebra expression to a temporary relation variable.\n\nIt acts similar as the assignment operation in general-purpose programming languages.\n\n- $x \\leftarrow E$, where $x$ is a name and $E$ is a relational algebra expression.\n    - e.g., Find all instructors in any of the Physics or Music departments:\n    $\\texttt{PH} \\leftarrow \\sigma_{\\texttt{dept\\_name=\"Physics\"}}(\\texttt{Instructor})$\n    $\\texttt{MU} \\leftarrow \\sigma_{\\texttt{dept\\_name=\"Musics\"}}(\\texttt{Instructor})$\n    $\\texttt{PH} \\cup \\texttt{MU}$\n- With the assignment operation, a query can be written as a sequential program consisting of a series of assignments, followed by an expression whose value is displayed as the result of the query.\n\n---\n\n**Condition $(*)$:**\n\n- Two relations must have the same arity.\n- The attributes of the two relations must be compatible.\n\n---","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Relational-query-language":{"title":"Relational query language","content":"\nA **query language** is a language in which a user requests information from the database.\n\nThere are some ‚Äòpure‚Äô query languages, equivalent in computing power.\n\n- [Relational algebra](Relational%20Algebra%20d48d3c6b16584d9f96d66cfc182e0d6f.md)\n- Tuple relational calculus\n- Domain relational calculus","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/SQL-data-definition":{"title":"SQL data definition","content":"\n## Domain types in SQL\n\n- **`char(n)`**\n  \n    Fixed-length character string, with user-specified length `n`\n    \n- **`varchar(n)`**\n  \n    Variable-length character string, with user-specified **maximum** length `n`\n    \n- **`int`**\n  \n    Integer (machine-dependent)\n    \n- **`smallint`**\n  \n    Small integer (machine-dependent)\n    \n- **`numeric(p, d)`**\n  \n    Fixed-point  number, with user-specified precision of `p` digits (plus a sign), with `d` digits to the right of the decimal point\n    - `numeric(3, 1)` allows `44.5` to be stored exactly, but neither `444.5` or `0.32` can be stored exactly.\n  \n- **`real`, `double precision`**\n  \n    Floating-point and double precision floating-point numbers (machine-dependent precision)\n    \n- **`float(n)`**\n  \n    Floating-point number, with user-specified precision of at least `n` digits\n    \n\n## Basic schema definition\n\nAn SQL relation is defined using the `create table` command.\n\n```sql\nCREATE TABLE r\n(\n\tA_1 D_1,\n\t... ,\n\tA_n D_n,\n\t[Integrity Constraint 1],\n\t... ,\n\t[Integrity Constraint k]\n)\n```\n\n- `r`: Name of the relation\n- `A_i`: Attribute name in the schema of the relation `r`\n- `D_i`: Data type of values in the domain of attribute `A_i`\n\n**Example**\n```sql\nCREATE TABLE instructor\n(\n\tID           char(5),\n\tname         varchar(20) NOT NULL,\n\tdept_name    varchar(20),\n\tsalary       numeric(8, 2),\n\tPRIMARY KEY(ID),\n\tFOREIGN KEY(dept_name) REFERENCES department\n);\n```\n    \n\n### Integrity Constraints\n\n- **`PRIMARY KEY(A_1, ... , A_n)`**\n    - Attributes `A_1`, ‚Ä¶ , `A_n` form the primary key for the relation.\n    - Required to be *nonnull* and *unique*.\n    \n- **`FOREIGN KEY(A_1, ... , A_n) REFERENCES s`**\n    - Values of attributes `(A_1, ... , A_n)` for any tuple in the relation *must* correspond to values of the **primary key** attributes of some tuple in relation `s`\n    \n- **`NOT NULL`**\n    - `NULL` value is not allowed for that attribute\n    \n\n### Updates to Tables\n\n- **`INSERT INTO s t`**\n    - Inserts tuple `t` into the relation `s`\n    - e.g., `INSERT INTO instructor VALUES('10211', 'Smith', 'Biology', 66000)`\n\n- **`DELETE FROM s t`**\n    - Deletes tuple `t` from the relation `r`\n    - e.g., `DELETE FROM student` deletes **all** tuples from the relation `student`\n    \n- **`DROP TABLE r`**\n    - Deletes all information of `r`, including the table itself, from the database\n    - After `r` is dropped, no tuples can be inserted into it unless it is re-created with the `CREATE TABLE` command\n    \n- **`ALTER`**\n    - **`ALTER TABLE r ADD A D`**\\\n        `A` is the name of the attribute to be added to relation `r`, and `D` is the domain of `A`\n        \n        All existing tuples in the relation are assigned `NULL` as the value for the new attribute\n        \n    - **`ALTER TABLE r DROP A`**\\\n        `A` is the name of an attribute of relation `r`","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Secure-system-call":{"title":"Secure system call","content":"\n## Importance\nThe kernel must implement its system calls in a way that protects itself from all errors and attacks that might be launched by the misuse of the interface. That is, the kernel should always assume that the parameters passed to a system call are intentionally designed to be as _malicious_ as possible.\n\n## Implementation of a Secure System Call\n\n![secure-syscall](/notes/images/secure-syscall.png)\n\n1. The user program calls the user stub in the normal way, oblivious to the fact the implementation of the procedure is in fact in the kernel.\n2. The user stub fills in the code for the system call and executes the trap instruction.\n3. The hardware transfers control to the kernel, vectoring to the system call handler. The handler acts as a stub on the kernel side, **copying** and checking arguments and then calling the kernel implementation of system call.\n4. After the system call completes, it returns to the handler.\n5. The handler returns to user level at the next instruction in the stub.\n6. The stub returns to the caller.\n\n## Tasks of the Kernel Stub\n### Locate system call arguments\nUnlike a regular kernel procedure, the arguments to a system call are stored in user memory. Since the user stack pointer may be corrupted, the stub must check the address to verify whether the pointer argument is a legal address within the user domain. If it is legal, the stub converts the virtual address into a physical address.\n\n### Validate parameters\nThe kernel must protect itself against malicious or accidental errors in the format or content of its arguments. If an error is detected, the kernel returns to the user program.\n\n### Copy before check\nAn application might modify the parameter _after_ the stub checks its value but _before_ the parameter is used in the actual implementation of the routine. This is called a **time of check vs. time of use (TOCTOU) attack**. To prevent this, kernel copies the system call parameters into kernel memory before performing the necessary checks.\n\n### Copy back any results\nFor the user program to access the results of the system call, the stub must copy the result from the kernel into user memory. The kernel must translate the physical address into virtual address before performing the copy.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Semantic":{"title":"Semantic","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Semaphore":{"title":"Semaphore","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Separation-of-mechanism-and-policy":{"title":"Separation of mechanism and policy","content":"\n## Definition\nThe separation of **mechanism** and **policy** is a design principle in computer science. According to the separation of mechanism and policy principle, mechanism should work no matter what policy is used.\n\n- **Mechanism** is a part of a system implementation that control the authorisation of operations and the allocation of resources.\n- **Policy** determines _which_ decisions are made about which operations to authorise, and which resources to allocate.\n\nFor example, when considering a [thread context switch](notes/Mode%20transfer.md), **mechanism** decides _how to switch between threads_, and **policy** determines _which thread to run next_.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Set-operations-in-SQL":{"title":"Set operations in SQL","content":"\n## `UNION` operation\n\nThe SQL operation `UNION` corresponds to the mathematical operation $\\cup$.\n\n```sql\nR1 UNION R2\n```\n\nThe `UNION` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `UNION ALL` operation instead.\n\n## `INTERSECT` operation\n\nThe SQL operation `INTERSECT` corresponds to the mathematical operation $\\cap$.\n\n```sql\nR1 INTERSECT R2\n```\n\nThe `INTERSECT` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `INTERSECT ALL` operation instead.\n\n## `EXCEPT` operation\n\nThe SQL operation `EXCEPT` corresponds to the mathematical operation $\\setminus$.\n\n```sql\nR1 EXCEPT R2\n```\n\nThe `EXCEPT` operation outputs all tuples from `R1` that do not occur in `R2`.\n\nThe `EXCEPT` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `EXCEPT ALL` operation instead.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Set-theory":{"title":"Set theory","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Span":{"title":"Span","content":"\n## Definition\nLet $S$ be a nonempty subset of a vector space $V$.\\\nThe **span** of $S$, denoted $\\text{span}(S)$ or $\\langle S \\rangle$,\nis the set consisting of all linear combinations of the\nvectors in $S$.\n\nWe define $\\text{span}(\\emptyset) = \\{0\\}$ for convenience.\nA subset $S$ of a vector space $V$ **generates** (or **spans**) $V$\nif $\\text{span}(S) = V$.\\\nIn this case, we also say that the vectors of $S$ generate (or span)\n$V$.\n\n## Theorems\n### Theorem 1 *[^1]\n\u003eThe span of any subset $S$ of a vector space $V$ is a [subspace](notes/Subspace.md) of $V$ that contains $S$.\n\u003e\n\u003eMoreover, any [subspace](notes/Subspace.md) of $V$ that contains $S$ must also contain $\\text{span}(S)$.\n\n### Proof\nThis result is immediate if $S = \\emptyset$ because $\\text{span}(\\emptyset) = \\{\\mathbf{0}\\}$, which is a subspace that contains $S$ and is contained in any subspace of $V$.\n\nIf $S \\neq \\emptyset$, then $S$ contains some vector $\\mathbf{z}$; $0\\mathbf{z} = \\mathbf{0}$ is in $\\text{span}(S)$.\n\nLet $\\mathbf{x}, \\mathbf{y} \\in \\text{span}(S)$.\nThen there exists vectors $\\def\\v#1{\\mathbf{#1}} \\v{u}\\_1, \\cdots, \\v{u}\\_m, \\v{v}\\_1, \\cdots, \\v{v}\\_n$ in $S$ and scalars $a\\_1, \\cdots, a\\_m, b\\_1, \\cdots, b\\_n$\n\nsuch that\n\n$$\n\\def\\v#1{\\mathbf{#1}}\n\\begin{align*}\n\\v{x} = \\sum\\limits^m\\_{i=1} {a\\_i\\v{u}\\_i} \\quad\\text{and}\\quad \\v{y} = \\sum\\limits^n\\_{i=1}{b\\_i\\v{v}\\_i}.\n\\end{align*}\n$$\n\nThen, for any scalar $c$,\n\n$$\n\\def\\v#1{\\mathbf{#1}}\nc\\v{x}+\\v{y} = \\sum\\limits^m\\_{i=1} {(ca\\_i)\\v{u}\\_i} + \\sum\\limits^n\\_{i=1}{b\\_i\\v{v}\\_i}\n$$\n\nis clearly a linear combination of the vectors in $S$. Hence $c\\mathbf{x}+\\mathbf{y} \\in \\text{span}(S)$.\nThus $\\text{span}(S)$ is a subspace of $V$.\nFurthermore, if $\\mathbf{v} \\in S$, then $\\mathbf{v} = 1\\mathbf{v} \\in \\text{span}(S)$, so $S \\subseteq \\text{span}(S)$.\n\nNow let $W$ denote any subspace of $V$ that contains $S$.\nIf $\\mathbf{w} \\in \\text{span}(S)$, then $\\mathbf{w}$ is a linear combination of \nsome vectors $\\mathbf{w}_1, \\cdots, \\mathbf{w}_k$ of $S$.\nSince $S \\subseteq W$, $\\mathbf{w}_i \\in W$ for all $i = 1, \\cdots, k$. \nTherefore $\\mathbf{w}$ is a linear combination of vectors of $W$, hence $\\mathbf{w} \\in W$. Thus $\\text{span}(S) \\subseteq W$.\n$$\\tag*{$||$}$$\n\n\n[^1]: Linear Algebra, Fifth Edition, by Stephen Friedberg, Arnold Insel, and Lawrence Spence","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Statistics":{"title":"Statistics","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Structure-of-relational-databases":{"title":"Structure of relational databases","content":"\nA relational database consists of a collection of **tables**, each of which is assigned a unique name.\nIn general, a row in a table represents a *relationship* among a set of values.\n\n- In the relational model, the term **relation** is used to refer to a table, whilst the term **tuple** is used to refer to a row.\n- Similarly, the term **attribute** refers to a column of a table.\n    - Denoted as $A_1, \\cdots, A_n$.\n        \n        ![Screenshot 2022-10-10 at 6.53.06 PM.png](Structure%20of%20Relational%20Databases%209c04c2584af142379f668c5078a9d46d/Screenshot_2022-10-10_at_6.53.06_PM.png)\n        \n- A **relation schema** consists of a list of attributes and their corresponding domains.\n    - Denoted as $R = (A_1, \\cdots, A_n)$.\n- The term **relation instance** refers to a specific instance of a relation, i.e., containing a specific set of rows.\n    - Denoted as $r(R)$.\n- The **domain** of the attribute refers to the set of allowed values for each attribute.\n    - Attribute values are normally required to be **atomic**, i.e., elements of the domain are considered to be indivisible unit**s**.\n    - The special value **null** is a member of every domain, indicating that the value is *unknown*.\n- Relations are unordered, like sets in mathematics.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Subspace":{"title":"Subspace","content":"\n## Definition\n\u003e Let $V$ be a [vector space](notes/Vector%20space.md) over the [field](notes/Field.md) $F$. A **subspace** of $V$ is a subset $W \\subset V$ which itself is a vector space over $F$ with the same operations defined on $V$.\n\n## Observations\n### Observation 1\n\u003eIn any vector space $V$, $V$ and $\\{0\\}$ are subspaces of $V$.\n\u003eThe latter is called the **zero subspace** of $V$.\n\n## Theorems\n### Theorem 1 *[^1]\n\u003e A non-empty subset $W$ of $V$ is a subspace of $V$ _if and only if_ $\\forall \\mathbf{x}, \\mathbf{y} \\in W, \\forall c \\in F:$ $c\\mathbf{x} + \\mathbf{y} \\in W$.\n\n### Proof\n$(\\Rightarrow)$ Trivial.\n\n$(\\Leftarrow)$ Since $W \\neq \\emptyset$, $\\forall \\mathbf{v} \\in W:$ $(-1)\\mathbf{v} + \\mathbf{v} = \\mathbf{0} \\in W$.\n\n$\\forall \\mathbf{w} \\in W, \\forall c \\in F:$ $c\\mathbf{w} = c\\mathbf{w} + \\mathbf{0} \\in W$. In particular, $(-1)\\mathbf{w} = -\\mathbf{w} \\in W$.\n\nFinally, $\\forall \\mathbf{v}, \\mathbf{w} \\in W:$ $\\mathbf{v} + \\mathbf{w} = 1\\mathbf{v} + \\mathbf{w} \\in W$.\n\nTherefore, $W$ is a subspace of $V$.\n$$\\tag*{$||$}$$\n### Theorem 2 *[^1]\n\u003e The intersection of any collection of subspaces of a vector space $V$ is a subspace of $V$.\n\n### Proof\nLet $\\lbrace W\\_a \\rbrace$ be the collection of subspaces of $V$, and let $W = \\cap\\_{a}W\\_a$. Since $\\mathbf{0} \\in W\\_a$ for all $W\\_a$, $\\mathbf{0} \\in W$ and thus $W$ is nonempty.\n\nLet $\\mathbf{x}, \\mathbf{y} \\in W$ and $c$ be an arbitrary scalar. By definition of $W$, $\\mathbf{x},\\mathbf{y} \\in W\\_a$ for all $W\\_a$ and since they are all subspaces of $V$, $c\\mathbf{x} + \\mathbf{y} \\in W\\_a$ for all $W\\_a$. Thus $c\\mathbf{x} + \\mathbf{y} \\in W$. \n$$\\tag*{$||$}$$ \n\n[^1]: Linear Algebra, Second Edition, by Kenneth Hoffman and Ray Kunze","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Syntax":{"title":"Syntax","content":"\n**Syntax** of a programming language decides the apprearance of the language.\nIt allows us to know which strings are programs and what the structures of the programs are.\nIt consists of []","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/System-upcalls":{"title":"System upcalls","content":"\n## Necessity of System Upcalls\nTo allow applications to implement operating system-like functionality, more than [system call](notes/Mode%20transfer.md#System%20Calls) is required; applications can also benefit from being told when events occur that _need their immediate attention_. Such _virtualised_ interrupts and exceptions are called **upcalls**, also known as **signals** (in UNIX).\n\n## Uses of System Upcalls\n### Preemptive user-level threads\nAn application may run multiple tasks, or threads, in a process.\n\n### Asynchronous I/O notification (`async` / `await`)\nIn an asynchronous I/O, a system calls starts the request and returns immediately. Later, the application can poll the kernel for I/O completion, or a separate notification can be sent via an upcall to the application when the I/O completes.\n\n### Interprocess communication\nA kernel upcall is needed if a process generates an event that needs the instant attention of another process.\n\n### User-level exception handling\nApplications may have their own exception handling routines. For this, the operating system needs to inform the application when it receives a processor exception.\n\n### User-level resource allocation\nMany applications are able to optimise their behaviour to differing amounts of CPU time or memory.\n- e.g., Java garbage collection\n\n## Diagrams\n- The state of the user program and signal handler before a UNIX signal\n![upcall-before](/notes/images/upcall-before.png)\n\n- The state of the user program and signal handler during a UNIX signal\n![upcall-during](/notes/images/upcall-during.png)\n\n## Comparison with [interrupts](notes/Mode%20transfer.md#Interrupts)\n### Types of Signals\n- In place of hardware-defined interrupts and processor exceptions, the kernel defines a limited number of sifnal types that a process can receive.\n\n### Handlers\n- The kernel defines its own [interrupt vector](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Vector).\n- Each process defines its own signal handlers for each signal type.\n\n### Signal Stack\n- The kernel uses [interrupt stack](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Stack), a region of _kernel_ memory when handling interrupts.\n- Applications have the option to run UNIX signal handlers on the process's _normal execution stack_, or on a special **signal stack** allocated buy the user process in user memory.\n\n### Signal Masking\n- The kernel can defer the arrival of interrupts via [interrupt masking](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Masking).\n- UNIX defers signals for events that occur while the signal handler for those types of events is in progress.\n- The deferred signal is delivered once the handler returns to the kernel.\n\n### Processor State\n- The _kernel_ copies onto the signal stack the saved state of the program counter, stack pointer, and general-purpose registers at the point when the program stopped.\n- When the signal handler returns, the kernel reloads the saved state into the processor to resume program execution.\n- The signal handler can also _modify_ the saved state, so that the kernel resumes a different user-level task on return.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Thread":{"title":"Thread","content":"\nA **thread** is a _single execution sequence_ that represents _a separately schedulable task_. Doing so, threads provide the illusion of an infinite number of _processors_.\n\n- **Single execution sequence**: Each thread executes a sequence of instructions, just as in the familiar sequential programming model.\n- **Separately schedulable task**: The operating system can run, suspend (block), or resume a thread at any time.\n\nThreads can run either in a [process](notes/Process.md) or in the kernel; there is also _shared state_ that is not saved or restored when switching the processor between threads.\n\n## Advantages\nUsing threads to express and manage concurrency has several advantages.\n\n-  **Expressing logically concurrent tasks**: Threads eneable the expression of an application's natural concurrency by writing each concurrent task as a separate thread.\n- **Shifting work to run in the background**: To improve user responsiveness and performance, a common design pattern is to create threads to perform work that in the background, without the user waiting for the result.\n- **Exploiting multiple processors**: Programs can use threads on a multiprocessor to do work in parallel; they can do the same work in less time or more work in the same elapsed time.\n- **Managing I/O devices**: By running tasks as separate threads, when one task is waiting for I/O, the processor can make progress on a different task.\n\n## Comparison with [Processes](notes/Process.md)\n- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)\n\n## Thread Data Structures\n- [Thread data structures](notes/Thread%20data%20structures.md)\n\n## Thread Life Cycle\n- [Thread life cycle](notes/Thread%20life%20cycle.md)\n","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Thread-data-structures":{"title":"Thread data structures","content":"\n![thread-data-structure](/notes/images/thread-data-structure.png)\n\n## Per-Thread State and Thread Control Block (TCB)\nThe operating system needs a data structure to represent a threads's state. This data structure is called the **thread control block (TCB)**. For every thread the operating system creates, it creates one TCB.\n\nThe thread control block holds two types of per-thread information:\n- **Per-thread Computation State**\n- **Per-thread Metadata**\n\n### Per-thread Computation State\nTo create multiple threads and to be able to start/stop each thread as needed, the operating system must allocate space in the TCB for the _current state of each thread's computation_. This, in turn, is the **pointer to the thread's stack** and a **copy of its processor registers**.\n\n- **Stack**\n\t- A thread's stack is the same as the stack for a single-threaded computation. It stores information needed by the nested procedures the thread is currently running.\n\t- Each thread needs its own stack, because at any given time different threads can be in different states in their sequential computations.\n\t- When a new thread is created, the operating system allocates it a new stack and stores a pointer to that stack in the thread's TCB.\n\n- **Copy of processor registers**\n\t- A processor's registers include not only its general-purpose registers (for storing intermediate values for ongoing computations), but they also include special-purpose registers, such as the _instruction pointer_ and the _stack pointer_.\n\t- To be able to suspend/run/resume threads, the operating system needs a place to store a thread's registers when that thread is not actively running.\n\n### Per-thread Metadata\nThe TCB also includes **per-thread metadata**, information for managing the thread. This includes _thread ID (tid)_, _scheduling priority_, and _status_.\n\n## Shared State\nSome state is **shared** between threads running _in the same process_ or _within the operating system kernel_. The followings are examples of shared states between threads.\n\n- Program **code** is shared by all threads in a process (although each thread may be executing at a different place within that code).\n- Statically allocated **global variables** and dynamically allocated **heap variables** can store information accessible to all threads.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Thread-life-cycle":{"title":"Thread life cycle","content":"\n![thread-life-cycle](/notes/images/thread-life-cycle.png)\n\n## Init\n- Thread creation `thread_create()` puts a thread into its `init` state and allocates and initialises per-thread data structures.\n- Once that is done, thread creation code puts the thread in `ready` state by adding the thread to the _ready list_ (set of runnable threads that are waiting their turn to use a processor).\n\n## Ready\n- A thread in `ready` state is available to be run but is not currently running.\n- Its TCB is on the ready list, and the values of its registers are stored in its TCB.\n- At any time, the **scheduler** can cause a thread to transition from `ready` to `running` state, by copying its register values from its TCB to a processor's registers.\n\n## Running\n- A thread in `running` state is running on a processor. At this time, its register values are stored on the processor rather than in the TCB.\n- A `running` thread can transition to the `ready` state in two ways:\n\t- The **scheduler** can _preempt_ a `running` thread and move it to the `ready` state by saving the thread's registers to its TCB and switching the processor to run the next thread on the ready list.\n\t- A `running` thread can voluntarily relinquish the processor and go from `running` to `ready` by calling `thread_yield()`.\n\n## Waiting\n- A thread in the `waiting` state is waiting for some event.\n- While the scheduler can move a thread in the `ready` state to the `running` state, a thread in the `waiting` state cannot run until some action by another thread moves it from `waiting` to `ready`.\n- The TCB of a `waiting` thread is stored on the _waiting list_ of some synchronisation variable associated with the event. When the required event occurs, the operating system moves the TCB from the synchronisation variable's waiting list to the scheduler's ready list, transitioning the thread from `waiting` to `ready`.\n\n## Finished\n- A thread in `finished` state never runs again.\n- The system can free some or all of its state for other use. Some systems may store `finished` threads in a _finished list_.\n\n\nOne way to understand the states is to consider where a thread's TCB and registers are stored.\n\n| State of Thread | Location of TCB                            | Location of Registers |\n| --------------- | ------------------------------------------ | --------------------- |\n| `init`          | Being Created                              | TCB                   |\n| `ready`         | Ready List                                 | TCB                   |\n| `running`       | Running List                               | Processor             |\n| `waiting`       | Waiting List of a Synchronisation Variable | TCB                   |\n| `finished`      | Finished List / Deleted                    | TCB / Deleted         |\n\n","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Thread-models":{"title":"Thread models","content":"\nSupport for threads may be provided either at the user level, for **user threads**, or by the kernel, for **kernel threads**. **User threads** are supported above the kernel and are managed without kernel support, whereas **kernel threads** are supported and managed directly by the operating system. Accordingly, a _relationship_ must exist between user threads and kernel threads.\n\n## One-to-one Model\n![one-to-one-model](/notes/images/one-to-one-model.png)\nThe **one-to-one model** maps each user thread to a kernel thread.\n|             |                                                                                                                                      |\n| ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| Advantages  | Provides _more concurrency_ than the many-to-one model by allowing another thread to run when a thread makes a blocking system call. |\n| Limitations | Every thread operation must go through the kernel; slower performance.                                                               |\n|             | One-size fits all thread implementation; maybe pay for fancy features that a thread doesn't need.                                    |\n|             | General heavy-weight memory requirements (e.g., requires a _fixed-size stack_ within kernel).                                        |\n \n## Many-to-one Model\n![many-to-one-model](/notes/images/many-to-one-model.png)\n\nThe **many-to-one model** maps many user-level threads to one kernel thread.\n|             |                                                                                               |\n| ----------- | --------------------------------------------------------------------------------------------- |\n| Advantages  | Thread scheduling is done in user space, so it is efficient.                                  |\n| Limitations | Can't take advantage of multicore systems.                                                    |\n|             | User-level threads are invisible to the OS and thus not well-integrated with the OS.          |\n|             | As a result, the OS can make poor decisions (e.g., a blocking system call blocks all threads) |\n\n## Many-to-many Model\n![many-to-many-model](/notes/images/many-to-many-model.png)\n\nThe **many-to-many model** multiplexes many user-level threads to a smaller or equal number of kernel threads. This is sometimes also called **n:m thread model**, where n is the number of user threads, and m is the number of kernel threads.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Too-much-milk-problem":{"title":"Too much milk problem","content":"\n## Definition\nThe **Too Much Milk** problem models two roommates who share a refrigerator and, who make sure the refrigerator is _always_ well stocked with milk.\n\n## Example Situation\n| Time | Roommate 1                   | Roommate 2                   |\n| ---- | ---------------------------- | ---------------------------- |\n| 3:00 | Look in fridge; out of milk. |                              |\n| 3:05 | Leave for store.             |                              |\n| 3:10 | Arrive at store.             | Look in fridge; out of milk. |\n| 3:15 | Buy milk.                    | Leave for store.             |\n| 3:20 | Arrive home; put milk away.  | Arrive at store.             |\n| 3:25 |                              | Buy milk.                    |\n| 3:30 |                              | Arrive home; put milk away.  |\n|      |                              | **Oh no, too much milk!**    |\n\nOne can model each roommate as a **thread** and the number of bottles of milk in the fridge with **a variable in memory**. Two properties needs to be met for a solution: **safety** and **liveliness**.\n\n### Safety\nA program never enters a bad state.\n- In the too much milk problem, never more than one person buys a milk.\n\n### Liveliness\nA program must, eventually, enter a good state.\n- In the too much milk problem, if milk is needed, someone eventually buys it.\n\n## Solutions\n### Solution 1: Leave a note\nThe basic idea is to leave a note on the fridge before going to the store. The simplest idea to implement this is to set a flag when going to buy milk and to check this flag before going to buy milk.\n\n```C\nif(milk == 0)   // If no milk\n{\n  if(!note)     // If no note\n  {\n    leave note;\n    buy milk;\n    remove note;\n  }\n}\n```\n\nHowever, this implementation can violate safety; it makes the problem worse since it fails intermittenly!\n\n| Thread A         | Thread B         |\n| ---------------- | ---------------- |\n| `if (milk == 0)` |                  |\n| `if (note == 0)` |                  |\n| _Interleaves_    | `if (milk == 0)` |\n|                  | `if (note == 0)` |\n| `note = 1;`      | _Interleaves_    |\n| `milk++;`        |                  |\n| `note = 0;`      |                  |\n| _Interleaves_    | `note = 1;`      |\n|                  | `milk++;`        |\n|                  | `note = 0;`      |\n\n### Solution 2: Using two notes\n- Thread A\n```C\nleave note A;\nif(!note B)\n{\n  if(milk == 0)\n\tbuy milk;\n}\nremove note A;\n```\n- Thread B\n```C\nleave note B;\nif(!note A)\n{\n  if(milk == 0)\n\tbuy milk;\n}\nremove note B;\n```\n\nThis solution is **safe**. However, this solution does not ensure **liveliness**. Although it is unlikely to happen, but it is possible at worst case.\n\n| Thread A              | Thread B              |\n| --------------------- | --------------------- |\n| `leave note A`        |                       |\n| _Interleaves_         | `leave note B`        |\n|                       | `if (!note A)`        |\n|                       | (PASS) `if (milk == 0)` |\n|                       | (PASS) `buy milk`       |\n| `if (!note B)`        | _Interleaves_         |\n| (PASS) `if (milk == 0)` |                       |\n| (PASS) `buy milk`       |                       |\n\n\n### Solution 3: Busy waiting\n- Thread A\n```C\nleave note A;\nwhile(note B)\n  ;\nif(milk == 0)\n  buy milk;\nremove note A;\n```\n\n- Thread B\n```C\nleave note B;\nif(!note A)\n{\n  if(milk == 0)\n    buy milk;\n}\nremove note B;\n```\n\nThis solution is both **safe** and **live**. Since thread B does not have a loop, it will eventually finish its execution.\n\nHowever, this solution is not very satisfying:\n\n- It is complex and requires caregul reasoning to be convinced that it works.\n- It is _inefficient_ because thread A is _busy waiting_, consuming CPU resources.\n- It may fail if the compiler or hardware reorders instructions.\n\n### Solution 4: [Locks](Lock.md)\n```C\nlock.acquire();\nif(milk == 0)\n  buy milk;\nlock.release();\n```\n","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Topology":{"title":"Topology","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Vector-analysis":{"title":"Vector analysis","content":"","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Vector-space":{"title":"Vector space","content":"\n## Definition\n\nA vector space $V$ over a [field](notes/Field.md) $F$ consists of a set on which two operations $+$ (_addition_) and $\\cdot$ (_scalar multiplication_) are defined so that the followings hold.\n\nFor any $\\mathbf{x}, \\mathbf{y}, \\mathbf{z} \\in V$ and $c, d \\in F$:\n\u003e **(A1)** $\\mathbf{x}, \\mathbf{y} \\in V \\Rightarrow \\mathbf{x} + \\mathbf{y} \\in V$\n\u003e\n\u003e **(A2)** $\\mathbf{x} + \\mathbf{y} = \\mathbf{y} + \\mathbf{x} \\quad$ (Commutativity of addition)\n\u003e\n\u003e **(A3)** $(\\mathbf{x} + \\mathbf{y}) + \\mathbf{z} = \\mathbf{x} + (\\mathbf{y} + \\mathbf{z}) \\quad$ (Associativity of addition)\n\u003e\n\u003e **(A4)** $\\exists ! \\mathbf{0} \\in V$ such that $\\forall \\mathbf{x} \\in V: \\mathbf{x} + \\mathbf{0} = \\mathbf{x} \\quad$ (Existence of additive identity)\n\u003e\n\u003e **(A5)** $\\forall \\mathbf{x} \\in V: \\exists ! (-\\mathbf{x}) \\in V$ such that $\\mathbf{x} + (-\\mathbf{x}) = \\mathbf{0} \\quad$ (Existence of additive inverse)\n\u003e\n\u003e **(M1)** $\\mathbf{x} \\in V \\Rightarrow c\\mathbf{x} \\in V$\n\u003e\n\u003e **(M2)** $c(d\\mathbf{x}) = (cd)\\mathbf{x}$\n\u003e\n\u003e **(M3)** $c(\\mathbf{x} + \\mathbf{y}) = c\\mathbf{x} + c\\mathbf{y}$\n\u003e\n\u003e **(M4)** $(c + d)\\mathbf{x} = c\\mathbf{x} + d\\mathbf{x}$\n\u003e\n\u003e **(M5)** $\\forall \\mathbf{x} \\in V: 1\\mathbf{x} = \\mathbf{x}$\n\n## Examples\n### The space of $m \\times n$ matrices\nLet $F$ be any field and $m, n \\in \\mathbb{N}$. Define $F^{m\\times n}$ as the set of all $m\\times n$ matrices over the field $F$. Then, for any matrices $A, B \\in F^{m \\times n}$ and scalar $c \\in F$,\n- $(A + B)\\_{ij} = A\\_{ij} + B\\_{ij}$\n- $(cA)\\_{ij} = cA\\_{ij}$\n\n### The space of functions from a set to a field\nLet $F$ be any field, and $S$ be any nonempty set. Define $V$ as the set of all functions $S \\to F$. Then, for any functions $f, g \\in V$ and scalar $c \\in F$, $\\forall s \\in S$:\n- $(f + g)(s) = f(s) + g(s)$\n- $(cf)(s) = cf(s)$\n- The zero vector is the function $\\mathbf{0}: S \\to \\{0\\}$.\n- The inverse vector $(-f)$ of an arbitrary function $f \\in V$ is given as $(-f)(s) = -f(s)$.\n\n### The space of polynomial functions over a field\nLet $F$ be any field. Define $V$ as tje set of all polynomials $F \\to F$, that is, all functions $f: F \\to F$ in the form of\n$$f(x) = \\sum\\limits_{i=0}^n c_ix^i$$\nwhere $c_i \\in F$ $(i= 0, \\cdots, n)$ are independent of $x$.\n\n\n## Related Concepts\n- [Norm](notes/Norm.md): Defines a distance-like property in vector spaces\n- [Inner product](notes/Inner%20product.md): Allows the concept of 'direction' to be considered in vector spaces\n ","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/View-of-data":{"title":"View of data","content":"\nA major purpose of a [database system](notes/Database%20systems.md) is to provide users with an abstract view of the data. That is, the system hides certain details of how the data are stored and maintained.\n\n## Data models\nA **data model** is a collection of conceptual tools for describing _data_, _data relationships_, _data semantics_, and _consistency constraints_.\n\n- **Relational model**: All the data is stored in various tables. Each table has multiple columns, and each column has a unique name. Tables are also known as _relations_.\n- **Entity-Relationship model**: Uses a collection of basic objects, called _entities_, and relationships among these objects.\n- **Semi-structured data model**\n- **Object-based data model**: Allow procedures to be stored in the database system and executed by the database system.\n\n\n## Data abstraction\nThe complexity of the data structures to represent data in the database is hidden from users through several levels of **data abstraction**.\n\n- **Physical level**: Describes _how_ the data are actually stored. It describes complex low-level data structures in detail.\n- **Logical level**: Describes _what_ data are stored in the database, and what relationships exist among those data.\n- **View level**: Describes only _part_ of the entire database. The view level of abstraction exists to simplify users' interaction with the system. The system may provide many views for the same database.\n\n![data-abstraction-levels](/notes/images/data-abstraction-levels.png)\n\n- **Physical data independence**: The ability to modify the physical schema without changing the logical schema. In general, the interfaces between the various levels and components should be well defined, so that changes in some parts do not seriously influence others.\n\n## Instances and schemas\n- The collection of information stored in the database at a _particular moment_ is called an **instance** of the database.\n- The _overall design_ of the database is called the database **schema**. Database systems have several schemas, partitioned according to the levels of abstraction.\n\t- **Physical schema**: Describes the overall _physical_ structure of the database.\n\t- **Logical schema**: Describes the overall _logical_ structure of the database.\n\t- **Subschema**: Describes different _views_ of the database.","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/Weierstrass-approximation-theorem":{"title":"Weierstrass approximation theorem","content":"\n## Theorem\n\u003e Let $f: \\mathbb{R} \\to \\mathbb{R}$ be a continuous function on the interval $[a,b]$.\n\u003e Then, for any positive $\\varepsilon$, there exists $n \\in \\mathbb{N}$ where for some \n\u003e $n$-degree polynomial $p_n$,\n\u003e $\\lVert f - p_n \\rVert_{C^0} \\leq \\varepsilon$ holds.\n\n## Proof\nWithout loss of generality, let $a=0$ and $b=1$. Since $f$ is continuous on $[0,1]$, let $M$ as:\n$$\nM = \\sup\\limits_{x \\in [0,1]}|f(x)| := \\lVert f \\rVert_0.\n$$\n\nConsequently, for any $\\xi \\in [0,1]$, the following holds:\n$$\n|f(x)-f(\\xi)| \\leq\n\\begin{cases}\n\\dfrac{\\varepsilon}{2} \\qquad \u0026 \u0026\\text{if„ÄÄ} |x - \\xi| \u003c \\delta \\\\\n|f(x)| + |f(\\xi)| \u0026\\leq 2M\\\\\n\u0026\\leq 2M\\cdot 1\\\\\n\u0026\\leq 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2\\qquad \u0026\\text{otherwise.}\n\\end{cases}\n$$\nTherefore we can conclude that \n$$\n|f(x) - f(\\xi)| \\leq 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2 + \\dfrac{\\varepsilon}{2}.\n$$\n\nNow, we will prove that the polynomial of interest is actually the **[Bernstein polynomial](notes/Bernstein%20polynomial.md)**.\n\n$$\n\\begin{aligned}\n|B_n(x;f)-f(\\xi)| \u0026= |B_n(x;f) - B_n\\left(x;f(\\xi)\\right)| = |B_n\\left(x;f-f(\\xi)\\right)|\\\\\n\u0026= \\left|\\sum\\limits_{\\nu = 0}^n \\left(f\\left(\\dfrac{\\nu}{n}\\right)-f(\\xi)\\right)\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}\\right|\\\\\n\u0026\\leq \\sum\\limits_{\\nu = 0}^n \\left|\\,f\\left(\\dfrac{\\nu}{n}\\right)-f(\\xi)\\,\\right|\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}\\\\\n\u0026= B_n\\left(x;|f-f(\\xi)|\\right)\\\\\n\u0026\\leq B_n\\left(x; 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2 + \\dfrac{\\varepsilon}{2}\\right)\\\\\n\u0026= \\dfrac{2M}{\\delta^2}\\left( x^2+\\dfrac{1}{n}(x - x^2) \\right) - \\dfrac{4M\\xi}{\\delta^2} + \\dfrac{2M\\xi^2}{\\delta^2} + \\dfrac{\\varepsilon}{2}\n\\end{aligned}\n$$\nThe last line is due to the [properties](notes/Bernstein%20polynomial.md###Properties) of Bernstein polynomials.\n\nNext, let $\\xi = x$. Then consequently,\n$$\n\\begin{aligned}\n|B_n(x;f) - f(x)|\n\u0026\\leq \\dfrac{2M}{\\delta^2}\\cdot\\dfrac{\\xi-\\xi^2}{n} + \\dfrac{\\varepsilon}{2}\\\\\n\u0026\\leq \\dfrac{M}{2\\delta^2}\\cdot\\dfrac{1}{n} + \\dfrac{\\varepsilon}{2}\n\\end{aligned}\n$$\nThe last line is due to the fact that the maximum value of the function $x - x^2$ on the interval $[0,1]$ is $\\dfrac{1}{4}$.\n\nFinally, choose $n$ such that it satisfies $n \\geq \\dfrac{M}{\\delta^2 \\varepsilon}$. Then for any $x \\in [0,1]$,\n$$\n|B_n(x;f)-f(x)| \\leq \\varepsilon\n$$\nand equivalently,\n$$\n\\lVert B_n(\\cdot;f) - f\\rVert_{C^0} \\leq \\varepsilon.\n$$\nThis completes the proof.\n$$\\tag*{$||$}$$","lastmodified":"2022-10-16T02:38:57.109338244Z","tags":null},"/notes/x86-Mode-Transfer":{"title":"x86 Mode Transfer","content":"\n## Background on x86 Architecture\nx86 is segmented, so pointers come in two parts.\n\n- **Segment**: A region of memory such as code, data, or stack\n- **Offset**: An offset within that segment\n\nThe current user-level instruction is a combination of the code segment (`cs`) and the instruction pointer (`eip` / `rip`) within the code segment. The current stack position is a combination of the stack segment (`ss`) and the stack pointer (`esp` / `rsp`) within the stack segment.\n\nThe current privilege level is stored as the low-order buts of the `cs` register. The `eflags` register has condition codes that are modified as a by-product of executing instructions, as well as other flags that control the processor's behaviour (such as whether interrupts are masked).\n\n## Mode Transfer in x86\nWhen a processor exception or a system call trap occurs, the following procedure takes place.\n\n1. **Mask interrupts**.\n\t- The hardware prevents any interrupts from occurring while the processor is in the middle of context switch.\n2. **Save three key values**. \n\t- The hardware saves the values of the stack pointer (`esp`/`rsp` and `ss`), the execution flags (`eflags`), and the instruction pointers (`eip`/`rip` and `cs`) to internal, temporary hardware registers.\n3. **Switch onto the kernel interrupt stack**.\n\t- The hardware switches the stack segment / stack pointer to the base of the kernel interrupt stack as specified in a special hardware register.\n4. **Push the three key values onto the new stack**.\n\t- The hardware stores the internally saved values onto the stack.\n5. **Optionally save an error code.**\n\t- The hardware pushes an error code (generated by certain types of exceptions, e.g., page fault) and make it the top item on the stack. For other types of events, the software interrupt handler pushes a dummy value onto the stack.\n6. **Invoke the interrupt handler**.\n\t- The hardware changes the code segment / program counter to the address of the interrupt handler procedure.\n\t- The handler pushes the rest of the registers, including the current stack pointer (but not the instruction pointer or `eflags` register), onto the stack.\n\n- State of the system before an interrupt handler is invoked\n![x86-mode-switch-1](/notes/images/x86-mode-switch-1.png)\n\n- State of the system after the jump to the interrupt handler\n![x86-mode-switch-2](/notes/images/x86-mode-switch-2.png)\n\n- State of the system after the interrupt handler has started executing\n![x86-mode-switch-3](/notes/images/x86-mode-switch-3.png)\n\nWhen the handler completes, it can resume the interrupted process. The handler executes the x86 `iret` instruction. It [atomically](notes/Atomic%20operation.md) restores the program counter, program stack pointer, the processor status word/condition codes, and switches the process back to user mode.","lastmodified":"2022-10-16T02:38:57.133338337Z","tags":null}}