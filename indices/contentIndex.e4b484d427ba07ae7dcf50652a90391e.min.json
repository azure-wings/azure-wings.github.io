{"/":{"title":"azurewings","content":"\nüëã Hello, I am **azurewings / Giyeon Lee**, and I study computer science \u0026 mathematics at KAIST.\n\nü¶ä I enjoy studying and tinkering random subjects by myself.\n\n**Portfolio** [[About me]]\n\n**Email** [azurewings.seoul](mailto://azurewings.seoul@gmail.com)   **GitHub** [azure-wings](https://github.com/azure-wings)    **Instagram** [@__azurewings](https://www.instagram.com/__azurewings/)\n\n---\n## My writings\n\n- **[[index/Blog | üå± Blog]]**\n- **[[index/Notes | ‚úèÔ∏è Notes]]**\n- **[[index/Links | üîó Links]]**\n\n\n\u003c!-- \u003ca href=\"https://github.com/azure-wings\" target=\"_blank\"\u003e\u003cimg src=\"https://img.shields.io/badge/Github-282828?style=for-the-badge\u0026logo=GitHub\u0026logoColor=white\"/\u003e\u003c/a\u003e\n\u003ca href=\"https://www.linkedin.com/in/leegiyeon\" target=\"_blank\"\u003e\u003cimg src=\"https://img.shields.io/badge/LinkedIn-0A66C2?style=for-the-badge\u0026logo=LinkedIn\u0026logoColor=white\"/\u003e\u003c/a\u003e\n\u003ca href=\"mailto:azurewings.seoul@gmail.com\" target=\"_blank\"\u003e\u003cimg src=\"https://img.shields.io/badge/Email-EA4335?style=for-the-badge\u0026logo=Gmail\u0026logoColor=white\"/\u003e\u003c/a\u003e --\u003e","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/About-me":{"title":"About me","content":"\n# Ïù¥Í∏∞Ïó∞ / Lee, Giyeon\n\n## Education\n\n### [Korea Advanced Institute of Science and Technology](https://kaist.ac.kr/)\n\n`Mar. 2020 ~ Current`\n\n- Major in [Computer Science](https://cs.kaist.ac.kr/)\n- Double major in [Mathtmatics](https://mathsci.kaist.ac.kr/)\n- [My coursework](https://www.notion.so/Coursework-bf592c57cd5c49aaac3e0a351a0df6a1)\n\n### [Korea Science Academy of KAIST](https://ksa.hs.kr/)\n\n`Mar. 2017 ~ Feb. 2020`\n\n- Graduate Student\n\n## Academic Interests\n\n- Financial Time Series Analysis and Forecasting\n- Natural Language Processing\n- Artificial Intelligence for Legal Affairs\n- Explainable Artificial Intelligence\n\n## Experiences\n\n### Laboratory Intern\n\n- `Winter 2021` [Machine Learning and Intelligence Laboratory @KAIST](https://mli.kaist.ac.kr/)\n\n## Skills\n\n- **Programming Languages**: Python, C/C++, $\\LaTeX$\n- **Frameworks / Libraries**: Git, PyTorch, TensorFlow\n- **Languages**: Korean, English\n\n~~You can download my CV file at this link.~~\nCurrently unavilable","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Blog":{"title":"Blog","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Books":{"title":"Books","content":"\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Business-administration":{"title":"Business administration","content":"\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Computer-science":{"title":"Computer science","content":"\n**Computer science** is the study of computation, automation, and information.\n\n## Basic mathematics\n- [Mathematical logic](notes/Mathematical%20logic.md)\n- [Set theory](notes/Set%20theory.md)\n\n## Data structures and algorithms\n- Data structures\n- Algorithms\n\t- Algorithm analysis\n- Combinatorial optimization\n\n## Theoretical computer science\n- Formal languages\n- Automata theory\n- Theory of computation\n\n## Programming language theory and formal methods\n- [Programming language theory](notes/Programming%20language%20theory.md)\n- Type theory\n- Compilers\n\n## Databases and data mining\n- [Database systems](notes/Database%20systems.md)\n\n## Computer systems\n- Digital systems\n- [Computer architecture](notes/Computer%20architecture.md)\n- [Operating systems](notes/Operating%20systems.md)\n- Computer network\n\n## Computer graphics and visualisation\n- [Computer graphics](notes/Computer%20graphics.md)\n\n## [Artificial intelligence](notes/Artificial%20intelligence.md)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Economics":{"title":"Economics","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Links":{"title":"Links","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Mathematics":{"title":"Mathematics","content":"\n**Mathematics** is a study of abstract concepts such as numbers, quantities, spaces, changes, structures, etc., based on strict logic.\n\n## Algebra\n- [Linear algebra](notes/Linear%20algebra.md)\n- [Abstract algebra](notes/Abstract%20algebra.md)\n\n## Analysis\n- Real analysis\n- [Vector analysis](notes/Vector%20analysis.md)\n- Functional analysis\n- Fourier analysis\n\n## Topology / Geometry\n- [Topology](notes/Topology.md)\n- Differential geometry\n\n## Probability / Statistics\n- Probability theory\n- [Statistics](notes/Statistics.md)\n\n## Discrete\n- Mathematical logic\n- Set theory\n- Category theory\n- Graph theory\n\n## Computational mathematics\n- [Approximation theory](notes/Approximation%20theory.md)\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Movies":{"title":"Movies","content":"\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/index/Notes":{"title":"Notes","content":"\n## Notes\n\n### üìö Academic\n- [[Mathematics]]\n- [[Computer science]]\n- [[Business administration]]\n- [[Economics]]\n\n### üìÅ Archives\n- [[Books]]\n- [[Movies]]","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Abstract-algebra":{"title":"Abstract algebra","content":"\n**Abstract algebra** is the study of algebraic structures such as groups, rings, [fields](notes/Field.md), modules, [vector spaces](notes/Vector%20space.md), lattices, and algebras.\n\n## Group theory\n- [Group](notes/Group.md)\n\n## Ring theory\n\n## Modules and vector spaces\n\n## Field theory\n\n## Galois theory\n\n## Finite groups","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Abstract-syntax":{"title":"Abstract syntax","content":"\n**Abstract syntax** formally express multiple components and subcomponents the program consists of.\n\n## Abstract Syntax Tree (AST)\nAbstract syntax are often described in the form of trees.\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Accessing-SQL-from-a-programming-language":{"title":"Accessing SQL from a programming language","content":"\nA database programmer must have access to a general purpose programming language for at least two reasons:\n- Not all queries can be expressed in SQL.\n  \n  SQL does not provide the full expressive power of a general-purpose language\n\n- Non-declarative actions cannot be done from within SQL.\n  \n  Non-delcatarive actions include printing a report, interacting with a user, and sending the results of a query to a GUI.\n\nThere are two approaches to accessing SQL from a general purpose programming language:\n- **Dynamic SQL**\n  \n  A general purpose program can _connect to_ and _communicate with_ a database server using a collection of functions.\n\n- **Embedded SQL**\n  \n  Provides a means by which program can interact with a database server. However, under embedded SQL:\n  - The SQL statements are identified at compile time, and are translated into function calls.\n  \n  - At runtime, these function calls connect to the database using an API that provides dynamic SQL facilities (but may be specific to the database being used).","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Additional-basic-SQL-operations":{"title":"Additional basic SQL operations","content":"\n## Rename operation\n\nSQL allows renaming relations and attributes using the `AS` clause.\n\n```sql\nold_name AS new_name\n```\n\nThe keyword `AS` is optional and may be omitted.\n\n## String operation\n\nSQL includes a string matching operator for comparisons on character strings.\\\n\n```sql\nLIKE some_string\n```\n\nThe operator `LIKE` uses patterns; they can be described using two special characters: `%` and `_`.\n\n- `%`: Matches any string.\n- `_`: Matches any character.\n\nPatterns are case-sensitive. SQL supports a variety of string operations such as:\n\n- `str1 || str2`: Concatenate `str1` and `str2`.\n- `UPPER(str)`, `LOWER(str)`: Converting from lower to upper / upper to lower cases.\n- `LENGTH(str)`: Finding the length of `str`.\n- `SUBSTR(str, start, length)`: Extracting substring.\n\n### Escape Character\n\nFor patterns to include the special pattern characters (% and _), SQL allows the specification of an **escape character** defined using the `ESCAPE` keyword.\n\n```sql\nLIKE some_string ESCAPE escape_character\n```\n\nFor example,\n\n- `LIKE 'ab\\%cd%' ESCAPE '\\'` matches all strings beginning with `'ab%cd'`.\n- `LIKE 'ab\\\\cd%' ESCAPE '\\'` matches all strings beginning with `'ab\\cd'`.\n\n## Ordering the display of tuples\n\nThe `ORDER BY` clause causes the tuples in the results of a query to appear in sorted order.\n\n```sql\nORDER BY some_attribute\n```\n\nWe may specify `DESC` for descending order or `ASC` for ascending order; ascending order is the default setting.\n\n`ORDER BY` can sort on multiple attributes.\n\n### `LIMIT` clause\nA `LIMIT n` clause, used in conjunction with an `ORDER BY` clause, can be added at the end of an SQL query to specify that only first `n` tuples should be the output.\n\n```sql\nORDER BY some_attribute\nLIMIT n\n```\n\nHowever, `LIMIT` clause does not support [[notes/Advanced aggregation features#Ranking with partitions | partitioning]], so top `n` results within each partition cannot be obtained without performing [[notes/Advanced aggregation features | ranking]].\n\nFurthermore, if more than one tuple has the same value for the attribute, it is possible that one is included in the top `n`, whilst another is excluded.\n\n## `WHERE` clause predicates\n\nSQL includes a `BETWEEN` comparison operator to simplify `WHERE` clauses.\n\n```sql\nWHERE some_attribute BETWEEN start_val AND end_val\n```\n\nSQL allows the use of the notation `(v_1, ... , v_n)` to denote a tuple of arity `n` containing values `v_1`, ‚Ä¶ , `v_n`.\n\nThe comparison operator can be used on tuples, and the ordering is defined lexicographically.\n\n- e.g., `(a_1, a_2) \u003c= (b_1, b_2)` is true if both `a_1 \u003c= b_1` and `a_2 \u003c= b_2`.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Advanced-aggregation-features":{"title":"Advanced aggregation features","content":"\n## Ranking\nFinding the position of a value in a larger set is a common operation. In SQL, **ranking** is done by `RANK() OVER` in conjunction with an `ORDER BY` specification.\n\n**Examples**\n- Find the rank of each student\n```sql\nSELECT  ID,\n        RANK() OVER (ORDER BY (GPA) DESC) AS s_rank\nFROM    student_grades;\n/* student_grades(ID, GPA) is a relation \n * giving the GPA of each student */\n```\nHere, an extra `ORDER BY` clause can return the results in sorted order.\n```sql\nSELECT  ID,\n        RANK() OVER (ORDER BY (GPA) DESC) AS s_rank\nFROM    student_grades\nORDER BY s_rank ASC;\n```\n\nA basic issue with ranking is how to deal with the case of mutiple tuples that are the same values on the ordering attribute(s).\n\n- Naturally, the `RANK()` function leaves gaps.\n  \n  Meaning that if the highest GPA is shared by two students, both would get rank `1`, and the next rank would be `3`.\n\n- There is a `DENSE_RANK()` function which does not leave gaps.\n\n### Ranking with partitions\nRanking can be done within partitions of data, using `PARTITION BY`.\n\n**Example**\n- Find the rank of students within each department\n```sql\nSELECT  ID,\n        dept_name,\n        RANK() OVER \n        (\n            PARTITION BY dept_name\n            ORDER BY GPA DESC\n        ) AS dept_rank\nFROM    dept_grades\nORDER BY dept_name, dept_rank;\n```\n\n- Multiple rank expressions can be used within a single `SELECT` statement.\n\n- When ranking (possibly with partitioning) occurs along with a `GROUP BY` clause, the `GROUP BY` clause is applied first, and partitioning and ranking are done on the results of `GROUP BY`, allowing aggregate values to be used for ranking.\n\n### Other ranking related features\n- `PERCENT_RANK`: Gives the rank of the tuple as a fraction\n- `CUME_DIST`: Cumulative distribution\n- `ROW_NUMBER`: Sorts the rows and gives each row a unique number corresponding to its position\n  - Non-deterministic in presence of duplicates\n\n- `NULLS FIRST`, `NULLS LAST`\n- `NTILE(n)`: Takes the tuples in each partition in the specified order, and divides them into `n` buckets with **equal numbers of tuples**\n  \n**Example**\n- Find for each student the quartile they belong to\n```sql\nSELECT  ID,\n        NTILE(4) OVER (ORDER BY GPA DESC) AS quartile\nFROM    student_grades;\n```\n\n## Windowing\nWindow queries compute an aggregate function over ranges of tuples. They are used to **smooth out** random variables.\n\nUnlike partitions, windows may overlap, in which case a tuple may contribute to more than one window.\n\nSQL provides a windowing feature to support such queries.\n```sql\nROWS n_1 PRECEDING AND n_2 FOLLOWING\n```\n\n**Example**\n- Compute the sum for each three days window.\n```sql\nSELECT  date,\n        SUM(value) OVER\n        (\n            ORDER BY date\n            ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n        )\nFROM    sales;\n```\n\n### Other windowing related features\n- `UNBOUNDED`: The number of preceding / following rows are unbounded\n- `CURRENT ROW`: Specifies the current row\n  - e.g., `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`\n- `RANGE BETWEEN ...`: Cover all tuples with a particular **value** rather than covering a specific number of tuples\n\n### Windowing with partitions\nSQL supports windowing within partitions.\n\n**Example**\n- Find total balance of each account after each transaction on the account\n```sql\nSELECT  account_number,\n        date_time,\n        SUM(value) OVER\n        (\n            PARTITION BY account_number\n            ORDER BY date_time\n            ROWS UNBOUNDED PRECEDING\n        ) AS balance\nFROM    transaction\nORDER BY account_number, date_time;\n```","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Aggregate-functions":{"title":"Aggregate functions","content":"\n**Aggregate functions** are functions that take a collection of values as input, and return a single value.\n\nSQL offers five aggregate functions:\n\n- Average: `AVG`\n- Minimum: `MIN`\n- Maximum: `MAX`\n- Total: `SUM`\n- Count: `COUNT`\n\nThe input to `AVG` and `SUM` must be a collection of numbers.\n\n## Aggregation with Grouping\n\n`GROUP BY` clause uses the given attributes to form groups.\n\n```sql\nGROUP BY some_attributes\n```\n\n- **Example**\n    \n    Find the average salary of instructors in each department.\n    \n    ```sql\n    SELECT   dept_name,\n    \t\t\t\t AVG(salary) AS avg_salary\n    FROM     instructor\n    GROUP BY dept_name\n    ```\n    \n\nAttributes in `SELECT` statement that is outside of aggregate functions **must** appear in the `GROUP BY` clause; otherwise the query is treated as erroneous.\n\n## `HAVING` Clause\n\nSQL applies predicated in the `HAVING` clause **after** the formation of groups, whereas predicates in the `WHERE` clause are applied **before** the group formation.\n\n```sql\nGROUP BY some_attributes\nHAVING   predicate\n```\n\nA typical query containing aggregation, `GROUP BY`, and/or `HAVING` clauses is defined by the following sequence of operations.\n\n1. The `FROM` clause is first  evaluated to get a relation.\n2. If a `WHERE` clause is present, the predicate in the `WHERE` clause is applied on the result relation of the `FROM` clause.\n3. Tuples satisfying the `WHERE` predicate are then placed into groups by the `GROUP BY` clause (if present).\nOtherwise the entire set of tuples satisfying `WHERE` clause‚Äôs predicate is treated as one single group.\n4. The `HAVING` clause (if present) is applied to **each group**, the groups that do not satisfying the `HAVING` predicate are removed.\n5. The `SELECT` clause uses the remaining groups to generate tuples of the result of the query, applying the aggregate functions to get a single result tuple for each group.\n\n## Aggregation with `NULL` Values\n\n- All aggregate functions except `COUNT` ignore `NULL` values in their input collection.\n- The `COUNT` of an empty collection is defined to be `0`.\n- All other aggregate operations return a value `NULL` when applied to an empty collection.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Algorithms":{"title":"Algorithms","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Alternating-multilinear-form":{"title":"Alternating multilinear form","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Approximation-theory":{"title":"Approximation theory","content":"\n**Approximation theory** is concerned with how functions can best be _approximated_ with simpler functions, and with quantitatively characterising the errors introduced thereby.\n\n- [Weierstrass approximation theorem](notes/Weierstrass%20approximation%20theorem.md)\n- ","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Artificial-intelligence":{"title":"Artificial intelligence","content":"\n**Artificial intelligence** is is intelligence demonstrated by machines, as opposed to the **natural intelligence** displayed by animals including humans.\n\n## Basics\n### Mathematics\n- [Linear algebra](notes/Linear%20algebra.md)\n- [Vector analysis](notes/Vector%20analysis.md)\n- [Statistics](notes/Statistics.md)\n\n## Goals\n### Planning\n- [Automated planning and scheduling](notes/Automated%20planning%20and%20scheduling.md)\n\n### Learning\n- [Machine learning](notes/Machine%20learning.md)\n\n### Natural language processing\n- [Natural language processing](notes/Natural%20language%20processing.md)\n\n### Perception\n- [Computer vision](/notes/Computer%20vision.md)\n- [Speech recognition](notes/Speech%20recognition.md)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Assertion":{"title":"Assertion","content":"\nAn **assertion** is a predicate expressing a condition that we wish the database to always satisfy.\n\n[[notes/SQL data definition#Domain types in SQL | Domain constraints]] and [[notes/Integrity constraints#Referential integrity | referential integrity constraint]] are special forms of assertions.\n\n```sql\nCREATE ASSERTION a CHECK(p);\n```\n- `a`: Name of the assertion\n- `p`: Predicate\n\nWhen an assertion is created, the system checks it for validity. If the assertion is valid, then any future modification to the database is allowed only if it does not cause assertion violation.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Atomic-operation":{"title":"Atomic operation","content":"\n## Definition\nAn **atomic operation** is an _indivisible_ operation that _cannot be ineterleaved_ or split by other operations.\n\n## Examples\n- On most modern architectures, a `load` or `store` of a 32-bit word from or to memory is an atomic operation.\n- However, depending on the hardware implementation, a `load` or `store` of a 64-bit word may not be atomic.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/AttributeE-R":{"title":"Attribute(E-R)","content":"\nAn attribute of an [[notes/Entity set|entity set]] is a function that maps from the entity set into a domain. Since an entity set may have several attributes, each entity can be described by a set of (attribute, data value) pairs, one pair for each attribute of the entity set.\n\nAn attribute, as used in the E-R model, can be characterised by the following attribute types.\n\n- **Simple** / **Composite**\n  - **Simple** attributes are not divided into subparts (i.e., other attributes).\n  - **Composite** attributes can be divided into subparts.\n- **Single-valued** / **Multivalued**\n  - **Single-valued** attributes have a single value for a particular entity.\n  - **Multivalued** attributes have a set of values for a specific entity.\n- **Derived**\n  - The value of derived attributes can be derived from the values of other related attributes or entities.\n\nAn attribute takes a [[notes/Null values in SQL|null]] value when an entity does not have a value for it.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Authorisation":{"title":"Authorisation","content":"\nA user can be assigned several forms of authorisations on parts of the database:\n- **Read**: Allows reading, but not modification of data\n\n- **Insert**: Allows insertion of new data, but not modification of existing data\n\n- **Update**: Allows modification, but not deletion of data\n\n- **Delete**: Allows deletion of data\n\nEach of these types of authorisations is called **privilege**.\n\nA user can be authorised all, none, or a combination of these types of privileges on specified parts of a database, such as a relation or a view.\n\n## Granting and revoking or privileges\n### `GRANT` statement\nThe `GRANT` statement is used to **confer** authorisation.\n```sql\nGRANT   \u003cprivilege list\u003e\nON      \u003crelation / view\u003e\nTO      \u003cuser list\u003e;\n```\nHere, `\u003cprivilege list\u003e` can be\n- `SELECT`: Allows read access, or the ability query using the view\n- `INSERT`: Ability to insert tuples\n- `UPDATE`: Ability to update using the SQL `UPDATE` statement\n- `DELETE`: Ability to delete tuples\n- `ALL PRIVILEGES`: Short form for all the allowable privileges\n\nand the `\u003cuser list\u003e` can be\n- a user ID\n- `PUBLIC`, which allows all valid users the privilege granted\n- A **[[notes/Roles | role]]**\n\nNote that\n- Granting a privilege on a view does **not** imply granting any privileges on the underlying relations.\n  \n- The grantor of the privilege **must** already hold the privilege on the specified item.\n\n### `REVOKE` statement\nThe `REVOKE` statement is used to **revoke** authorisation.\n```sql\nREVOKE  \u003cprivilege list\u003e\nON      \u003crelation / view\u003e\nTO      \u003cuser list\u003e;\n```\nIf the `\u003cprivilege list\u003e` is\n- `ALL`: **All** privileges the revokee may hold, are revoked.\n\nIf the `\u003cuser list\u003e` is \n- `PUBLIC`: **All** users lose the privilege, except those granted it explicitly.\n\nNote that\n- If the same privilege was granted more than once to the same user by **different** grantees, then the user may **retain** the privilege after one revocation.\n\n- All privileges that depend on the privilege being revoked are **also revoked**.\n\n## Authorisation on views\n- A user who creates a [[notes/Views | view]] must have at least `SELECT` privilege on the base relation.\n  \n- The creator of the view does **not** receive all privileges on that view.\n  - Only those privileges that provide no additional authorisation beyond those that the user already had, are given.\n  \n- Users who received only the privilege on the view does not have privilege on the base relation.\n\n## Other authorisation features\n### `REFERENCES` privilege\nSQL includes a `REFERENCES` privilege that permits a user to declare foreign keys when creating relations.\n```sql\nGRANT   REFERENCES(A_1, ... , A_k)\nON      r\nTO      \u003cuser list\u003e;\n```\n- `r`: Relation\n- `A_i`: Attributes of `r`\n\nSuch privilege is required because:\n- [[notes/Integrity constraints#Referential integrity | Foreign key constraints]] restrict deletion and update operations on the referenced relation, which may restrict future activity by other users.\n\n- With the `REFERENCES` privilege, the user can **check for the existence** of a certain value in a certain (set of) attributes of the referenced relation.\n\n### Transfer of privileges\nThe privilege to allow the recipient to _pass the privilege onto other users_ can be explicitly given.\n```sql\nGRANT   \u003cprivilege list\u003e\nON      \u003crelation / view\u003e\nTO      \u003cuser list\u003e\nWITH GRANT OPTION;\n```\nIt is also possible to specify the actions when a privilege is _revoked_ from a user.\n\nOne option is to **cascade** the revoking operation, meaning that **all** privileges the revokee granted with `GRANT OPTION` is also revoked.\n```sql\nREVOKE  \u003cprivilege list\u003e\nON      \u003crelation / view\u003e\nFROM    \u003cuser list\u003e\nCASCADE;\n```\nThe keyword `CASCADE` can be omitted, as it is the basic behaviour of the `REVOKE` operation.\n\nAnother option is to maintain the privileges the revokee granted to other users, and only revoke the revokee's privilege.\n```sql\nREVOKE  \u003cprivilege list\u003e\nON      \u003crelation / view\u003e\nFROM    \u003cuser list\u003e\nRESTRICT;\n```","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Basic-structure-of-SQL-queries":{"title":"Basic Structure of SQL Queries","content":"\n## Basic Query Structure\n\nA typical SQL query has the following form.\n\n```sql\nSELECT  A_1, ... , A_n\nFROM    r_1, ... , r_m\nWHERE   p\n```\n\n- `A_i`: Attributes\n- `r_i`: Relations\n- `p`: Predicate\n\nThe result of an SQL query is a relation.\n\n### `SELECT` Clause\n\n- The `SELECT` clause lists the attributes desired in the result of a query.\n  \n    It corresponds to the projection operation $\\Pi$ of the [[notes/Relational algebra | relational algebra]].\n    Note that SQL names are case insensitive.\n    \n- The `DISTINCT` keyword inserted after `SELECT` eliminates all duplicates.\n- The `ALL` keyword, on the other hand, explicitly specifies that duplicates should not be removed, although it is the default of `SELECT` clause.\n    \n- A `*` in the `SELECT` clause denotes all attributes.\n- An attribute can be a literal **without** `FROM` clause.\n\n    The result is a table with one column and a single row with the literal value.\n    \n- An attribute can be a literal **with** `FROM` clause.\n    \n    The result is a table with one column and rows (number equal to the number of rows on the table), each row with the literal value.\n    \n- `SELECT` clause can contain arithmetic expressions (`+`, `-`, `*`, `/`) operating on constants or attributes of tuples.\n\n### `FROM` Clause\n\n- The `FROM` clause lists the relations involved in the query.\\\nIt corresponds to the Cartesian product $\\times$ of the [[notes/Relational algebra | relational algebra]].\n    \n\n### `WHERE` Clause\n\n- The `WHERE` clause specifies conditions that the resulting relation must satisfy.\n\n    It corresponds to the selection operation $\\sigma$ of the [[notes/Relational algebra | relational algebra]].\n    \n- SQL allows the use of the logical connectives `AND`, `OR`, and `NOT`.\n- The operands of the logical connectives can be expressions involving the comparison operators, `\u003c`, `\u003c=`, `\u003e`, `\u003e=`, `=`, and `\u003c\u003e`.\\\nComparisons can be applied to results of arithmetic expressions.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Basis":{"title":"Basis","content":"\n## Definition\n\u003eLet $V$ be a [vector space](notes/Vector%20space.md) and $\\beta$ be a subset of $V$.\\\n\u003eIf $\\beta$ is [linearly independent](notes/Linear%20independence.md) and [spans](notes/Span.md) $V$, then $\\beta$ is a **basis** of $V$.\\\n\u003eWe can also say that $\\beta$ forms a basis for $V$.\n\n## Theorems\n### Theorem 1\n\u003eLet $V$ be a vector space over a [field](notes/Field.md) $F$, and $\\def\\v#1{\\mathbf{#1}} \\v{u}\\_1, \\cdots, \\v{u}\\_n$ be $n$ distinct vectors of $V$.\\\n\u003eThen $\\def\\v#1{\\mathbf{#1}} \\beta = \\lbrace \\v{u}\\_1, \\cdots, \\v{u}\\_n \\rbrace$ forms a basis for $V$ if and only if an arbitrary vector $\\mathbf{v} \\in V$ can be **uniquely** written as a linear combination of vectors of $\\beta$.\\\n\u003eIn other words, $\\exists! a\\_1, \\cdots, a\\_n \\in F$ such that $\\def\\v#1{\\mathbf{#1}} \\v{v} = \\sum\\limits^n\\_{i=1} a\\_i\\v{u}\\_i$.\n\n### Proof\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Bernstein-polynomial":{"title":"Bernstein polynomial","content":"\nA **Bernstein polynomial** is a polynomial that is a [linear combination](notes/Linear%20combination.md) of Bernstein [basis](notes/Basis.md) polynomials.\n\n## Definition\nThe $n‚Ää+1$ **Bernstein basis polynomials** of degree $n$ are defined as\n\u003e $b_{\\nu, n}(x) = \\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}, \\qquad \\text{where } \\nu = 0, \\cdots, n$.\n\nThe name is from the fact that the Bernstein basis polynomials of degree $n$ form a [basis](notes/Basis.md) for the [vector space](notes/Vector%20space.md) $\\mathbb{P}_n$, a space which consists of polynomials with degree at most $n$. \n\nA **Bernstein polynomial** is a linear combination of Bernstein basis polynomials:\n\u003e $B_n(x) = \\sum\\limits_{\\nu = 0}^n \\beta_\\nu b_{\\nu, n}(x)$\n\nwhere the coefficients $\\beta_\\nu$ are called **Bernstein coefficients**.\n\n## Examples\n### Approximation of continuous functions\nLet $f$ be a continuous funciton on the interval $[0,1]$. Let $\\beta_\\nu = f\\left(\\dfrac{\\nu}{n}\\right)$.\nWe can denote the corresponding Bernstein polynomial as $B_n(x; f)$.\nThe corresponding Bernstein polynomial becomes:\n$$\n\\begin{aligned}\nB_n(x; f) \u0026= \\sum\\limits_{\\nu = 0}^n f\\left(\\dfrac{\\nu}{n}\\right)b_{\\nu, n}(x)\\\\\n\u0026= \\sum\\limits_{\\nu = 0}^n f\\left(\\dfrac{\\nu}{n}\\right)\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}.\n\\end{aligned}\n$$\n\n\n## Properties\n### Property #1\n\u003e $B_n(x; \\mathbb{1}) = 1$\n\n### Property #2\n\u003e $B_n(x;x) = x$\n\n### Property #3\n\u003e $B_n(x;x^2) = x^2 + \\dfrac{1}{n}(x - x^2)$\n\n### Property #4\n\u003e $B_n(x; af + g) = aB_n(x; f) + B_n(x;g)$\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Bounded-buffer-problem":{"title":"Bounded buffer problem","content":"\n## Definition\n```\n+----------+                    +----------+\n|          |    +----------+    |          |\n| Producer |---\u003e|  Buffer  |---\u003e| Consumer |\n|          |    +----------+    |          |\n+----------+                    +----------+\n```\n\n- The producer puts objects into a shared buffer.\n- The consumer takes them out.\n- There must be a synchronisation to coordinate between the producer and the consumer.\n- The producer and the consumer should not need to work in [lock](Lock.md) step; there is a fixed-size buffer between them.\n\t- The access to this buffer must be synchronised.\n\t- The producer must wait if the buffer is full.\n\t- The consumer must wait if the buffer is empty.\n\n## Implementation Example\n- **Producer**\n```C\nfor (int i = 0; i\u003cMAX_LOOP; i++)\n{\n  try_put (i);\n}\n```\n\n- **Consumer**\n```C\nwhile (true)\n{\n  int tmp = try_get ();\n  printf (\"%d\\n\", tmp);\n}\n```\n\nInitially, the buffer is a _queue_ with `front = tail = 0`, and the lock is initially `free`. Let `MAX` be the maximum capacity of the buffer. Then, the `try_put ()` and `try_get ()` can be implemented as follows.\n\n- **`try_put`**\n```C\ntry_put (item)\n{\n  lock.acquire ();\n  if ((tail - front) \u003c size)    // Buffer is not full\n  {\n\tbuffer[tail % MAX] = item;\n\ttail++;\n  }\n  lock.release ();\n}\n```\n\n- **`try_get`**\n```C\ntry_get ()\n{\n  item = NULL;\n  lock_acquire ();\n  if (front \u003c tail)            // Buffer is not empty\n  {\n\titem = buffer[front % MAX];\n\tfront++;\n  }\n  lock_release ();\n  return item;\n}\n```\n\nHere, the shared states are `buffer`, `front`, and `tail`.\n\nHowever, one cannot assure that the `buffer` is empty when `try_get ()` returns `NULL`.\n- If a producer generates an item between `lock_release ()` and `return`, even though the `buffer` is not empty, `try_get ()` returns `NULL`.\n- For a thread to know when the `buffer` is empty, there must be _[another primitive](Condition%20variable.md)_ for the purpose.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Boyce-Codd-normal-form":{"title":"Boyce-Codd normal form","content":"\n## Definition\n\nA relation schema $R$ is in **Boyce-Codd normal form(BCNF)** with respect to a set of [[notes/Functional dependency|functional dependencies]] $F$ if:\n\nFor all functional dependencies $\\alpha \\to \\beta \\in F^+$, where $\\alpha, \\beta \\subseteq R$, at least one of the following holds:\n- $\\alpha \\to \\beta$ is trivial. (i.e., $\\beta \\subseteq \\alpha$)\n- $\\alpha$ is a [[notes/Keys|superkey]] of $R$. (i.e., $\\alpha \\to R$)\n\n### Example\n\nConsider $\\texttt{in-dep(\\underline{ID}, name, salary, \\underline{deptName}, building, budget)}$, and the set of functional dependencies $F = \\lbrace \\texttt{ID} \\to \\lbrace \\texttt{name,deptName,salary} \\rbrace, \\texttt{deptName} \\to \\lbrace \\texttt{building,budget} \\rbrace \\rbrace$.\n  - This is **not** in BCNF because\n    - $\\texttt{deptName} \\to \\texttt{building,budget}$ holds in $\\texttt{in-dep}$, but\n    - $\\texttt{deptName}$ is **not** a superkey.\n\n## Testing for BCNF\n\n### Testing a functional dependency\n\nTo check if a nontrivial functional dependency $\\alpha \\to \\beta$ causes a violation of BCNF:\n\n1. Compute $\\alpha^+$.\n2. Verify that $R \\subseteq \\alpha^+$. i.e., $\\alpha^+$ is a superkey of $R$.\n\n### Testing a relation schema decomposition\n\nLet $R$ be a relation schema, and $R_1, \\cdots, R_n$ be a decomposition of $R$. Let $F$ be the set of functional dependencies.\n\n1. For every set of attributes $\\alpha \\subseteq R_i$, compute $\\alpha^+$. \n2. Verify that either $\\alpha^+ \\cap (R_i \\setminus \\alpha) = \\empty$ or $R \\subseteq \\alpha^+$.\n   - If the condition is violated by some $\\alpha$, the dependency $\\alpha \\to \\left( (\\alpha^+ \\setminus \\alpha) \\cap R_i \\right) \\in F^+$. Hence $R_i$ violates BCNF.\n\n## Decomposition into BCNF\n\nLet $R$ be a schema that is not in BCNF, and let $\\alpha \\to \\beta$ be the functional dependency that causes a violation in BCNF.\n\nThen, the following decomposition of $R$ is in BCNF.\n- $\\alpha \\cup \\beta$\n- $R \\setminus (\\beta \\setminus \\alpha)$\n\nIn most cases, $\\beta \\setminus \\alpha = \\beta$.\n\n### Example\nConsider a schema $R = \\texttt{dept-advisor}(\\texttt{\\underline{sID}}, \\texttt{\\underline{deptName}}, \\texttt{iID})$ with the functional dependencies $\\texttt{iID} \\to \\texttt{deptName}$ and $\\texttt{sID}, \\texttt{deptName} \\to \\texttt{iID}$.\n\nHere, the dependency $\\texttt{iID} \\to \\texttt{deptName}$ is causing a violation of BCNF conditions.\n\nThe decomposition\n- $\\alpha \\cup \\beta = (\\texttt{iID}, \\texttt{deptName})$\n- $R \\setminus (\\beta \\setminus \\alpha) = (\\texttt{sID}, \\texttt{iID})$\n\nis in BCNF.\n\nHowever, any of the decomposed relation does not include all the attributes used in the dependency $\\texttt{sID}, \\texttt{deptName} \\to \\texttt{iID}$; it is **not** dependency preserving.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Canonical-cover":{"title":"Canonical cover","content":"\n## Extraneous attribute\n\nSome attributes in a given relational schema do not affect the [[notes/Closure(Database)|closure of functional dependency]] of the schema.\n\nAn attribute of [[notes/Functional dependency|functional dependency]] in $F$ is said to be **extraneous** if it can be removed without changing its closure $F^+$.\n\nWhen removing an attribute from a functional dependency:\n\n- Removing an attribute from the **left** side of a functional dependency could make it a **stronger** constraint.\n- Removing an attribute from the **right** side of a functional dependency could make it a **weaker** constraint.\n\nConsider a set $F$ of functional dependencies and a functional dependency $\\alpha \\to \\beta \\in F$. Then attribute $A$ is **extraneous** if:\n\n- $A \\in \\alpha$:\\\n  $F$ logically implies $\\left( F \\setminus \\lbrace \\alpha \\to \\beta \\rbrace \\right) \\cup \\lbrace (\\alpha \\setminus A) \\to \\beta \\rbrace$\n- $A \\in \\beta$:\\\n  $\\left( F \\setminus \\lbrace \\alpha \\to \\beta \\rbrace \\right) \\cup \\lbrace \\alpha \\to (\\beta \\setminus A) \\rbrace$ logically implies $F$.\n\nNote that a stronger functional dependency **always** implies a weaker one.\n\n### Testing if an attribute is extraneous\n\nLet $R$ be a relation schema, and let $F$ be a set of functional dependencies that hold on $R$.\n\nConsider an attribute $A$ in the functional dependency $\\alpha \\to \\beta \\in F$.\n\n- Testing if $A \\in \\alpha$ is extraneous in $\\alpha$:\n  1. Let $\\gamma = \\alpha \\setminus A$.\n  2. Compute $\\gamma^+$ under $F$.\n  3. If $\\beta \\subseteq \\gamma^+$, $A$ is extraneous in $\\alpha$.\n- Testing if $A \\in \\beta$ is extraneous in $beta$:\n  1. Let $F' = (F \\setminus \\lbrace \\alpha \\to \\beta \\rbrace) \\cup \\lbrace \\alpha \\to (\\beta \\setminus A) \\rbrace$\n  2. Compute $\\alpha^+$ under $F'$.\n  3. If $A \\in \\alpha^+$, $A$ is extraneous in $\\beta$.\n\n## Canonical cover\n\nA **canonical cover** for $F$ is a set of dependencies $F_c$ that satisfies all of the followings:\n- $F$ logically implies **all** dependencies in $F_c$.\n- $F_c$ logically implies **all** dependencies in $F$.\n- None of the attributes in $F_c$ is extraneous.\n- Each left side of all functional dependencies in $F_c$ is unique.\n  - i.e., $\\forall \\alpha_1 \\to \\beta_1, \\alpha_2 \\to \\beta_2 \\in F_c: \\alpha_1 \\neq \\alpha_2$\n\n### Purpose of canonical covers\n\nWhenever a user performs an update on a relation, the [[notes/Database systems|database system]] must ensure that the update does not violate any functional dependencies.\n\nThe effort spent in checking for violations in functional dependencies can be reduced by testing on only a simplified set of functional dependencies that has the same closure as the given set. This is the **canonical cover** of the functional dependencies.\n\n\n### Algorithm for computing canonical covers\n\n```\nF_c = F\nREPEAT\n  FOR EACH alpha -\u003e beta1, alpha -\u003e beta2 IN F_c\n    APPLY union rule\n    /* alpha -\u003e beta1, beta2 */\n    REPLACE TO F\n  FOR EACH f in F_c\n    IF EXISTS (extraneous attribute A) IN f\n    REMOVE A FROM f\nUNTIL (F_c CONVERGE)\n```\nNote that the **union rule** may become applicable after some extraneous attributes have been deleted, so it has to be re-applied.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Cauchy-Schwartz-inequality":{"title":"Cauchy-Schwartz Inequality","content":"## Theorem\nFor any vectors $\\mathbf{x},\\mathbf{y} \\in \\mathbb{R}^n$,\n$$\n|\\mathbf{x}^\\top\\mathbf{y}| \\leq \\|\\mathbf{x}\\|_2\\|\\mathbf{y}\\|_2.\n$$\n\n## Generalization\nSee [H√∂lder's inequality](notes/H%C3%B6lder's%20inequality.md).\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/ClosureDatabase":{"title":"Closure(Database)","content":"\n## Closure of functional dependencies\n\nGiven a set $F$ of [[notes/Functional dependency|functional dependencies]], there are certain other functional dependencies that are logically implied by $F$.\n\nThe set of all functional dependencies logically implied by $F$ is called the **closure** of $F$, and is denoted as $F^+$.\n\n### Armstrong's axioms\n\nFor any set $F$ of functional dependencies, the closure $F^+$ of $F$ can be obtained by repeatedly applying **Armstrong's axioms**.\n\nLet $\\alpha, \\beta, \\gamma, \\delta$ be sets of attributes of a relation schema $R$ with the set of functional dependency $F$.\n\n- **Reflexive rule**: $\\beta \\subseteq \\alpha \\Rightarrow \\alpha \\to \\beta$\n- **Augmentation rule**: $\\alpha \\to \\beta \\Rightarrow \\forall \\gamma: \\gamma\\alpha \\to \\gamma\\beta$\n- **Transitivity rule**: $\\alpha \\to \\beta \\land \\beta \\to \\gamma \\Rightarrow \\alpha \\to \\gamma$\n\nThe above rules are both\n- **Sound**: Generates only the functional dependencies that _actually hold_.\n- **Complete**: Generates _all_ the functional dependencies that hold.\n\nSome additional rules can be inferred from **Armstrong's axioms**.\n\n- **Union rule**: $\\alpha \\to \\beta \\land \\alpha \\to \\gamma \\Rightarrow \\alpha \\to \\beta\\gamma$\n- **Decomposition rule**: $\\alpha \\to \\beta\\gamma \\Rightarrow \\alpha \\to \\beta \\land \\alpha \\to \\gamma$\n- **Pseudo-transitivity rule**: $\\alpha \\to \\beta \\land \\gamma\\beta \\to \\delta \\Rightarrow \\alpha\\gamma \\to \\delta$\n\n## Closure of attribute sets\n\nSimilarly as [[notes/Functional dependency|functional dependencies]], a **closure** of an attribute set $\\alpha$ under $F$, denoted by $\\alpha^+$, can be defined.\n\nThe set of all attributes that are functionally determined by $\\alpha$ under $F$ are called the **closure** of $\\alpha$, and is denoted as $\\alpha^+$.\n\n### Usages of attribute closures\n\nAttribute closures can be used for various purposes:\n\n- **Testing for [[notes/Keys|superkey]]**\n  - Testing if $\\alpha$ is a superkey can be done by checking if $R \\subseteq \\alpha^+$.\n- **Testing functional dependencies**\n  - Testing if a functional dependency $\\alpha \\to \\beta$ is in $F^+$ can be done by checking $\\beta \\subseteq \\alpha^+$.\n- **Computing the closure $F^+$**\n  - $F^+$ can be obtained by finding $\\gamma^+$ for each $\\gamma \\subseteq R$, and for each $S \\subseteq \\gamma^+$, outputting a functional dependency $\\gamma \\to S$.\n\n## Algorithms for computing closures\n\n### Algorithm for computing $F^+$\n\n```\nF_closure = F\nREPEAT\n  FOR EACH f IN F_closure\n    APPLY reflexivity AND augmentation ON f\n    ADD TO F_closure\n  FOR EACH PAIR f1, f2 IN F_closure\n    IF f1 AND f2 APPLY transitivity\n    THEN ADD TO F_closure\nUNTIL (F_closure CONVERGE)\n```\n\n### Algorithm for computing $\\alpha^+$\n\n```\nA_closure = A\nREPEAT\n  FOR EACH beta -\u003e gamma IN A\n    IF beta IN A_closure\n    THEN ADD gamma TO A_closure\nUNTIL (A_closure CONVERGE)\n```\n\n## Closure of multivalued dependencies\n\nThe concept of closures can also be applied to [[notes/Multivalued dependency|multivalued dependencies]].\n\nFirst, note that from the definition of multivalued dependencies:\n- $\\alpha \\to \\beta \\Rightarrow \\alpha \\twoheadrightarrow \\beta$.\n- $\\alpha \\twoheadrightarrow \\beta \\Rightarrow \\alpha \\twoheadrightarrow R \\setminus (\\alpha \\cup \\beta)$\n\nGiven a set $D$ of multivalued dependencies, the **closure** $D^+$ is the set of all **functional and multivalued** dependencies logically implied by $D$.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Comparison-between-BCNF-and-3NF":{"title":"Comparison between BCNF and 3NF","content":"\nIt is always possible to decompose a relation into a set of relations that are in [[notes/Boyce-Codd normal form|BCNF]] such that:\n\n- The decomposition is **[[notes/Overview of normalisation#Lossless decomposition|lossless]]**.\n\nIt is always possible to decompose a relation into a set of relations that are in [[notes/Third normal form|3NF]] such that:\n\n- The decomposition is **[[notes/Overview of normalisation#Lossless decomposition|lossless]]**.\n- The decomposition **[[notes/Dependency preservation|preserves dependencies]]**.\n\n|    | BCNF | 3NF |\n|----|------|-----|\n| Redundancy | Less than 3NF | More than BCNF |\n| Lossless Decomposition | Always guaranteed | Always guaranteed |\n| Dependency Preservation | Not guaranteed | Always guaranteed |","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Comparison-between-processes-and-threads":{"title":"Comparison between processes and threads","content":"\n## Comparison\n|                        | [Processes](notes/Process.md)                 | [Threads](notes/Thread.md)                                                    |\n| ---------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |\n| Switch Overhead        | High (CPU state + Memory, I/O state)        | Low (CPU state only)                                                        |\n| Creation Cost          | High                                        | Low                                                                         |\n| CPU Protection         | Yes                                         | Yes                                                                         |\n| Memory, I/O Protection | Yes                                         | No                                                                          |\n| Sharing Overhead       | High (Involves at leas a context switch)    | Low (Because thread switch overhead is low; may not need to switch context) |\n| Sharing Security       | High (One process cannot corrupt the other) | Low (A thread can write the memory used by another thread)                  |\n\n## Diagrams\n![process-diagram](/notes/images/process-diagram.png)\n\n![processes-diagram](/notes/images/processes-diagram.png)\n\n![threads-diagram](/notes/images/threads-diagram.png)\n\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Computer-architecture":{"title":"Computer architecture","content":"\n**Computer architecture** is a set of rules and methods that describe the functionality, organisation, and implementation of computer systems.\n\n## Computer Abstractions\n- [Performance](notes/Performance.md)\n\n## Instructions\n- [MIPS Assembly language](notes/MIPS%20Assembly%20language.md)\n\t- Representation of MIPS instructions in the computer\n- \n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Computer-graphics":{"title":"Computer graphics","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Computer-vision":{"title":"Computer vision","content":"\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Concrete-syntax":{"title":"Concrete syntax","content":"\n**Concrete syntax** determines whether a certain string is a program or not.\n\n## Intuition\nLet $C$ be the set of all characters. Then, the set of all strings $S$ can be defined as\n$$\nS = \\lbrace c_1c_2\\cdots c_n : c_i \\in C \\rbrace.\n$$\nConcrete syntax defines which strings are considered as programs. Let $P$ be the set of all possible programs. In other words,\n$$\nP = \\lbrace p: p \\text{ is a program} \\rbrace.\n$$\nIt is clear that $P \\subseteq S$. Concrete syntax determines which elements $s \\in S$ are in $P$. \n\nHowever, $P$ is (in most cases) an infinite set. Hence a sophisticated way to define concrete syntax is required.\n\n## Backus-Naur Form (BNF)\nBNF is one of the most popular method to define a concrete syntax. It consists of three concepts: **terminals**, **non-terminals**, and **expressions**.\n\n### Terminals\nA terminal is a string. `\"00\"`, `\"abc\"` are examples of terminals. Simple!\n\n### Non-terminals\nA non-terminal, also called a **metavariable**, denotes a set of strings. In BNF, it is denoted as a name between a pair of angle brackets. `\u003cdigit\u003e`,`\u003cexpression\u003e` are examples of non-terminals.\n\n### Expressions\nAn expression is an enumeration of one or more terminals/nonterminals. The followings are all examples of expressions.\n- `\"abc\"`\n- `\"0\"` `\"1\"`\n- `\u003cdigit\u003e`\n- `\u003cdigit\u003e` `\u003cnumber\u003e`\n- `\"-\"` `\u003cnumber\u003e`\n\nNow, it is possible to construct a concrete syntax in BNF. In BNF, a definition of a set is denoted as:\n\n`[nonterminal] ::= [expression] | [expression] | ...`\n\nwhere the vertical bars separates distinct expressions.\n\nAn example of BNF can be given as:\n```\n\u003cdigit\u003e  ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n\u003cnat\u003e    ::= \u003cdigit\u003e | \u003cdigit\u003e \u003cnat\u003e\n\u003cnumber\u003e ::= \u003cnat\u003e | \"-\" \u003cnat\u003e\n```","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Condition-variable":{"title":"Condition variable","content":"\n## Definition\nA **condition variable** is a synchronisation object that lets a [thread](notes/Thread.md) efficiently wait for a change to shared state that is protected by a [lock](notes/Lock.md).\n\n## APIs\nA condition variable has three methods.\n\n- **`CV::wait(Lock *lock*)`**\n\t- This call [atomically](notes/Atomic%20operation.md) **releases the lock** and **suspends execution of the calling thread**, placing the calling thread on the condition variable's waiting list.\n\t- Later, when the calling thread is awakened, the lock is re-acquired before returning from the `wait` call.\n\n- **`CV::signal()`**\n\t- This call takes **one** thread off the condition variable's wait list and marks it as eligible to run (i.e., it puts the thread on the scheduler's ready list).\n\t- If no threads are on the waiting list, `signal` has no effect.\n\n- **`CV::broadcast()`**\n\t- This call takes **all** threads off the condition variable's waiting list and marks them as eligible to run.\n\t- If no threads are on the waiting list, `broadcast` has no effect.\n\n## Properties\n### Memoryless\n- The conditional variable itself has _no internal state_ other than a **queue** of waiting threads.\n\t- Condition variables do not need their own state because they are always used inside shared objects that have their own state.\n- If no threads are currently on the condition variable's waiting list, a `signal` or `broadcast` has no effect.\n- The condition variable has no _memory_ of earlier calls to `signal` or `broadcast`.\n\n### [Atomic](notes/Atomic%20operation.md)  Lock Release\n- A thread always calls `wait` while holding a lock. The call to `wait` atomically releases the lock and puts the thread on the condition variable's waiting list.\n\t- Atomicity ensures that there is no separation between checking the shared object's state, deciding to wait, adding the waiting thread to the condition variable's queue and releasing the lock, so that some other thread can access the shared object.\n\n### Non-immediate Return\n- When a waiting thread is re-enabled, it is moved to the [scheduler](notes/Scheduler.md)'s ready queue with no special priority, and the scheduler may run it at some later time.\n- Furthermore, when the thread finally does run, it must re-acquire the lock, which means that other threads may have acquired and released the lock in the meantime, between the `signal` / `broadcast` occurs and when the waiter re-acquires the lock.\n- Even if the desired predicate were true when `signal` / `broadcast` was called, it may no longer be true when `wait` returns.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/ConstraintE-R":{"title":"Constraint(E-R)","content":"\nAn E-R enterprise schema may define certain constraints to which the contents of a database must conform.\n\n## Mapping cardinality\n**Mapping cardinality** expresses the number of entities to which another entity can be associated via a relationship set. It is most useful in describing binary relationship sets.\n\nFor a binary relationship set $R$ between entity sets $A$ and $B$, the mapping cardinality must be one of the following:\n- **One-to-one**\n- **One-to-many**\n- **Many-to-one**\n- **Many-to-many**\n\n### One-to-one\nAn entity in $A$ is associated with _at most_ one entity in $B$, and vice versa.\n\n![one-to-one-mapping-example](notes/images/one-to-one-mapping-example.png)\n\n### One-to-many\nAn entity in $A$ is associated with any number (zero or more) of entities in $B$. An entity in $B$ can be associated with _at most_ one entity in $A$.\n\n![one-to-many-mapping-example](notes/images/one-to-many-mapping-example.png)\n\n### Many-to-one\nAn entity in $A$ can be associated with _at most_ one entity in $B$. An entity in $B$ is associated with any number (zero or more) of entities in $A$.\n\n![many-to-one-mapping-example](notes/images/many-to-one-mapping-example.png)\n\n### Many-to-many\nAn entity in $A$ is associated with any number (zero or more) of entities in $B$, and vice versa.\n\n![many-to-many-mapping-example](notes/images/many-to-many-mapping-example.png)\n\n## Participation constraints\n\nLet $E$ be an entity set and $R$ be a relationship set.\n\n- **Total participation**\\\n    The participation of $E$ in $R$ is said to be **total** if every entity in $E$ participates in at least one relationship of $R$.\n\n- **Partial participation**\\\n    The participation of $E$ in $R$ is said to be **partial** if only some entities in $E$ participate in relationships in $R$.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Coordinates":{"title":"Coordinates","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Cramers-rule":{"title":"Cramer's rule","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Critical-section":{"title":"Critical section","content":"\n## Definition\nA **critical section** is a sequence of code that _atomically_ accesses shared state.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Database-normalisation":{"title":"Database normalisation","content":"\nThe method for designing a relational database is to use a process commonly known as **normalisation**. The goal of database normalisation is to:\n- Decide if a given relation schema is in 'good form'.\n- If a given relation schema is not in 'good form', losslessly decompose it into a number of smaller relation schemas, each of which is in an appropriate good form.\n\nDatabase normalisation theory is based on **[[notes/Functional dependency|functional dependencies]]** and **[[notes/Multivalued dependency|multivalued dependencies]]**.\n\n## Notational conventions\n\n- Greek letters $(\\alpha, \\beta, \\cdots)$ are used for attributes.\n- $K$ denotes a set of attributes which is a superkey.\n- Lowercase names $(r, s, \\cdots)$ are used for relations. Uppercase names $(R, S, \\cdots)$ are used for relation schemas.\n  - $r(R)$ denotes the relation $r$ with schema $R$.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Database-systems":{"title":"Database systems","content":"\nA **database** is an organised collection of interrelated data that models some aspect of the real world.\nA **database management system**(DBMS) is a collection of interrelated data and a set of programs to access those data.\n\n## Introduction\n- [[notes/Purpose of database systems]]\n- [[notes/View of data]]\n\n## Relational languages\n- [[notes/Structure of relational databases]]\n- [[notes/Keys]]\n- [[notes/Relational query language]]\n  - [[notes/Relational algebra]]\n## SQL\n### Introductory\n- [[notes/Overview of SQL]]\n- [[notes/SQL data definition]]\n- [[notes/Basic structure of SQL queries]]\n- [[Additional basic SQL operations]]\n- [[notes/Set operations in SQL]]\n- [[notes/Null values in SQL]]\n- [[notes/Aggregate functions]]\n- [[notes/Nested subqueries]]\n- [[notes/Modification of the database]]\n\n### Intermediate\n- [[notes/Join expressions]]\n- [[notes/Views]]\n  - [[notes/Update of a view]]\n- [[notes/Transactions]]\n- [[notes/Integrity constraints]]\n  - [[notes/Assertion]]\n- [[notes/SQL data types and schemas]]\n- [[notes/Authorisation]]\n  - [[notes/Roles]]\n\n### Advanced\n- [[notes/Accessing SQL from a programming language]]\n- [[notes/Triggers in SQL]]\n- [[notes/Recursive queries]]\n- [[notes/Advanced aggregation features]]\n\n## Database design\n### E-R model\n- [[notes/E-R model]]\n  - [[notes/Entity set]]\n  - [[notes/Relationship set]]\n  - [[notes/Attribute(E-R)]]\n- [[notes/Constraint(E-R)]]\n- [[notes/Primary key(E-R)]]\n- [[notes/Extended E-R features]]\n- [[notes/E-R diagram]]\n- [[notes/Reduction to relational schema]]\n- [[notes/E-R design issues]]\n\n### Relational database design\n- [[notes/Overview of normalisation]]\n- [[notes/Functional dependency]]\n- [[notes/Multivalued dependency]]\n  - [[notes/Closure(Database)]]\n  - [[notes/Restriction(Database)]]\n  - [[notes/Dependency preservation]]\n  - [[notes/Canonical cover]]\n- [[notes/Database normalisation]]\n  - [[notes/Boyce-Codd normal form]]\n  - [[notes/Third normal form]]\n    - [[notes/Comparison between BCNF and 3NF]]\n  - [[notes/Fourth normal form]]","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Deadlock":{"title":"Deadlock","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Dependency-preservation":{"title":"Dependency preservation","content":"\n## Overview\n\nTesting [[notes/Functional dependency|functional dependency]] constraints each time the database is updated can be costly. Thus, it is useful to design the database in a way that constraints can be tested efficiently.\n\nWhen decomposing a relation, it may be no longer possible to do the testing without having to perform a [[notes/Relational algebra#Cartesian Product|Cartesian product]] of [[notes/Relational algebra#Join|join]] operations.\n\nA decomposition that makes it computationally hard to enforce functional dependency is said to be _not_ **dependency preserving**. \n\nConversely, if functional dependencies of the original relation can be checked on the decomposed relations without the need of Cartesian product or join operations, is said to be **dependency preserving**.\n\n## Definition\n\nLet $F$ be the set of functional dependencies on schema $R$, and let $R_1, \\cdots, R_n$ be a decomposition of $R$. Let $F_i$ be a [[notes/Restriction(Database)|restriction]] of $F$ to $R_i$.\n\nThe decomposition is **dependency preserving** if the following holds:\n\n$$\n\\left( \\bigcup_{i=1}^n F_i \\right)^+ = F^+\n$$\n\nTesting for dependency preservation using the above definition takes exponential time.\n\n## Algorithm for testing dependency preservation\n\nThe following algorithm checks if a dependency $\\alpha \\to \\beta$ is preserved in a decomposition of $R$ into $D = \\lbrace R_1, \\cdots, R_n \\rbrace$.\n\n```\nresult = alpha\nREPEAT\n  FOR EACH R[i] IN D\n    t = CLOSURE(result INTERSECT R[i]) INTERSECT R[i]\n    result = result UNION t\nUNTIL (result CONVERGE)\n```\nIf `result` contains all attributes in $\\beta$, then the functional dependency $\\alpha \\to \\beta$ is presereved.\n\nThis method takes polynomial time, instead of exponential time required when using the definition directly.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Determinant":{"title":"Determinant","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Dimension":{"title":"Dimension","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Dual-mode-operation":{"title":"Dual-mode operation","content":"\n\n## Definition\n**Dual-mode operation** of a kernel consists of two modes: **user mode** and **kernel mode**. \n\n- In **user mode**, the processor checks each instruction before executing it to verify that it is permitted to be performed by that process.\n- In **kernel mode**, the operating system executes it with protection checks turned off.\n\n## Hardware Requirements\nThe following three things must be supported by the hardware in order to accomplish dual-mode operation.\n\n1. **Privileged Instructions**: All potentially unsafe instructions are prohibited when executing in user mode.\n2. **Memory Protection**: All memory accesses outside of a process's valid memory region are prohibited when executing in user mode.\n3. **Timer Interrupts**: The kermnel must have a way to periodically regain control from the current process, regardless of what the process does.\n\n### Privileged Instructions\nInstructions that are available in kernel mode, but not in user mode, are called **privileged instructions**. The followings are examples of privileged instructions.\n\n- Changing the set of memory locations an application can access\n- Disabling processor interrupts\n- Changing an application's prvilige level\n- Jumping into kernel code\n\nIf an application attempts to execute an instruction that is prvileged, **processor exception** is caused. This causes the processor to transfer control to an **exception handler** in the operating system kernel.\n\nHowever, in some cases, applications must execute a privileged instruction. In such cases, applications are allowed to use a special instruction called **system call**. Processes can indirectly change their privilege level by executing a system call to transfer control into the kernel at a fixed location defined by the operating system.\n\n### Memory Protection\nTo make memory sharing safe, an application must be prevented from reading/writing other applications' memory. Most modern processors introduce **virtual memory** to accomplish this.\n\nWith virtual memory, every process's memory starts at the same location (e.g., zero). The hardware translates these virtual addresses into physical memory locations. At runtime, **memory-management unit (MMU)** relocates each `load`/`store` instructions; if the given virtual address is illegal, MMU raises a **segmentation fault**.\n\n### Timer Interrupts\nIf the user program enters an infinite loop (process monopolising CPU), or if the user simply becomes impatient and wants the system to stop the application, then the operating system must be able to regain control from applications. Operating system also needs to regain control of the processor in normal operations for multi-tasking.\n\nA physical timer included in the computer system delivers a hardware signal (interrupt) to the processor with a predefined frequency set by the kernel. (Each timer interrupts only one processor.) When the timer interrupt occurs, the hardware transfers from the user process to the kernel (interrupt handler) running in kernel mode.\n\n However, interrupts can be temporarily deferred by the kernel. This is crucial for the implementation of [mutual exclusion].","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/E-R-design-issues":{"title":"E-R design issues","content":"\nThe notions of an [[notes/Entity set|entity set]] and a [[notes/Relationship set|relationship set]] are not precise, and it is possible to define a set of entities and the relationships among them in a number of different ways.\n\n## Common mistakes in E-R models\n\n- Use of a primary key of an entity set as an attribute of another entity set.\n\n![er-mistake-example-1](notes/images/er-mistake-example-1.png)\n\n- Use of a relationship with a single-valued attribute in a situation that requires a [[notes/Attribute(E-R)|multivalued attribute]].\n\n![er-mistake-example-2](notes/images/er-mistake-example-2.png)\n\n- Possible solutions:\n  - Use a [[notes/Primary key(E-R)#Weak entity sets|weak entity set]].\n  - Use a multivalued composite attribute.\n\n![er-mistake-2-correction](notes/images/er-mistake-2-correction.png)\n\n## Use of entity sets versus attributes\n\nConsider the entity set `instructor` with the additional attribute `phone-number`. There are two possible ways to model this as an E-R model:\n\n- `phone-number` is an attribute of an entity `instructor`.\n- `phone` is an entity in its own right with attributes `phone-number`.\n\n![entity-set-vs-attribute](notes/images/entity-set-vs-attribute.png)\n\nThe main difference is that treating a `phone` as an entity better models a\nsituation where one may want to keep **extra information** about a `phone`, possibly multiple `phone-number`s per `instructor`.\n\n## Use of entity sets versus relationship sets\n\nConsider the entity sets `section` and `student`, and the relationship between them indicating the section(s) that a student takes. There are two possible ways to model this as an E-R model:\n\n- As a relationship set `takes`\n- As an entity set `registration`, and two relationship sets between `registration` and `section`, `student`\n\n![relationship-set-vs-entity-set-1](notes/images/relationship-set-vs-entity-set-1.png)\n\n![relationship-set-vs-entity-set-2](notes/images/relationship-set-vs-entity-set-2.png)\n\nA possible guideline is to designate a relationship set to describe an **action** that occurs between entities.\n\n## Binary versus nonbinary relationships\n\nAlthough it is possible to replace any nonbinary ($n$-ary, $n \u003e 2$) relationship set by a number of distinct binary relationship sets, a $n$-ary relationship sets shows more clearly that several entities participate in a single relationship.\n\nHowever, some relationships that appear to be nonbinary may be better represented using binary relationships.\n\n### Converting nonbinary relationships\n\nIn general, any nonbinary relationship can be represented using binary relationships by creating an artificial entity set, and creating an identifying attribute for the artificial entity set to other entity sets participating in the relationship.\n\n![n-ary-to-binary-relationships](notes/images/n-ary-to-binary-relationships.png)\n\nHowever, this restriction is not always desirable.\n\n- Such restrictions increases the complexity of the design and the overall storage requirements.\n- An $n$-ary relationship set shows more clearly that several entities participate in a single relationship.\n- **Translating all constraints may not be possible**.\n- There may be instances in the translated schema that **cannot correspond to any** instance of the original relationship.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/E-R-diagram":{"title":"E-R diagram","content":"\n## Basic structure\n\nAn E-R diagram consists of the following major components:\n\n- **Rectangles divided into two parts**: Represent entity sets. The first part contains the name of the entity set. The second part contains the names of all the attributes of the entity set.\n\n- **Diamonds**: Represent relationship sets.\n\n- **Undivided rectangles**: Represent the attributes of a relationship set. Attributes that are part of the primary key are underlined.\n\n- **Lines**: Link entity sets to relationship sets.\n\n- **Dashed lines**: Link attributes of a relationship set to the relationship set.\n\n- **Double lines**: Indicate [[notes/Constraint(E-R)#Participation constraints|total participation]] of an entity in a relationship set.\n\n- **Double diamonds**: Represent identifying relationship sets linked to weak entity sets.\n\n![er-diagram-basics](notes/images/er-diagram-basics.png)\n\n## [[notes/Constraint(E-R)#Mapping cardinality|Mapping Cardinality]]\n\nTo distinguish among different mapping cardinalities, either a directed line $(\\rightarrow)$, signifying '**one**', or an undirected line $(-)$, signifying '**many**', is drawn between the relationship set and the entity set.\n\n![er-diagram-mapping-cardinality](notes/images/er-diagram-mapping-cardinality.png)\n\nE-R diagrams also provide a way to indicate more complex constraints on the number of times each entity participates in relationships in a relationship set.\n\nA line may have an associated minimum and maximum cardinality, shown in the form $l..h$, where $l$ is the minimum and $h$ is the maximum capacity. The $*$ sign indicates 'no limit'.\n\n![er-diagram-complex-cardinality](notes/images/er-diagram-complex-cardinality.png)\n\n## [[notes/Attribute(E-R)|Complex attributes]]\n\nE-R diagrams can also describe complex attributes.\n\n**Composite attributes** and **component attributes** are distinguished with indentations. Component attributes that consists the composite attributes are given directly below the composite attribute with an indentation.\n\n**Multivalued attributes** are written inside curly braces $( \\lbrace \\cdots \\rbrace )$.\n\n**Derived attributes** are written with an additional parentheses at the end.\n\n![er-diagram-complex-attributes](notes/images/er-diagram-complex-attributes.png)\n\n## [[notes/Relationship set|Roles]]\n\nRoles are indicated in E-R diagrams by labeling the lines that connect diamonds to rectangles.\n\n![er-diagram-roles](notes/images/er-diagram-roles.png)\n\n## [[notes/Relationship set#Nonbinary relationship sets|Nonbinary relationship sets]]\n\n_At most_ one arrow out of a ternery (or greater degree) relationship is allowed to indicate a cardinality constraint.\n\nIf there are more than arrow, there are two ways of interpreting the meaning. Suppose that there is a relationship set $R$ between entity sets $A_1, \\cdots, A_n$, and the only arrows are on the edges to entity sets $A_{i+1}, A_{i+2}, \\cdots, A_n$.\n- A particular _combination_ of entities from $A_1, \\cdots, A_i$ can be associated with at most one _combination_ of entities from $A_{i+1}, \\cdots, A_n$.\n  - i.e., the primary key for the relationship $R$ can be constructed by the union of the primary keys of $A_1, \\cdots, A_i$.\n- For each entity set $A_k (i \u003c k \\leq n)$, each combination of the entities from the other entity sets can be associated with at most one entity from $A_k$.\n  - i.e., Each set $\\lbrace A_1, \\cdots, A_{k-1}, A_{k+1}, \\cdots, A_n \\rbrace$, for $i \u003c k \\leq n$, forms a candidate key.\n\n[[notes/Functional dependency|Functional dependencies]] allow either of these interpretations to be specified in an unambiguous manner.\n\n## [[notes/Primary key(E-R)#Weak entity sets|Weak entity sets]]\n\nIn E-R diagrams, a weak entity set is depicted via a rectangle, like a strong entity set, but there are two main differences:\n- The discriminator of a weak entity is underlined with a **dashed line**.\n- The relationship set connecting the weak entity set to the identifying entity set is depicted by a **double diamond**.\n\n![er-diagram-weak-entity-set](notes/images/er-diagram-weak-entity-set.png)\n\n## Specialisation\n\n- [[notes/Extended E-R features#Specialisation|Specialisation]] is depicted by a **hollow arrow-head** pointing from the specialised entity to the other entity.\n- This relationship is referred to as the ISA relationship, which stands for 'is a'.\n  - e.g., `instructor` 'is a' `employee`.\n- For **overlapping specialisation**, **two separate arrows** are used.\n- For **disjoint specialisation**, a **single arrow** is used.\n\n![er-diagram-specialisation](notes/images/er-diagram-specialisation.png)\n\n### Completeness constraint\n\n- [[notes/Extended E-R features#Completeness constraint|Total generalisation]] is specified in an E-R diagram by **adding the keyword** 'total' in the diagram and drawing a **dashed line** from the keyword to the corresponding hollow arrow-head(s).\n\n![er-diagram-total-generalisation](notes/images/er-diagram-total-generalisation.png)\n\n## Aggregation\n- [[notes/Extended E-R features#Aggregation|Aggregation]] is specified by drawing a **rectangular box** around the relationships treated as a higher-level entity.\n  \n![er-diagram-aggregation](notes/images/er-diagram-aggregation.png)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/E-R-model":{"title":"E-R model","content":"\nThe **entity-relationship(E-R)** data model models an enterprise as a collection of entities and relationships that represents the overall logical structure of a database.\n\nThe E-R data model employs three basic components:\n- [[Entity set]]\n- [[Relationship set]]\n- [[Attribute(E-R)]]\n\nThe E-R model also has an associated diagrammatic representation called the **E-R diagram**, which can express the overall logical structure of a database graphically.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Entity-set":{"title":"Entity sets","content":"\n\nAn **entity** is an object that exists and is distinguishable from other objects.\n\nAn **entity set** is a set of entities of the same type that share the same properties.\n\nAn entity is represented by a set of **[[Attribute(E-R)|attributes]]**, and each entity has a **value** for each of its attributes.\n\n![entity-set-examples](/notes/images/entity-set-examples.png)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Extended-E-R-features":{"title":"Extended E-R features","content":"\r\n## Specialisation\r\n\r\nAn [[notes/Entity set|entity set]] may include subgrouping of entities that are distinct in some way from other entities in the set. The process of designating subgroups within an entity set is called **specialisation**.\r\n\r\nThese subgroupings become _lower-level entity sets_ that have attributes or participate in relationships that do not apply to the higher-level entity set.\r\n\r\n## Generalisation\r\n\r\n**Generalisation** is a containment relationship that exists between a higher-level entity set and one or more lower-level entity sets. This is a **bottom-up** design process, in which multiple entity sets are synthesised into a higher-level entity set on the basis of _common features_.\r\n\r\nThe terms specialisation and generalisation are used interchangeably.\r\n\r\n## Attribute inheritance\r\n\r\nA lower-level entity set inherits all the attributes and relationship participation of the higher-level entity set to which it is linked. This is called **attribute inheritance**.\r\n\r\nLower- and higher-level entity sets are also referred to as **subclasses** and **superclasses**, respectively.\r\n\r\n## Constraints on specialisations/generalisations\r\n\r\nTo model an enterprise more accurately, the database designer may choose to place\r\ncertain constraints on a particular generalisation/specialisation.\r\n\r\n### Disjoint/Overlapping specialisation\r\n\r\nOne type of constraint on specialisation specifies whether a specialisation is **disjoint** or **overlapping**.\r\n\r\n- **Disjoint**\\\r\n    A _disjoint constraint_ requires that an entity belong to no more than one lower-level entity set.\r\n\r\n- **Overlapping**\\\r\n    An _overlapping constraint_ requires that an entity may belong to more than one lower-level entity sets within a single specialisation.\r\n    \r\n\r\n### Completeness constraint\r\n\r\nThe **completeness constraint** specifies whether or not an entity in the higher-level entity set must belong to at least one of the lower-level entity sets within the generalisation.\r\n\r\n- **Total**\\\r\n    Each higher-level entity _must_ belong to a lower-level entity set.\r\n\r\n- **Partial**\\\r\n    Some higher-level entities may _not_ belong to any lower-level entity set.\r\n\r\nPartial generalisation is the default.\r\n\r\n## Aggregation\r\n\r\n**Aggregation** is an abstraction through which relationships are treated as higher-level entities. By treating relationship as an abstract entity, relationships between relationships can be defined, thereby reducing unnecessary redundancy.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Field":{"title":"Field","content":"\n## Definition\nA field $F$ is a set on which two operations $+$ (_addition_) and $\\cdot$ (_multiplication_) are defined so that the followings hold.\n\nFor any $x, y, z \\in F$,\n\u003e **(A1)** $x + y = y + x$  „ÄÄ(Commutativity of addition)\n\u003e \n\u003e **(A2)** $(x + y) + z = x + (y + z)$ „ÄÄ(Associativity of addition)\n\u003e\n\u003e **(A3)** $\\exists ! 0 \\in F$ such that  $\\forall x \\in F: x + 0 = x$ „ÄÄ(Existence of additive identity)\n\u003e \n\u003e **(A4)** $\\forall x \\in F: \\exists ! (-x) \\in F$ such that $x + (-x) = 0$ „ÄÄ(Existence of additive inverse)\n\u003e \n\u003e **(M1)** $xy = yx$ „ÄÄ(Commutativity of multiplication)\n\u003e \n\u003e **(M2)** $(xy)z = x(yz)$ „ÄÄ(Associativity of multiplication)\n\u003e\n\u003e **(M3)** $\\exists ! 1 \\in F$ such that $\\forall x \\in F: 1x = x$ „ÄÄ(Existence of multiplicative identity)\n\u003e \n\u003e **(M4)**  $\\forall x \\in F \\setminus \\lbrace 0 \\rbrace: \\exists ! x^{-1} \\in F$ such that $xx^{-1} = 1$ „ÄÄ(Existence of multiplicative inverse)\n\u003e \n\u003e **(D)** $x(y + z) = xy + xz$ „ÄÄ(Distributivity of multiplication over addition)\n\n\n## Examples\n- The set of rational numbers $(\\mathbb{Q})$, real numbers $(\\mathbb{R})$, and complex numbers $(\\mathbb{C})$ are fields.\n- The set $B = \\lbrace 0, 1 \\rbrace$ with boolean addition / multiplication is a field.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Fourth-normal-form":{"title":"Fourth normal form","content":"\n## Definition\n\nLet $R$ be a relation schema, and $D$ be a set of [[notes/Functional dependency|functional]] and [[notes/Multivalued dependency|multivalued dependencies]] of $R$. Let $D^+$ be the [[notes/Closure(Database)#Closure of multivalued dependencies|closure]] of $D$.\n\nThen, $R$ is said to be in **fourth normal form(4NF)** if, for all multivalued dependencies $\\alpha \\twoheadrightarrow \\beta \\in D^+$, at least one of the followings hold:\n- $\\alpha \\twoheadrightarrow \\beta$ is trivial. (i.e., $\\beta \\subseteq \\alpha$, or $\\alpha \\cup \\beta = R$)\n- $\\alpha$ is a [[notes/Keys|superkey]] of $R$. (i.e., $\\alpha \\to R$)\n\n## Decomposition into 4NF\n\n![4nf-decompose-algorithm](notes/images/4nf-decompose-algorithm.png)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Functional-dependency":{"title":"Functional dependency","content":"\nThere are usually a variety of constraints on the data in the real world.\n\nAn instance of a relation that satisfies all such real-world constraints is called a **legal instance** of the relation; a legal instance of a database is one where all the relation instances are legal instances.\n\nSome of the most commonly used types of real-world constraints can be represented formally as [[notes/Keys|keys]] (superkeys, candidate keys, and primary keys), or as **functional dependencies**.\n\n## Definition\n\nConsider a relation schema $r(R)$, and let $\\alpha, \\beta \\subseteq R$ be sets of attributes.\n\nGiven an instance of $r(R)$, the instance is said to satisfy a **functional dependency** $\\alpha \\to \\beta$ if for all pairs of tuples $t_1$ and $t_2$ in the instance, \n$$\nt_1[\\alpha] = t_2[\\alpha] \\Rightarrow t_1[\\beta] = t_2[\\beta].\n$$\n\nThe functional dependency $\\alpha \\to \\beta$ is said to **hold** on schema $r(R)$ if every legal instance of $r(R)$ satisfies the functional dependency.\n\nOne easy way to understand the concept of functional dependency is to interpret $\\alpha \\to \\beta$ as: \n\u003e If values of $\\alpha$ is given, then values of $\\beta$ is _uniquely_ determined.\n\n## Trivial functional dependencies\n\nA functional dependency is **trivial** if it is satisfied by all instances of a relation.\n\nIn general, $\\alpha \\to \\beta$ is trivial if $\\beta \\subseteq \\alpha$.\n\n## Keys and functional dependencies\n\n- $K$ is a superkey for relational schema $r(R)$ if and only if the functional dependency $K \\to R$ holds on $r(R)$.\n- $K$ is a candidate key for $r(R)$ if and only if the functional dependency $K \\to R$ holds on $r(R)$, and for any $L \\subsetneq K$, $L \\not\\to R$.\n\n## Use of functional dependencies\n\nFunctional dependencies can be used to:\n- Test relations to see if they are legal inder a given set of functional dependencies\n- Specify constraints on the set of legal relations\n\nNote that a specific instance of a relation schema may satisfy a functional dependency even if the functional dependency **does not** hold on all legal instances.\n- e.g., A specific instance of `instructor` may, **by chance**, satisfy $\\texttt{name} \\to \\texttt{ID}$","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Fundamental-theorem-of-linear-algebra":{"title":"Fundamental theorem of linear algebra","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Group":{"title":"Group","content":"\r\n## Definition\r\nA **group** is an ordered pair $(G, \\cdot)$ where $G$ is a set and $\\cdot$ is a binary operation on $G$ satisfying the following axioms:\r\n\r\nFor any $x, y, z \\in G$:\r\n\u003e**(1)** $(x\\cdot y)\\cdot z = x\\cdot (y\\cdot z) \\quad$ (Associativity)\r\n\u003e\r\n\u003e**(2)** $\\exist e \\in G$ such that $\\forall x \\in G: x\\cdot e = e \\cdot x = x \\quad$ (Existence of identity element)\r\n\u003e\r\n\u003e**(3)** $\\forall x \\in G: \\exists ! x^{-1} \\in V$ such that $x\\cdot x^{-1} = x^{-1}\\cdot x = e \\quad$ (Existence of inverse element)\r\n\r\nFurthermore, $(G, \\cdot)$ is called **Abelian** if the following holds:\r\n\u003e**(A)** $x\\cdot y = y \\cdot x \\quad$ (Commutativity)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/H%C3%B6lders-inequality":{"title":"H√∂lder's Inequality","content":"### Theorem\nFor any vectors $\\mathbf{x},\\mathbf{y} \\in \\mathbb{R}^n$ and for any $p,q \\geq 1$ such that $\\frac{1}{p} + \\frac{1}{q} = 1$, it holds that\n$$\n|\\mathbf{x}^\\top\\mathbf{y}| \\leq \\sum\\limits_{i=1}^n|x_iy_i| \\leq \\|\\mathbf{x}\\|_p\\|\\mathbf{y}\\|_q.\n$$\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Implementation-of-mode-transfer":{"title":"Implementation of mode transfer","content":"\n## Importance\nThe context switch ([mode transfer](notes/Mode%20transfer.md)) must be carefully crafted, and it relies on _hardware support_. To avoid confusion and reduce the possibility of error, m most operating systems have a common sequence of instructions both for entering the kernel and for returning to user level, regardeless of te cause.\n\nAt a minimum, this common sequence must provide the followings.\n\n- **Limited entry into the kernel**: User programs cannot be allowed to jump to arbitrary locations in the kernel.\n- **Atomic changes to processor state**: Transitioning between kernel and user mode is [atomic](notes/Atomic%20operation.md); _the mode, program counter, stack and memory protection_ are all changed _\u003cu\u003eat the same time\u003c/u\u003e (with a single instruction).\n-  **Transparent, restatable execution**: The operating system must be able to restore the state of the user program exactly as it was before the context switch.\n\n## Interrupt Vector\nWhen an interrupt, processor exception or system call trap occurs, the operating system must take different actions depending on what the event is. To this end, the processor has a special register that points to an area of kernel memory called the **interrupt vector table** set up by the kernel.\n\nThe interrupt vector table is an array of pointers, with each entry pointing to the first instruction of a different handler procedure in the kernel. An **interrupt handler** is the term used for the procedure called by kernel on an interrupt.\n\n![interrupt-vector-table](/notes/images/interrupt-vector-table.png)\n\n## Interrupt Stack\n**Interrupt stack** is a region of _kernel_ memory pointed by a special, privileged register. When an interrupt, processor exception, or system call trap causes a context switch into the kernel, the hardware changes the stack pointer to point to the base of the kernel's interrupt stack. The _hardware_ automatically saves some of the interrupted process's registers by pushing them onto the interrupt stack before calling the kernel's handler.\n\nWhen the kernel handler handler runs, it pushes any remaining registers onto the stack before pereforming its work. When returning from the interrupt, processor exception or system call trap, the reverse occurs. The handler pops the saved registers and the hardware restores the registers it saved, returning back to the point where the processor was interrupted. When returning from a system call, the value of the saved program counter _must be incremented_.\n\nOn a multiprocessor, each processor needs to have its own interrupt stack so that the kernel can handle simultaneous system calls and exceptions aacross multiple processors.\n\n### Two Stacks per Process\nMost operating system kernels go one step further and allocate a kernel interrupt stack for every user-level process. This makes it easier to switch to a new process inside an interrupt or system call handler.\n\n![interrupt-stack](/notes/images/interrupt-stack.png)\n\n- If the process is running on the processor in user mode, its kernel stack is empty.\n- If the process is running on the processor in kernel mode (regardless of cause), its kernel stack is in use, containing the saved registers from the suspended user-level computations and the current state of the kernel handler.\n- If the process is available to run but is waiting on the processorm its kernel stack contains the registers and state to be restored when the process is resumed.\n- If the process is waiting for an I/O event to complete, its kernel stack contains the suspended computation to be resumed when the I/O finishes.\n\n## Interrupt Masking\nIn certain regions of the kernel such as interrupt handlers or a scheduler, taking an interrupt could cause confusion. In such cases, the hardware provides a _privileged instruction_ to temporarily defer the delivery of an interrupt until it is safe to do so.\n\nIf multiple interrupts arrive while interrupts are disabled, the hardware delivers them in turn when interrupts are re-enabled. However, due to the limited buffering of hardwares, some interrupts may be lost.\n\nIf the processor takes an interrupt in kernel mode with interrupts enabled, it is safe to use the current stack pointer rather than resetting it to the base of the interrupt stack.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Inner-product":{"title":"Inner product","content":"\n## Definition\nAn inner product on a [vector space](notes/Vector%20space.md) $V$ over a [field](notes/Field.md) is a function $\\langle \\cdot,\\cdot\\rangle:V^2 \\to F$ that satisfies the followings:\n\nFor arbitrary $\\mathbf{x}, \\mathbf{y}, \\mathbf{z} \\in V$ and $c \\in \\mathbb{R}$,\n\u003e **(1)** $\\langle a\\mathbf{x}+\\mathbf{y},\\mathbf{z}\\rangle = a\\langle \\mathbf{x},\\mathbf{z}\\rangle + \\langle \\mathbf{y},\\mathbf{z}\\rangle$ „ÄÄ(Linearity for the first argument)\n\u003e\n\u003e **(2)** $\\langle \\mathbf{x},\\mathbf{y}\\rangle = \\overline{\\langle \\mathbf{y},\\mathbf{x}\\rangle}$ „ÄÄ(Conjugate symmetry)\n\u003e\n\u003e **(3)**  $\\langle \\mathbf{x},\\mathbf{x}\\rangle \\geq 0;$ $\\langle\\mathbf{x},\\mathbf{x}\\rangle = 0$ if and only if $\\mathbf{x}=\\mathbf{0}$ „ÄÄ(Positive semidefiniteness)\n\n## Examples\n### Standard inner product\n#### Definition\nA standard inner space in $\\mathbb{R}^n$ is defined for $\\mathbf{x} = (x_1, \\cdots, x_n)$ and $\\mathbf{y} = (y_1, \\cdots, y_n)$ as\n$$\n\\langle\\mathbf{x},\\mathbf{y}\\rangle = \\mathbf{x}^\\top\\mathbf{y} = \\sum\\limits_{i=1}^n x_iy_i.\n$$\nNote that for the Euclidean [norm](notes/Norm.md),\n$$\n\\lVert \\mathbf{x} \\rVert_2 = \\sqrt{\\langle\\mathbf{x},\\mathbf{x}\\rangle}.\n$$\n\n#### Angle between vectors\nThe standard inner product on $\\mathbb{R}^n$ is related to the angle between two vectors $\\mathbf{x}, \\mathbf{y}$. Let $\\theta$ be the angle between the two vectors and let $\\mathbf{z}=\\mathbf{x}-\\mathbf{y}$.\nThen, applying the second law of cosine gives\n$$\n\\lVert \\mathbf{z} \\rVert_2^2 = \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\lVert \\mathbf{x} \\rVert_2\\lVert \\mathbf{y}\\rVert_2\\cos\\theta.\n$$\nNow substitute $\\mathbf{z}=\\mathbf{x}-\\mathbf{y}$.\n\n$$\\begin{align*}\n\\lVert \\mathbf{x}-\\mathbf{y} \\rVert_2^2 \u0026= (\\mathbf{x}-\\mathbf{y})^\\top(\\mathbf{x}-\\mathbf{y}) \\\\\n\u0026= \\mathbf{x}^\\top \\mathbf{x} + \\mathbf{y}^\\top\\mathbf{y} -2\\mathbf{x}^\\top\\mathbf{y} \\\\\n\u0026= \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\mathbf{x}^\\top\\mathbf{y} \\\\\n\u0026= \\lVert \\mathbf{x} \\rVert_2^2 + \\lVert \\mathbf{y} \\rVert_2^2 -2\\lVert \\mathbf{x} \\rVert_2 \\lVert \\mathbf{y} \\rVert_2\\cos\\theta\n\\end{align*}$$\n\nHence,\n$$\n\\cos\\theta = \\dfrac{\\mathbf{x}^\\top\\mathbf{y}}{\\lVert \\mathbf{x} \\rVert_2 \\lVert \\mathbf{y} \\rVert_2}.\n$$","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Integrity-constraints":{"title":"Integrity constraints","content":"\n**Integrity constrains** ensure that changes made to the database by authorised users do not result in a loss of data consistency. Thus, integrity constraints guard against accidental damage to the database.\n\n## Constraints on a single relation\nThere are some integrity-constraint statements allowed to be included in the `CREATE TABLE` command:\n- `NOT NULL`\n- `PRIMARY KEY`\n- `UNIQUE`\n- `CHECK(\u003cpredicate\u003e)`\n\n### `NOT NULL` constraint\nThe [[notes/Null values in SQL | `NULL` value]] is a member of all domains, hence is a legal value for every attribute in SQL by default.\n\nHowever, for certain attributes, `NULL` values may be inappropriate.\n\nThe `NOT NULL` specification prohibits the insertion of a `NULL` value for the attribute.\n```sql\nA D NOT NULL\n```\n- `A`: Attribute\n- `D`: Domain\n\n### `UNIQUE` constraint\nThe `UNIQUE` specification states that the attributes specified form a candidate key.\n```sql\nUNIQUE(A_1, ... , A_n)\n```\n- `A_i`: Attributes\n\nAttributes $(A_1, \\cdots, A_n)$ form a candidate key; that is, no two tuples can be equal on all the listed attributes.\n\nCandidates keys are permitted to be `NULL` (unless explicitly declared to be `NOT NULL`), in contrast to primary keys.\n\n### `CHECK` clause\nThe `CHECK` clause specifies a predicate `P` that **must** be satisfied by every tuple in a relation.\n\n**Example**\n- Ensure that `semester` is one of 'Autumn', 'Winter', 'Spring', or 'Summer'\n```sql\nCREATE TABLE section\n(\n    ...\n    semester    VARCHAR(6),\n    ...\n    CHECK(semester IN ('Autumn', 'Winter', 'Spring', 'Summer'))\n)\n```\n\n### Complex `CHECK` conditions\nThe predicate in the `CHECK` clause can be an arbitrary predicate that can include a subquery.\n\n**Example**\n```sql\nCHECK\n(\n    time_slot_id IN\n    (\n        SELECT  time_slot_id\n        FROM    time_slot\n    )\n)\n```\nThe condition must be checked not only when a tuple is inserted or modified in `section`, but also when the relation `time_slot` changes.\n\n## Referential integrity\n**[[notes/SQL data definition#Integrity Constraints | Referential integrity]]** ensures that a value that appears in one relation for a given set of attributes also appears for a certain set of attributes in another relation.\n\nBy default, a foreign key references the primary key attributes of the referenced table. Non-primary keys can also be referenced by foreign keys, but the attribute **must** have `UNIQUE` constraint specified.\n\nSQL allows a list of attributes of the referenced relation to be specified explicitly:\n```sql\nFOREIGN KEY(A_1, ... , A_k) REFERENCES r(B_1, ... , B_k)\n```\n- `A_i`, `B_i`: Attributes\n- `r`: Referenced relation\n\n### Cascading actions in referential integrity\nWhen a referential integrity constraint is violated, the normal procedure is to reject the action that caused the violation. An alternative in case of `DELETE` or `UPDATE` is to **cascade** actions.\n\n`CASCADE` specification ensures that whenever a referenced key is deleted or updated (depending on the specification), the same operation is _cascaded_ to all the referencing keys.\n\n**Example**\n```sql\nCREATE TABLE course\n(\n    ...\n    dept_name   VARCHAR(20),\n    FOREIGN KEY (dept_name) REFERENCES department\n        ON DELETE CASCADE\n        ON UPDATE CASCADE\n);\n```\nIf a `DELETE` of a tuple in `department` results in this reference integrity constraint being violated, the `DELETE` operation _cascades_ to the `course` relation, deleting the tuple that refers to the department that was deleted. Similar process also happens for `UPDATE`.\n\nThe followings can be used instead of `CASCADE`:\n- `SET NULL`\n  \n  Whenever a tuple of referenced key relation is removed, set the value of **all** tuples of the referencing key with the same value to `NULL`\n\n- `SET DEFAULT`\n  \n  Same as above, but use default value instead of `NULL`\n\n- `NO ACTION`\n  \n  No action is done; referential integrity is violated.\n\n## Integrity constraint violation during a transaction\nIntegrity constraints may be violated temporarily during [[notes/Transactions | transactions]].\n\n**Example**\n```sql\nCREATE TABLE person\n(\n    ID      CHAR(10),\n    name    VARCHAR(40),\n    mother  CHAR(10),\n    father  CHAR(10),\n    PRIMARY KEY (ID),\n    FOREIGN KEY (father) REFERENCES person,\n    FOREIGN KEY (mother) REFERENCES person\n);\n```\nHow can a tuple be inserted without causing constraint violation?\nThere are some ways to do this:\n- Insert `father` and `mother` of a person before inserting that person\n  \n- Set `father` and `mother` to `NULL` initially, and update after inserting all persons\n  - Not possible if `father` and `mother` attributes are declared to be `NOT NULL`\n  \n- Defer constraint checking until the end of the transaction","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Isomorphism":{"title":"Isomorphism","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Join-expressions":{"title":"Join expressions","content":"\n## Natural join\nThe **natural join** operation operates on two relations and produces a relation as a result.\n\nIt matches tuples with the same values for **all common attributes**, and retains only one copy of each common attribute.\n```sql\nr_1 NATURAL JOIN r_2\n```\nUnlike the Cartesian product of two relations, natural join considers only those pairs of tuples with the same value on those attributes that appear on the schema of both relations.\n\nIt is an **equi-join** which occurs **implicitly** by comparing all the same name columns in both relations.\n\n## Join conditions\nTo prevent equating attributes erroneously, SQL supports the specification of the join condition.\n\n### `USING` construct\nThe operation `JOIN ... USING` requires a list of attribute names to be specified.\n```sql\nr_1 JOIN r_2 USING(A_1, ... , A_n)\n```\n- `r_i`: Relation\n- `A_i`: Attribute\n\nThe operation is equivalent to:\n```sql\nSELECT  *\nFROM    r_1,\n        r_2\nWHERE   COALESCE(r_1.A_1, r_2.A_1) AS A_1\nAND     ...\nAND     COALESCE(r_1.A_n, r_2.A_n) AS A_n\n```\n\nIt is an **equi-join**, and causes duplicate attributes to be **removed** from the resultset.\n\n### `ON` construct\nThe `ON` condition allows a general predicate over the relaions being joined.\n\nThis predicate is written like a `WHERE` clause predicate.\n```sql\nr_1 JOIN r_2 ON p\n```\n- `r_i`: Relation\n- `p`: Predicate\nThe operation is equivalent to:\n```sql\nSELECT  *\nFROM    r_1,\n        r_2\nWHERE   p\n```\nIt is a **theta join**, and it allows duplicate attributes to appear in the resultset.\n\n**Example**\n- All attributes about all students, along with all the courses that they have took\n```sql\nSELECT  *\nFROM    student\nJOIN    takes\nON      student.ID = takes.ID\n```\n- Note that the above query has **two** occurrences for the attribute `ID`, and the relation name of origin must be specified to disambiguate the two.\n\n#### Comparison of `ON` and `USING`\nIn a nutshell, `ON` can be used for most joins, but `USING` is a handy shorthand for the situation where _the column names are the same_.\n\nThe following queries are equivalent.\n```sql\nSELECT  I.title, R.name\nFROM    albums I\nINNER JOIN  artists R\nON      R.artist_id = I.artist_id;\n```\n```sql\nSELECT  title, name\nFROM    albums\nINNER JOIN  artists\nUSING(artist_id);\n```\n\n## Outer join\nThe **outer join** is an extension of the join operation that **avoids loss of information**.\n\nIt computes the join operation, and then adds tuples from one relation that does not match tuples in the other relation to the result of the join, using `NULL` values.\n\nThere are three forms of outer join:\n- **`LEFT OUTER JOIN`**\n\n  Preserves tuples only in the relation named to the left of the `LEFT OUTER JOIN` operation.\n- **`RIGHT OUTER JOIN`**\n  \n  Preserves tuples only in the relation named to the right of the `RIGHT OUTER JOIN` operation.\n- **`FULL OUTER JOIN`**\n  \n  Preserves tuples in both relations.\n\n![sql-join-visualisation](/notes/images/sql-join-visualisation.png)\n\nIn constrast, the join operations that do not preserve nonmatched tuples are called `INNER JOIN` operations.\n\n### Outer join with `ON` construct\nFor outer join, `ON` and `WHERE` behave differently. The reason for this is that outer join adds `NULL`-padded tuples only for those tuples that do not contribute to the result of the corresponding inner join.\n\nThe `ON` condition is part of the outer join specification, whilst `WHERE` clause is **not**.\n\n**Example**\n\nSuppose that the relation `student` has a tuple with name `Snow`, which has no corresponding tuples in the `takes` relation.\n\nThe following two queries are **not** equivalent.\n```sql\nSELECT  *\nFROM    student\nLEFT OUTER JOIN takes\nON      student.ID = takes.ID;\nWHERE   student.name = 'Snow'\n-- Result: (70557, 'Snow', 'Physics', 0, NULL, NULL, NULL, NULL, NULL, NULL)\n```\n```sql\nSELECT  *\nFROM    student\nLEFT OUTER JOIN takes\nON      TRUE\nWHERE   student.ID = takes.ID\nAND     student.name = 'Snow'\n-- Result: \n```\nIn the latter query, every tuple satisfies the join condition `TRUE`, hence the outer join actually generates the Cartesian product of the two relations. Since there are no tuples in `takes` with the ID `'70557'`, every time a tuple appears in the outer join with the name `'Snow'`, the values for `student.ID` and `takes.ID` must be different, and such tuples are eliminated by the `WHERE` clause predicate. Thus the resultset is empty.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Keys":{"title":"Keys","content":"\nWe must have a way to specify how tuples within a given relation are distinguished; no two tuples in a relation are allowed to have exactly the same value for all attributes.\n\nLet $K \\subseteq R$, where $R$ is a [[notes/View of data#Instances and schemas | relational schema]] for the relation $r$.\n\n- **Superkey**\n  \n  $K$ is a **superkey** of $R$ if value for $K$ are sufficient to identify a unique tuple of each possible relation instance $r(R)$.\n    - i.e., $\\forall t_1, t_2 \\in R: t_1 \\neq t_2 \\Rightarrow t_1.K \\neq t_2.K$\n  \n- **Candidate key**\n  \n  A superkey $K$ is a **candidate** key if $|K|$ is at its minimum value.\n\n- **Primary key**\n  \n  One of the candidate keys is selected to be the **primary key**.\n    - Usually the most efficient one in terms of computation cost is chosen.\n    - Primary key is chosen by the database designer as the principal means of identifying tuples within a relation.\n    - Also referred to as the **primary key constraint**.\n\nLet $A_i$ be an attribute of relations $r_i$.\n\n- A **foreign-key constraint** from attribute(s) $A_1$ of relation $r_1$ to the primary-key $A_2$ of relation $r_2$ states that on any database instance, the value of $A_1$ for **each** tuple in $r_1$ must also be the value of $A_2$ for **some** tuple in $r_2$.\n    - i.e., $\\forall t_1 \\in R_1: \\exists \\,t_2 \\in R_2$ such that $t_1.A_1 = t_2.A_2$\n\n- Attribute set $A_1$ is called a **foreign key** from $r_1$, referencing $r_2$.\n    - The relation $r_1$ is also called the **referencing relation**; $r_2$ is also called the **referenced relation**.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Linear-algebra":{"title":"Linear algebra","content":"\nLinear algebra is the branch of mathematics concerning linear equations, linear transformations (maps), and their representations in vector spaces and through matrices.\n\n## Vector Space\n- [Field](notes/Field.md)\n- [Vector space](notes/Vector%20space.md)\n\t- [Subspace](notes/Subspace.md)\n- [Linear combination](notes/Linear%20combination.md)\n\t- [Span](notes/Span.md)\n- [Linear independence](notes/Linear%20independence.md)\n- [Basis](notes/Basis.md)\n\t- [Dimension](notes/Dimension.md)\n- [Coordinates](notes/Coordinates.md)\n\n## Linear Transformation\n- [Linear transformation](notes/Linear%20transformation.md)\n- [Isomorphism](notes/Isomorphism.md)\n- [Fundamental theorem of linear algebra](notes/Fundamental%20theorem%20of%20linear%20algebra.md)\n\n## Determinant\n- [Multilinear form](notes/Multilinear%20form.md)\n\t- [Alternating multilinear form](notes/Alternating%20multilinear%20form.md)\n- [Determinant](notes/Determinant.md)\n\t- [Properties of determinant](notes/Properties%20of%20determinant.md)\n- [Cramer's rule](notes/Cramer's%20rule.md)\n\n## Characteristic Polynomial\n\n## Decomposition Theorems\n\n## Inner Product Space\n- [Inner product](notes/Inner%20product.md)","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Linear-combination":{"title":"Linear combination","content":"\n## Definition\nLet $V$ be a vector space over the field $F$.\nLet $S$ be a nonempty subset of $V$.\nA nonempty vector $\\mathbf{v} \\in V$  is called a **linear combination** of vectors of $S$ if there exist a finite number of vectors $\\mathbf{u}_1, \\cdots, \\mathbf{u}_n$ and scalars $a_i, \\cdots, a_n$ such that\n\n$$\\mathbf{v} = \\sum\\limits\\_{i=1}^na\\_i\\mathbf{u}\\_i.$$\n\nThen, $\\mathbf{v}$ is called a linear combination of vectors $\\mathbf{u}\\_1, \\cdots, \\mathbf{u}\\_n$, and call $a\\_i, \\cdots, a\\_n$ the **coefficients** of the linear combination.\n\n## Observations\n### Observation 1\n\u003eIn any vector space $V$, $0\\mathbf{v} = \\mathbf{0}$ for any $\\mathbf{v} \\in V$.\n\u003e\n\u003eThus the zero vector is a linear combination of any nonempty subset of $V$.\n\n## Related Concepts\n- [Span](notes/Span.md): The set of all linear combinations of some set of vectors","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Linear-independence":{"title":"Linear independence","content":"\n## Definition\nA subset $S$ of a vector space $V$ is called **linearly dependent** if\nthere exist a finite number of distinct vectors $\\mathbf{u}_1, \\cdots, \\mathbf{u}_n$ in $S$\nand scalars $a_1, \\cdots, a_n$, _not all zero_, such that\n\n$$\\sum\\limits\\_{i=1}^n a\\_i\\mathbf{u}\\_i = \\mathbf{0}.$$\n\nIn this case we also say that the vectors of $S$ are linearly dependent.\n\nA subset $S$ of a vector space $V$ that is not linearly dependent is called **linearly independent**.\nWe also say that the vectors of $S$ are linearly independent.\n\n## Theorems\n### Theorem 1\n\u003eLet $V$ be a vector space over a field $F$, and let $S_1 \\subseteq S_2 \\subseteq V$.\n\u003e\n\u003eIf $S_1$ is linearly dependent, then $S_2$ is also linearly dependent.\n\n### Proof\nSince $S\\_1$ is linearly dependent, we can choose some vectors $\\def\\v#1{\\mathbf{#1}} \\v{v}\\_1, \\cdots, \\v{v}\\_n$ such that for some scalars $a\\_1, \\cdots, a\\_n$,\n\n$$\n\\def\\v#1{\\mathbf{#1}}\n\\sum\\limits\\_{i = 1}^n a\\_i\\v{v}\\_i = \\v{0}.\n$$\n\nThen, since $S\\_1 \\subseteq S\\_2$, we know that $\\v{v}\\_i \\in S\\_2$ for all $i = 1, \\cdots, n$. Hence by definition the vectors of $S\\_2$ are linearly dependent.\n$$\\tag*{$||$}$$ \n\n### Corollary\n\u003eLet $V$ be a vector space over a field $F$, and let $S_1 \\subseteq S_2 \\subseteq V$.\n\u003e\n\u003eIf $S_2$ is linearly independent, then $S_1$ is also linearly independent.\n\n### Theorem 2\n\u003eLet $S$ be a linearly independent subset of a vector space $V$, \n\u003eand let $\\mathbf{v}$ be a vector in $V$ that is not in $S$.\n\u003e\n\u003eThen $S \\cup \\lbrace \\mathbf{v} \\rbrace$ is linearly dependent \n\u003eif and only if $\\mathbf{v} \\in \\text{span}(S)$.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Linear-transformation":{"title":"Linear transformation","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Lock":{"title":"Lock","content":"\n## Definition\nA **lock** is a synchronisation variable that provides **mutual exclusion** - when one thread holds a lock, no other thread can hold it.\n\n## APIs\nA lock enables mutual exclusion by providing two methods: `Lock::acquire()` and `Lock::release()`. These methods are defined as follows:\n\n- A lock can be in one of two states: `busy` or `free`.\n- A lock is initially in the `free` state.\n- **`Lock::acquire()`**\n\t- The caller thread **waits** until the lock is `free` and then atomically makes the lock `busy`.\n\t- Checking the state of a lock and setting the state to `busy` are, together, an [atomic operation](notes/Atomic%20operation.md).\n\t- Even if multiple threads try to acquire the lock, at most one thread will succeed.\n- **`Lock::release()`** \n\t- This call makes the lock `free`.\n\t- If there are pending `acquire()` operations, this state change causes one of them to proceed.\n\n## Properties\nA lock should ensure the three properties: **mutual exclusion**, **progress**, and **bounded waiting**. Mutual exclusion ensures [safety](notes/Too%20much%20milk%20problem###Safety), while progress and bounded waiting ensures [liveliness](notes/Too%20much%20milk%20problem###Liveliness).\n\n### Mutual Exclusion\nAt most **one** thread can hold the lock.\n\n### Progress\nIf no thread holds the lock and any thread attempts to acquire the lock, then eventually some thread succeeds in acquiring the lock.\n\n### Bounded Waiting\nIf a thread $T$ attempts to acquire a lock, then there exists a bound on the number of times other threads can successfully acquire the lock before $T$ does.\n\n## Rules for Using Locks\n- **Lock is initially free**.\n- **Always acquire lock before accessing shared data.\n- **Always release after finishing with shared data**.\n- **Never access shared data without acquiring lock**.\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/MIPS-Assembly-language":{"title":"MIPS Assembly language","content":"\n## Operands and operations\n### MIPS Operands\n- **Registers**(2^5 = 32):  `$s0-$s7, $t0-$t9, $zero, $a0-$a3, $v0-$v1, $gp, $fp, $sp, $ra, $at`\n- **Memory words** (2^30): `Memory[X]`\n\n### MIPS assembly language\n| **Category**  | **Instruction**       | **Example**         | **Meaning**              |\n| ------------- | --------------------- | ------------------- | ------------------------ |\n| Arithmetic    | Add                   | `add $s1, $s2, $s3` | `$s1 = $s2 + $s3`        |\n|               | Subtraction           | `sub $s1, $s2, $s3` | `$s1 = $s2 - $s3`        |\n|               | Add immediate         | `addi $s1, $s2, 20` | `$s1 = $s2 + 20`         |\n| Data Transfer | Load word             | `lw $s1, 20($s2)`   | `$s1 = Memory[$s2 + 20]` |\n|               | Store word            | `sw $s1, 20($s2)`   | `Memory[$s2 + 20] = $s1` |\n|               | Load half             | `lh`                |                          |\n|               | Load half unsigned    | `lhu`               |                          |\n|               | Store half            | `sh`                |                          |\n|               | Load byte             | `lb`                |                          |\n|               | Load byte unsigned    | `lbu`               |                          |\n|               | Store byte            | `sb`                |                          |\n|               | Load linked word      | `ll`                |                          |\n|               | Store condition. word | `sc`                |                          |\n|               | Load upper immediate  | `lui $s1, 20`       | `$s1 = 20\u003c\u003c16`           |\n| Logical       | AND                   | `and $s1, $s2, $s3` | `$s1 = $s2 \u0026 $s3`        |\n|               | OR                    | `or $s1, $s2, $s3`  | `$s1 = $s2 | $s3`        |\n|               | NOR                   | `nor $s1, $s2, $s3` | `$s1 = ~($s2 | $s3)`     |\n|               |                       |                     |                          |\n","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Machine-learning":{"title":"Machine learning","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Mathematical-logic":{"title":"Mathematical logic","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Mode-transfer":{"title":"Mode transfer","content":"\nThe operating system must provide a way to safely transfer between user mode and kernel mode. \n\n## User to Kernel Mode\nThere are three reasons for the kernel to take control from a user process: **interrupts**, **processor exceptions**, and **system calls**.\n\n### Interrupts\nAn **interrupt** is an asynchronous signal to the processor that some external event has occurred that may require its attention. The followings are examples of interrupts.\n\n- Processor timer\n- I/O requests (keyboard, mouse, network, ...)\n\nA processor checks for whether an interrupt has arrived as it executes and, if so, it completes or stalls any instructions that are in progress. On a multiprocessor, an interrupt is taken on only one of the processors. Each different type of interrupt requires its own **interrupt handler**.\n\n### Processor Exceptions\nA **processor exception** is a hadware event caused by (unexpected or malicious) user program behaviour that causes a transfer of control to the kernel. The followings are examples of processor exceptions.\n\n- Performing privileged instruction\n- Accessing memory outside accessible memory region (Segmentation fault)\n- Dividing by zero\n- Writing to read-only memory\n- Accessing a word of memory with a non-aligned address\n- Setting a breakpoint in a program\n\nOn a multiprocessor, the exception only stops execution on the processor triggering the exception. The kernel then needs to send interprocessor interrupts to stop execution of the parallel program on other processors.\n\n### System Calls\nUser programs can voluntarily transition into the operating system kernel that the kernel perform an operation on the user's behalf. A **system call** is any procedure provided by the kernel that can be called from user level. The followings are examples of system calls.\n\n- System call to send/receive packets over the network\n- System call to create/delete files\n- System call to read/write data into files\n- System call to create new user process\n\nTo protect the kernel from misbehaving user programs, it is essential that the hardware transfers control on a ststem call to a _pre-defined_ address. Even with system calls, user processes cannot be allowed to jump to arbitrary places in the kernel.\n\n## Kernel to User Mode\n### New Process\nTo start a new process, the kernel copies the program into memorym, sets the program counter to the first instruction of the process, sets the stack pointer to the base of the user stack, and switches to user mode.\n\n### Resume After an Interrupt, Processor Exception, or System Call\nWhen the kernel finishes handling th erequest, it resumes the execution of the interrupted process by restoring its program counter, restoring its registers, and changing the mode back to user level.\n\n### Switch to Different Process\nThe kernel save the process state of the old process in the process's control block. The kernel can then resume a different process by loading its state from the process's control block into the processor and then switching to user mode.\n\n### User-level Upcall\nMany operating systems provide user programs with the ability to receive any asynchronous notification or events.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Modification-of-the-database":{"title":"Modification of the database","content":"\n## Deletion\nA delete request can only delete whole tuples; deleting values on only particular attributes is not allowed.\n```sql\nDELETE FROM r\nWHERE       p\n```\n- `r`: Relation\n- `p`: Predicate\n\nThe `DELETE` statement first finds all tuples `t` in `r` for which `P(t)` is true, and then deletes them from `r`.\\\nNote that `DELETE` command operates on only one relation.\n\n**Examples**\n- Delete all tuples from `instructor` table\n```sql\nDELETE FROM instructor;\n```\n- Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building\n```sql\nDELETE FROM instructor\nWHERE       dept_name IN\n(\n    SELECT  dept_name\n    FROM    department\n    WHERE   building = 'Watson'\n);\n```\n- Delete all instructors whose salary is less than the average salary of all instructors\n```sql\nDELETE FROM instructor\nWHERE       salary \u003c\n(\n    SELECT  AVG(salary)\n    FROM    instructor\n);\n```\nSQL first computes the average salary and find all tuples to delete, then delete all corresponding tuples from the relation (**without** recomputing or retesting the tuples).\n\n## Insertion\nTo insert data into a relation, either a tuple to be inserted, or the query whose result is a set of tuples to be inserted, must be specified.\n```sql\nINSERT INTO r\n```\n- `r`: Relation\n\n**Examples**\n- Insert a new tuple to `course`\n```sql\nINSERT INTO course\n    VALUES('CS360', 'Introduction to Database', 'SoC', 3)\n```\n- Make each student in the Music department who has earned more than 144 credit as an instructor in the Music department with a salary of 18000\n```sql\nINSERT INTO instructor\n(\n    SELECT  ID,\n            name,\n            dept_name,\n            18000\n    FROM    student\n    WHERE   dept_name = 'MUSIC'\n            AND tot_credit \u003e 144\n); \n```\nThe `SELECT` - `FROM` - `WHERE` statement is **evaluated fully before** any of its results are inserted into the relation.\n\n## Update\nA value in a tuple can be changed without changing _all_ values in the tuple with the `UPDATE` statement.\n```sql\nUPDATE  r\nSET     A = (Some Value)\nWHERE   p\n```\n- `r`: Relation\n- `A`: Attribute\n- `p`: Predicate\n\n**Examples**\n- Give a 5% salary raise to those instructors who earn less than 70000\n```sql\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c 70000;\n```\n- Give a 5% salary raise to instructors whose salary is less than the average of all instructors\n```sql\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c\n(\n    SELECT  AVG(salary)\n    FROM    instructor\n);\n```\nNote that the order of `UPDATE` statements is very important.\\\nConsider the following query.\n```sql\n-- Update 1\nUPDATE  instructor\nSET     salary = salary * 1.03\nWHERE   salary \u003e 100000\n-- Update 2\nUPDATE  instructor\nSET     salary = salary * 1.05\nWHERE   salary \u003c= 100000\n```\nIf the order of the two updates are changed, the results whould not be as desired.\\\nTo prevent order related problems, `CASE` construct is provided by SQL.\n\n### `CASE` construct\n`CASE` construct can be used in any place where a value is expected.\n```sql\nCASE\n    WHEN  P_1 THEN  R_1\n    ...\n    WHEN  P_n THEN  R_n\n    ELSE            R_0\nEND\n```\n- `P_i`: Predicates\n- `R_i`: Resulting value\n  \nThe error-prone query above can be re-written using `CASE` construct.\n```sql\nUPDATE  instructor\nSET     salary =\n(\n    CASE\n        WHEN salary \u003c= 100000 THEN salary * 1.05\n        ELSE salary * 1.03\n    END\n);\n```\n### Updates with scalar subqueries\nScalar subqueries are also useful in SQL update statements, where they can be used in `SET` clause.\n\n**Example**\n- Recompute and update `tot_credit` for all students to the credits of courses successfully completed by the student (successfully completed means `grade` is not `F` nor `NULL`)\n```sql\nUPDATE  student S\nSET     tot_credit =\n(\n    SELECT  SUM(credits)\n    FROM    takes JOIN course USING(course_id)\n    WHERE   S.ID = takes.ID AND\n            (\n                takes.grade \u003c\u003e 'F' AND\n                takes.grade IS NOT NULL\n            )\n);\n```","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Multilinear-form":{"title":"Multilinear form","content":"","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Multivalued-dependency":{"title":"Multivalued dependency","content":"\n[[notes/Functional dependency|Functional dependencies]] rule out certain tuples from being in a relation. **Multivalued dependency**, however, do not rule out the existence of certain tuples; instead, they require that other tuples of a certain form be _present_ in the relation.\n\n## Definition\n\nLet $R$ be a relation schema and let $\\alpha, \\beta \\subseteq R$.\n\nThe **multivalued dependency** $\\alpha \\twoheadrightarrow \\beta$ ($\\alpha$ **multidetermines** $\\beta$) holds on $R$ if in any legal relation $r(R)$, for all pairs of tuples $t_1, t_2 \\in R$ such that $t_1[\\alpha] = t_2[\\alpha]$, there exists tuples $t_3, t_4 \\in R$ that satisfies all of the followings:\n- $t_1[\\alpha] = t_2[\\alpha] = t_3[\\alpha] = t_4[\\alpha]$\n- $t_3[\\beta] = t_1[\\beta]$\n- $t_3[R \\setminus \\beta] = t_2[R \\setminus \\beta]$\n- $t_4[\\beta] = t_2[\\beta]$\n- $t_4[R \\setminus \\beta] = t_1[R \\setminus \\beta]$\n\nThe following is a tabular representation of the multivalued dependency $\\alpha \\twoheadrightarrow \\beta$.\n\n|       | $\\alpha$ | $\\beta$ | $R \\setminus (\\alpha \\cup \\beta)$ |\n|-------|----------|---------|-----------------------------------|\n| $t_1$ | E | A | C |\n| $t_2$ | E | B | C |\n| $t_3$ | E | A | D |\n| $t_4$ | E | B | D |\n\n### Alternate definition\n\nLet $R$ be a relation schema with a set of attributes that are partitioned into 3 nonempty subsets $X, Y, Z$.\n\nThen, $X \\twoheadrightarrow Y$ holds on $R$ if and only if for all possible relations $r(R)$:\n$$\n\\begin{align*}\n\\langle x_1, y_1, z_1 \\rangle, \\langle x_1, y_2, z_2 \\rangle \\in r \\\\ \\Rightarrow \\langle x_1, y_1, z_2 \\rangle, \\langle x_1, y_2, z_1 \\rangle \\in r\n\\end{align*}\n$$\n\nNote that since the behaviour of $Y$ and $Z$ are identical, it follows that $X \\twoheadrightarrow Y \\Leftrightarrow X \\twoheadrightarrow Z$.\n\n## Use of multivalued dependencies\n\nMultivalued dependencies can be used to:\n- Test relations to determine whether they are legal under a given set of functional and multivalued dependencies.\n- Specify constraints on the set of legal relations.\n\nIf a relation $r$ fails to satisfy a given multivalued dependency, a relation $r'$ that satisfies the multivalued dependency can be constructed by adding additional tuples to $r$.","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Nested-subqueries":{"title":"Nested subqueries","content":"\nA **subquery** is a `SELECT` - `FROM` - `WHERE` expression that is nested within another query.\n\nSQL provides a mechanism for the nesting of subqueries.\n\n## Set membership\n\nSQL allows testing tuples for membership in a relation, using `IN` or `NOT IN` clause.\n\n**Examples**\n- Name all instructors whose name is neither ‚ÄúMozart‚Äù nor ‚ÄúEinstein‚Äù\n\n```sql\nSELECT  DISTINCT name\nFROM    instructor\nWHERE   name NOT IN ('Mozart', 'Einsten');\n```\n\n- Find all the courses taught in the Fall 2009 semester, but not in the Spring 2010 semester\n\n```sql\nSELECT  DISTINCT course_id\nFROM    section\nWHERE   semester = 'Fall' AND year = 2009 AND course_id NOT IN\n(\n\tSELECT  course_id\n\tFROM    section\n\tWHERE   semester = 'Spring' AND year = 2010\n);\n```\n\n- Find the total number of distinct students who have taken course sections taught by the instructor with ID `10101`\n- As seen in the example query below, it is possible to test for membership in an arbitrary relation.\n\n```sql\nSELECT  COUNT(DISTINCT ID)\nFROM    takes\nWHERE   (course_id, sec_id, semester, year) IN\n(\n    SELECT  course_id, sec_id, semester, year\n\tFROM    teaches\n\tWHERE   teaches.ID = 10101\n);\n```\n    \n\n## Set comparison\n\n### `SOME` clause\n\n`SOME` clause can check if the predicate is satisfied by at least one tuple in the relation.\n\n- `F \u003ccomp\u003e SOME r` $\\Leftrightarrow$\n$\\exists \\, t \\in r$  such that $(F \\texttt{ \u003ccomp\u003e } t)$, where $\\texttt{\u003ccomp\u003e} \\in \\lbrace \u003c, \\leq, \u003e, \\geq, =, \\neq \\rbrace$\n- `= SOME` $\\Leftrightarrow$ `IN`, however `\u003c\u003e SOME` $\\not\\Leftrightarrow$ `NOT IN`\n\n**Example**    \nFind names of instructors with salary greater than that of some (at least one) instructor in the Biology department\n\n```sql\nSELECT  DISTINCT T.name\nFROM    instructor AS T,\n\t\t\t\tinstructor AS S\nWHERE   T.salary \u003e S.salary AND S.dept_name = 'Biology';\n```\n\n```sql\n-- Using SOME clause\nSELECT  name\nFROM    instructor\nWHERE   salary \u003e SOME\n(\n    SELECT  salary\n    FROM    instructor\n\tWHERE   dept_name = 'Biology'\n);\n```\n    \n\n### `ALL` clause\n\n`ALL` clause can check if the predicate is satisfied by all of the tuples in the relation.\n\n- `F \u003ccomp\u003e ALL r` $\\Leftrightarrow$\n$\\forall\\, t \\in r$ such that $(F \\texttt{ \u003ccomp\u003e } t)$, where  $\\texttt{\u003ccomp\u003e} \\in \\lbrace \u003c, \\leq, \u003e, \\geq, =, \\neq \\rbrace$\n- `\u003c\u003e ALL` $\\Leftrightarrow$ `NOT IN`, however `= ALL` $\\not\\Leftrightarrow$ `IN`\n\n**Example**    \nFind the names of all instructors whose salary is greater the salary of all instructors in the Biology department\n\n```sql\nSELECT  name\nFROM    instructor\nWHERE   salary \u003e ALL\n(\n    SELECT  salary\n\tFROM    instructor\n\tWHERE   dept_name = 'Biology'\n);\n```\n    \n\n## Test for empty relations\n\nThe `EXISTS` construct returns the value `TRUE` if the argument subquery is nonempty.\n\n- `EXISTS r` $\\Leftrightarrow$ $r \\neq \\emptyset$\n- `NOT EXISTS r` $\\Leftrightarrow$ $r = \\emptyset$\n\n**Example**\n\n- Find all students who have taken all courses offered in the Biology department\n\n```sql\nSELECT  DISTINCT S.ID,\n\t\t    S.name\nFROM    student AS S\nWHERE   NOT EXISTS\n(\n\tSELECT  course_id\n\tFROM    course\n\tWHERE   dept_name = 'Biology'\n\tEXCEPT\n\tSELECT  T.course_id\n\tFROM    takes AS T\n\tWHERE   S.ID = T.ID\n);\n```\n\n- Note that $X - Y = \\emptyset \\Leftrightarrow X \\subseteq Y$\n- This query **cannot** be written using `= ALL` and its variants\n## Test for the absence of duplicate tuples\n\nThe `UNIQUE` construct tests whether a subquery has any duplicate tuples in its result.\n\nIt evaluates to `TRUE` if a given subquery contains no duplicates.\n\n**Example**\n    \n- Find all courses that were offered at most once in 2017\n\n```sql\nSELECT  T.course_id\nFROM    course AS T\nWHERE   UNIQUE\n(\n\tSELECT  R.course_id\n\tFROM    course AS R\n\tWHERE   T.course_id = R.course_id AND\n\t\t\tR.year = 2017\n);\n```\n    \n\n## Subqueries in the `FROM` clause\nSince any `SELECT` - `FROM` - `WHERE` clause returns a relation as a result, it can be inserted into another `SELECT` - `FROM` - `WHERE` aanywhere that a relation can appear.\n\n**Example**\n\nFind the average instructors' salaries of those departments where the average salary is greater than 42000\n```sql\nSELECT  dept_name,\n        avg_salary\nFROM\n(\n    SELECT  dept_name,\n            AVG(salary) AS avg_salary\n    FROM    instructor\n    GROUP BY dept_name\n)\nWHERE   avg_salary \u003e 42000;\n```\n- Since the subquery in the `FROM` clause computes the average salary, `HAVING` query is not required; the predicate is rather inside the `WHERE` clause of the outer query.\n- The above query is equivalent to\n```sql\nSELECT  dept_name,\n        AVG(salary) AS avg_salary\nFROM    instructor\nGROUP BY dept_name\nHAVING  avg_salary \u003e 42000\n```\n\n## `WITH` clause\nThe `WITH` clause provides a way of defining a temporary relation whose definition is available **only** to the query in which the `WITH` clause occurs.\n\n**Examples**\n- Find all departments with the maximum budget\n```sql\nWITH    max_budget(value) AS\n(\n    SELECT  MAX(budget)\n    FROM    department\n)\nSELECT  department.dept_name\nFROM    department,\n        max_budget\nWHERE   department.budget = max_budget.value\n```\n- Find all departments where the total salary is greater than the average of the total salary at all departments\n```sql\nWITH    dept_total(dept_name, value) AS\n(\n    SELECT  dept_name,\n            SUM(salary)\n    FROM    departments\n    GROUP BY dept_name\n),\n        dept_total_avg(value) AS\n(\n    SELECT AVG(value)\n    FROM   dept_total\n)\nSELECT  dept_name\nFROM    dept_total,\n        dept_total_avg\nWHERE   dept_total.value \u003e dept_total_avg.value;\n```\n\n## Scalar subquery\nScalar subqeury is used where a **single value** is expected. It incurs a runtime error if the subquery returns more than one result tuple.\n\n**Example**\n- Find all departments, along with the number of instructors, in each department\n```sql\nSELECT  dept_name,\n(\n    SELECT  COUNT(*)\n    FROM    instructor\n    WHERE   department.dept_name = instructor.dept_name\n    GROUP BY dept_name\n)       AS num_instructors\nFROM    department;\n```","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Norm":{"title":"Norm","content":"## Intuition\nWIP\n\n## Definition\nA function $\\lVert\\cdot\\rVert: V\\to \\mathbb{R}$ is a norm if it satisfies the followings:\n\nFor arbitrary $\\mathbf{x},\\mathbf{y}\\in V$ and $c \\in \\mathbb{R}$,\n\n\u003e **(1)**    $\\lVert\\mathbf{x}+\\mathbf{y}\\rVert \\leq \\lVert\\mathbf{x}\\rVert + \\lVert\\mathbf{y}\\rVert$ „ÄÄ(Subadditivity)\n\u003e\n\u003e **(2)**    $\\lVert c\\mathbf{x}\\rVert = |c|\\lVert\\mathbf{x}\\rVert$ „ÄÄ(Absolute homogeneity)\n\u003e\n\u003e **(3)**    $\\lVert\\mathbf{x}\\rVert\\geq 0;$ $\\lVert\\mathbf{x}\\rVert = 0$ if and only if $\\mathbf{x}=\\mathbf{0}$ „ÄÄ(Positive semidefiniteness)\n\n## $L_p$-Norms\n### Definition\nFor $\\mathbf{x} = (x_1, \\cdots, x_n) \\in \\mathbb{R}^n$, an $L^p$-norm when $1\\leq p \u003c \\infty$ is defined as:\n\n$$\\lVert\\mathbf{x}\\rVert_p := \\left( \\sum\\limits_{i=1}^n |x_i|^p\\right)^{1/p}$$\n\nFor $p = \\infty$, the $L_\\infty$-norm is defined as:\n\n$$\\lVert\\mathbf{x}\\rVert_\\infty := \\sup\\limits_i |x_i|.$$\n\nFor $p=0$, the $L_0$-\"norm\"[^-1] is defined as:\n$$\\lVert\\mathbf{x}\\rVert_0 := \\text{card}(\\mathbf{x}) = \\sum\\limits_{i=1}^n \\mathbb{I}(x_i \\neq 0)$$\n\nwhere\n\n$$\\mathbb{I}(x_i \\neq 0) :=\n\\begin{cases}\n1 \\qquad \\text{if„ÄÄ} x_i \\neq 0\\\\\n0 \\qquad\\text{otherwise.}\n\\end{cases}$$\n\nThe $L_2$-norm is also called the Euclidean norm.\n\n## Unit Balls\nThe set of all vectors with $L_p$-norm less than or equal to $1$,\n$$\\mathcal{B}_p = \\lbrace\\mathbf{x} \\in \\mathbb{R}^n:\\lVert\\mathbf{x}\\rVert_p \\leq 1 \\rbrace$$\nis called the unit $L_p$-norm ball.\nThe following figure shows the shapes of the $\\mathcal{B}_p$ balls in $\\mathbb{R}^2$ for $p\\in \\lbrace 1/2, 1, 1.1, 4/3, 2, \\infty \\rbrace$.\n\n![various-unit-balls](/notes/images/various-unit-balls.png)\n\n[^-1]: This is a slight abuse in the term as $L^0$-\"norm\" does not satisfy the second property(absolute homogeneity). This is justified as $$\\text{card}(\\mathbf{x}) = \\lim\\limits_{p \\to 0}\\left( \\sum\\limits_{i=1}^n |x_i|^p\\right)^{1/p}.$$","lastmodified":"2022-12-27T21:16:58.281027739Z","tags":null},"/notes/Null-values-in-SQL":{"title":"Null values in SQL","content":"\n**`NULL` values** signifies an unknown value or that a value does not exist.\n\n## Arithmetic operations\n\nThe result of **any** arithmetic expression involving `NULL` is `NULL`.\n\n## Comparison operations\n\nSQL treats as `UNKNOWN` the result of **any** comparison involving a `NULL` value, other than `IS NULL` and `IS NOT NULL`.\n\nThe predicate in a `WHERE` clause can involve Boolean operations such as `AND`, `OR`, and `NOT`.\n\n- **`AND`**\n    - `TRUE AND UNKNOWN` = `UNKNOWN`\n    - `FALSE AND UNKNOWN` = `FALSE`\n    - `UNKNOWN AND UNKNOWN` = `UNKNOWN`\n- **`OR`**\n    - `UNKNOWN OR TRUE` = `TRUE`\n    - `UNKNOWN OR FALSE` = `UNKNOWN`\n    - `UNKNOWN OR UNKNOWN` = `UNKNOWN`\n- **`NOT`**\n    - `NOT UNKNOWN` = `UNKNOWN`\n\nThe result of `WHERE` clause predicate is treated as `FALSE` if the value evaluates to `UNKNOWN`.\n\n## `IS NULL` and `IS NOT NULL`\n\nThe predicate `IS NULL` can be used to check for `NULL` values.\n\nThe predicate `IS NOT NULL` succeeds if the value on which it is applied is not `NULL`.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Operating-systems":{"title":"Operating systems","content":"\n## Kernels and Processes\n- [Process](notes/Process.md)\n- [Dual-mode operation](notes/Dual-mode%20operation.md)\n- [Mode transfer](notes/Mode%20transfer.md)\n\t- [Implementation of mode transfer](notes/Implementation%20of%20mode%20transfer.md)\n\t- [x86 Mode transfer](notes/x86%20Mode%20Transfer.md)\n- [Secure system call](notes/Secure%20system%20call.md)\n- [System upcalls](notes/System%20upcalls.md)\n\n## Concurrency and Threads\n- [Thread](notes/Thread.md)\n\t- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)\n\t- [Thread data structures](notes/Thread%20data%20structures.md)\n\t- [Thread life cycle](notes/Thread%20life%20cycle.md)\n\t- [Thread models](notes/Thread%20models.md)\n\n## Synchronisation\n- [Atomic operation](notes/Atomic%20operation.md)\n- [Critical section](notes/Critical%20section.md)\n- [Race condition](notes/Race%20condition.md)\n\t- [Too much milk problem](notes/Too%20much%20milk%20problem.md)\n\t- [Bounded buffer problem](notes/Bounded%20buffer%20problem.md)\n- [Lock](notes/Lock.md)\n- [Condition variable](notes/Condition%20variable.md)\n- [Semaphore](notes/Semaphore.md)\n- [Deadlock](notes/Deadlock.md)\n\n## Scheduling\n- [Separation of mechanism and policy](notes/Separation%20of%20mechanism%20and%20policy.md)\n- ","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Overview-of-SQL":{"title":"Overview of SQL","content":"\n## SQL Parts\n\n- **Data-Definition Language (DDL)**\n    \n    Provides commands for defining relation schemas, deleting relations, and modifying relation schemas.\n    \n- **Data-Manipulation Language (DML)**\n    \n    Provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database.\n    \n- **Integrity**\n    \n    Provides commands for specifying integrity constraints that the data stored in the database must satisfy.\n    \n- **View Definition**\n    \n    Provides commands for defining views.\n    \n- **Transaction Control**\n    \n    Provides commands for specifying the beginning and ending of transactions.\n    \n- **Embedding SQL \u0026 Dynamic SQL**\n    \n    Define how SQL statements can be embedded within general-purpose programming languages.\n    \n- **Authorisation**\n    \n    Provides commands for specifying access rights to relations and views.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Overview-of-normalisation":{"title":"Overview of normalisation","content":"\nSuppose that the tables `instructor` and `department` are combined via [[notes/Join expressions#Natural join|natural join]].\n\n![bad-relation-design-example](notes/images/bad-relation-design-example.png)\n\nThis relation design is not good because:\n- There are repetitions of information.\n- [[notes/Null values in SQL|Null values]] must be used when a new `department` with no `instructor` is added.\n\nHowever, not all combined schemas result in repetitions of information.\n\n## Decomposition\n\nThe only way to avoid the repetition-of-information problem in the previous example is to **decompose** it into two schemas: `instructor` and `department`.\n\nHowever, not all decompositions are good. Consider the decomposition\n| Relation | Attributes |\n| -------- | ---------- |\n| employee | ID, name, street, city, salary |\n\ninto\n\n| Relation | Attributes |\n| -------- | ---------- |\n| employee1 | ID, name |\n| employee2 | name, street, city, salary |\n\nThe problem arises when there are multiple employees with the same name.\n\n![lossy-decomposition-example](notes/images/lossy-decomposition-example.png)\n\nSuch decomposition is unable to represent certain important facts about the relation before the decomposition. This kind of decomposition is referred to as a **lossy decomposition**. Conversely, those that are not are referred to as **lossless decomposition**.\n\n## Lossless decomposition\nLet $r$ be a relation, $R$ be a relation schema of $r$ and let $R_1, R_2$ form a decomposition of $R$. In other words, $R = R_1 \\cup R_2$.\n\nThe decomposition is said to be **lossless** if there is no loss of information by replacing $R$ with $R_1 \\cup R_2$. Or equivalently,\n\n$$\n\\Pi_{R_1}(r) \\bowtie \\Pi_{R_2}(r) = r\n$$\n\nConversely, a decomposition is said to be **lossy** if\n\n$$\nr \\subsetneq \\Pi_{R_1}(r) \\bowtie \\Pi_{R_2}(r)\n$$\n\n### Definitions with functional dependencies\n\n[[notes/Functional dependency|Functional dependencies]] can be used to show when certain decompositions are lossless.\n\nConsider the decomposition of $R$ into $R_1, R_2$. The sufficient condtion for it to be a **lossless decomposition** is that _at least one_ of the following dependencies is in $F^+$:\n- $R_1 \\cap R_2 \\to R_1$\n- $R_1 \\cap R_2 \\to R_2$\n\n## Design goals of relational database\n\nThe primary goal for a relational database design is:\n- [[notes/Boyce-Codd normal form|BCNF]]\n- [[notes/Overview of normalisation#Lossless decomposition|Losslessness]]\n- [[notes/Dependency preservation|Dependency preservation]]\n\nHowever, if all three of the goals cannot be achieved, then one of the followings is accepted:\n- **Lossless BCNF**: Lack of dependency preservation\n- **[[notes/Third normal form|3NF]]**: More redundancy","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Parser":{"title":"Parser","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Performance":{"title":"Performance","content":"\n## Defining Performance\n- **Response time (execution time)**: The time between start and completion of a task\n- **Throughput (Bandwidth)**: The number of tasks completed per unit time\n\n## Measuring Performance\n- **Clock cycle** (s): The time for one clock period (usually the processor clock) - constant\n- **Clock rate** (Hz): The inverse of clock period\n- **CPU execution time**: The time CPU spends computing for a certain task (does not include time spent waiting for I/O or running other programs)\n$$\n\\begin{align*}\n\\text{CPU time} \u0026= \\text{CPU clock cycles} \\times \\text{Clock cycle time}\\\\\n\u0026= \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}\n\\end{align*}\n$$\n- **CPI (Clock cycles per instruction)**: The average number of clock cycles per instruction for a program or program fragment.\n$$\n\\begin{align*}\n\\text{CPU clock cycles} = \\text{Total number of instructions} \\times \\text{CPI}\n\\end{align*}\n$$\nTherefore, we have the following.\n$$\n\\begin{align*}\n\\text{CPU time} \u0026= \\frac{\\text{Instruction count} \\times \\text{CPI}}{\\text{Clock rate}}\n\\end{align*}\n$$\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Primary-keyE-R":{"title":"Primary key(E-R)","content":"\n[[notes/Keys|Primary keys]] provide a way to specify how entities and relationships are distinguished.\n\n## Primary key for [[notes/Entity set|entity sets]]\n\nBy definition, individual entities are distinct. However, from a database perspective, the differences among them must be expressed in terms of their attributes.\n\nTherefore, the values of the attribute values of an entity must be such that theycan _uniquely identify_ the entity.\n\nThe concepts of superkey, candidate key, and primary key are applicable to entity sets just as they are applicable to [[notes/Structure of relational databases|relation schemas]].\n\n## Primary key for [[notes/Relationship set|relationship sets]]\n\nTo distinguish among the various relationships of a relationship set, the **individual primary keys of the entities** in the relationship set are used.\n\nLet $R$ be a relationship set involving entity sets $E_1, \\cdots, E_n$. Let $A = \\lbrace a_1, \\cdots, a_m \\rbrace$ be the set of attributes assoiciated with $R$, which may be $\\emptyset$. Then, the set of attributes\n\n$$\n\\left( \\bigcup_{i=1}^n \\texttt{primary-key}(E_i) \\right) \\cup A\n$$\n\nforms a primary key for $R$.\n\nThe choice of the primary key for a relationship set depends on the [[notes/Constraint(E-R)#Mapping cardinality|mapping cardinality]] of the relationship set.\n\n## Weak entity sets\n\nIn some cases, the primary key of an entity in a relationship is redundant when describing the relationship. In this case, an alternative way to deal with this redundancy is to not store the redundant attribute in the entity.\n\nA **weak entity** is one whose existence is dependent on another entity, called its **identifying entity**. An entity set that is not a weak entity set is termed a **strong entity set**.\n\nInstead of associating a primary key with a weak entity, we use the identifying entity, along with extra attributes called a **discriminator** or **partial key** to uniquely identify a weak entity.\n\nEvery weak entity _must_ be associated with an identifying entity; the weak entity set is said to be **existence dependent** on the identifying entity set.\n- The identifying entity set is said to **own** the weak entity set that it identifies.\n- The relationship associating the weak entity set with the identifying entity set is called the **identifying relationship**.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Process":{"title":"Process","content":"\nA **process** is an instance of a program; it is the execution of a program with restricted rights. Processes provide the illusion of an infinite number of _machines_. Each program can have zero, one, or more processes executing it. For each instance of a program, there is a process with its own copy of the program in memory.\n\nThe operating system keeps track of the processes on the computer using a data structure called the **process control block** (PCB).\n\n\n## Comparison with [threads](notes/Thread.md)\n- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Programming-language-theory":{"title":"Programming language theory","content":"\n**Programming language theory** (**PLT**) is a branch of [computer science](index/Computer%20science.md) that deals with the design, implementation, analysis, characterisation, and classification of formal languages known as programming languages and of their individual features.\n\n## Syntax and Semantics\n- [Syntax](notes/Syntax.md)\n\t- [Concrete syntax](notes/Concrete%20syntax.md)\n\t- [Abstract syntax](notes/Abstract%20syntax.md)\n\t- [Parser](notes/Parser.md)\n- [Semantic](notes/Semantic.md)\n- Identifier\n\t- Interpreter\n\n## Functions\n- First-order function\n- First-class function\n- Recursion\n\n## Mutability\n- Box\n- Mutable variable\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Properties-of-determinant":{"title":"Properties of determinant","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Purpose-of-database-systems":{"title":"Purpose of database systems","content":"\nIn the early days, [database](notes/Database%20systems.md) applications were built directly on top of file systems, which leads to several disadvantages.\n\n- **Data redundancy and inconsistency**\n  \n  Data is stored in multiple file formats, resulting in duplication of information in different files. In addition, this may lead to data inconsistency, where the various copies of the same data no longer agree.\n\n- **Difficulty in accessing data**\n  \n  Conventional file-processing environments do not allow needed data to be retrieved in a convenient and efficient manner.\n\n- **Data isolation**\n  \n  Because data are scattered in _various files_, and files may be in _different formats_, writing new application programs to retrieve the appropriate data is difficult.\n\n- **Integrity problems**\n\n    The data values stored in the database must satisfy certain types of _integrity constraints_(e.g., `account_balance \u003e= 0`). Without database systems, these integrity constraints become buried in the program code, making it hard to add new constrains or change existing ones.\n\n- **Atomicity problems**\n\n    Failures may leave data in an inconsistent state with only partial updates carried out; data update must be _[atomic](notes/Atomic%20operation.md)_. It is difficult to ensure atomicity in a conventional file-processing system.\n\n- **Concurrent access anomalies**\n  \n  For the sake of overall performance, many systems allow concurrent access to data. However, uncontrolled concurrent access can lead to data inconsistencies.\n\n- **Security problems**\n  \n  Not every user of the database system should be able to access all the data. It is hard to provide user access to som, but not all, data in conventional file-processing environments.\n\n[[notes/Database systems]] offer solutions to all of the above problems.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Race-condition":{"title":"Race condition","content":"\n## Definition\nA **race condition** is a situation where multiple process access and manipulate _the same data_ concurrently, and the outcome of the execution depends on _the particular order_ (interleaving) of such accesses.\n\n## Example\nSuppose that initially `y = 12`, and a program with two threads that do the following is run.\n\n| Thread A    | Thread B    |\n| ----------- | ----------- |\n| `x = y + 1` | `y = y * 2` |\n\n- If thread A reads `y` before thread B updates `y`, the result is `x = 13`.\n- Otherwise, the result is `x = 25`.\n\nSuppose that initially `x = 0`, and a program with two threads that do the following is run.\n\n| Thread A    | Thread B     |\n| ----------- | ------------ |\n| `x = 1`     | `y = 2`      |\n| `x = y + 1` | `y = y * 2*` |\n\n- If thread A runs to completion and then thread B starts and runs to completion, the result is `x = 1`.\n- If thread B runs to completion and then thread A starts and runs to completion, the result is `x = 5`.\n- If thread B executes `y = 2` and interleaves - thread A starts and runs to completion - and thread B executes `y = y * 2`, the result is `x = 3`.\n- If thread A executes `x = 1` and interleaves - thread B starts and runs to completion - and thread A executes `x = y + 1`, the result is `x = 5`.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Recursive-queries":{"title":"Recursive queries","content":"\nRecursive [[notes/Views | views]] make it possible to write queries that cannot be written without recursion or iteration.\n\n**Example**\n- Find all (direct or indirect) prerequisite subjects of each course\n```sql\nWITH RECURSIVE rec_prereq(course_id, prereq_id) AS\n(\n    (\n        SELECT  course_id,\n                prereq_id\n        FROM    prereq\n    )\n    UNION\n    (\n        SELECT  rec_prereq.course_id,\n                prereq.prereq_id\n        FROM    rec_prereq,\n                prereq\n        WHERE   rec_prereq.prereq_id = prereq.course_id\n    )\n)\nSELECT  course_id\nFROM    rec_prereq;\n```\nThe example view `rec_prereq` is called the **transitive closure** of the `prereq` relation, meaning that it is a relation that contains all pairs (`cid`, `pre`) such that `pre` is a direct or indirect prerequisite of `cid`.\n\nRecursive views are required to be **monotonic**.\n- For each step of the recursion, the view **must** contain all of the tuples it contained in the previous step, plus possibly some more.\n\n- At some point, no tuple is added to the view after recursion. This final result is called the **fixed point** of the recursive view definition.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Reduction-to-relational-schema":{"title":"Reduction to relational schema","content":"\n[[notes/Entity set|Entity sets]] and [[notes/Relationship set|relationship sets]] can be expressed uniformly as [[notes/Structure of relational databases|relation schemas]] that represent the contents of the database.\n\nA database which conforms to an [[notes/E-R diagram]] can be represented by a collection of schemas. For each entity set and relationship set, there is a _unique_ schema that is assigned the name of the corresponding entity set or relationship set. Furthermore, each schema has a number of columns (generally corresponding to attributes), which have unique names.\n\n## Representing [[notes/Entity set|entity sets]]\n\n- A **strong eneity set** reduces to a schema with the same attributes.\n  - e.g., $\\texttt{student(\\underline{ID}, name, credits)}$\n- A **[[notes/Primary key(E-R)#Weak entity sets|weak entity set]]** becomes a table that includes a column for the primary key of the identifying strong entity set.\n  - e.g., $\\texttt{section(\\underline{courseID}, \\underline{secID}, \\underline{sem}, \\underline{year})}$\n\n### Entity sets with composite attributes\n\n- **[[notes/Attribute(E-R)|Composite attributes]]** are flattened out by creating a separate attribute for each component attribute.\n  - e.g., with composite attribute `name` with component attributes `firstName`, `middleName`, and `lastName`:\\\n    $\\texttt{instructor(..., firstName, middleName, lastName, ...)}$\n\n### Entity sets with multivalued attributes\n\n- A **[[notes/Attribute(E-R)|multivalued attribute]]** $M$ of an entity $E$ is represented by a _separate schema_ $EM$.\n- The schema $EM$ has attributes corresponding to the primary key of $E$, and an attribute corresponding to the multivalued attribute $M$.\n  - e.g., Multivalued attribute `phoneNo` of `instructor` is represented by:\\\n    $\\texttt{inst-phone(\\underline{ID}, \\underline{phoneNo})}$\n- Each balue of the multivalued attribute maps to a separate tuple of the relation on the schema $EM$.\n\n## Representing [[notes/Relationship set|relationship sets]]\n\n### Relationship sets with different [[notes/Constraint(E-R)#Mapping cardinality|mapping cardinalities]]\n\n- A **many-to-many** relationship is represented as a schema with attributes for the primary keys of the two participating entity sets, and any descriptive attributes of the relationship set.\n  - e.g., Schema for a relationship set `advisor` between `student` and `instructor`:\\\n    $\\texttt{advisor(\\underline{studentID}, \\underline{instructorID})}$\n- **Many-to-one** and **one-to-many** relationship sets that are _[[notes/Constraint(E-R)#Participation constraints|total]]_ on the many-side can be represented by adding an extra attribute to the 'many' side, containing the primaty keys of the 'one' side.\n  - e.g., Instead of creating a schema for a relationship set `inst-dept` between `instructor` and `department` with many-to-one mapping, add an attribute `deptName` to the schema arising from the entity set `instructor`.\n  - If the [[notes/Constraint(E-R)#Participation constraints|participation]] if **partial** on the 'many' side, this could result in [[notes/Null values in SQL|null values]].\n- A **one-to-one** relationship sets, either side can be chosen to act as the 'many' side.\n  - An extra attribute can be added to either of the tables corresponding to the two entity sets.\n\n## Redundancy of schemas\n\n- The schema corresponding to a relationship set linking a [[notes/Primary key(E-R)#Weak entity sets|weak entity set]] to its identifying strong entity set is **redundant**.\n  - e.g., The `section` schema already contains the attributes that would appear in the `sec-course` schema.\n\n## Representing [[notes/Extended E-R features#Specialisation|specialisations]]\n\n### Method 1\n1. Form a schema for the higher level entity.\n2. Form a schema for each of the lower level entity set, and include the primary key if the higher level entity set and local attributes.\n\ne.g.,\n| Schema | Attributes |\n|--------|------------|\n| person | ID, name, street, city |\n| student | ID, credits |\n| employee | ID, salary |\n\n- **Drawbacks**: Accessing information about an lower level entity requires accessing two relations (the one corresponding to the lower level schema, and the one corresponding to the higher level schema).\n\n### Method 2\n1. Form a schema for each entity set with all local and inherited attributes.\n  \ne.g.,\n| Schema | Attributes |\n|--------|------------|\n| person | ID, name, street, city |\n| student | ID, name, street, city, credits |\n| employee | ID, name, street, city, salary |\n\n- **Drawbacks**: Some attributes may be stored redundantly for entities that belongs to two or more specialised entity sets.\n\n## Representing aggregations\n\nTo represent [[notes/Extended E-R features#Aggregation|aggregations]], create a schema containing\n- The primary key of the aggregated relationship\n- The primary key of the associated entity set\n- Any descriptive attributes\n\ne.g.,\n\nConsider the ternary relationship `proj-guide` between `instructor`, `student`, and `project`. Regard the relationship set `proj-guide` as a higher-level entity set. Create a binary relationship `eval-for` between `proj-guide` and `evaluation`.\n\nThe schema for `eval-for` is: $\\texttt{eval-for(studentID, projectID, instructorID, evaluationID)}$","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Relation":{"title":"Relation","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Relational-algebra":{"title":"Relational algebra","content":"\nA **relational algebra** is a procedural [[notes/Relational query language | query language]] consisting of a set of operations that take one or two relations as input and produce a new relation as their result.\n\nThere are six basic operators: $\\sigma$(Selection), $\\Pi$(Projection), $\\cup$(Union), $-$(Set difference), $\\times$(Cartesian product), and $\\rho$(Rename).\n\nNote that there are **equivalent queries**; there may be multiple ways to write a query in relational algebra.\n\n## Selection\n\nThe unary selection operator $\\sigma$ selects tuples that satisfy a given predicate.\n\n- $\\sigma_p(r)$, where $p$ is a selection predicate and $r$ is a relation.\n    - e.g., $\\sigma_{\\texttt{building=\"E11\"}}(\\texttt{Department})$\n- Comparisons uses $=, \\neq, \u003e, \\geq, \u003c, \\leq$ in the selection predicate.\n- Predicates are combined using $\\wedge, \\vee, \\neg$.\n- The select predicate may include comparisons between two different attributes.\n\n## Projection\n\nThe unary projection operator $\\Pi$ returns its argument relation with certain attributes removed.\n\n- $\\Pi_{A_1, \\cdots, A_k}(r)$, where $A_i$s are attributes and $r$ is a relation.\n    - e.g., $\\Pi_{\\texttt{ID,name,salary}}(\\texttt{Instructor})$\n- Duplicate rows are removed from the result\n\n## Cartesian Product\n\nThe binary cartesian operator $\\times$ combines information from two relations.\n\n It constructs a tuple of the result out of *each possible pair of tuples*.\n\n- $r_1 \\times r_2$, where $r_1$ and $r_2$ are relations.\n    - e.g., $\\texttt{Instructor} \\times \\texttt{Teaches}$\n- To distinguish between attributes present in both relations, attach the name of the originating relation to the name of the attribute.\n    - e.g., $\\texttt{Instructor}.\\texttt{ID}, \\texttt{Teaches}.\\texttt{ID}$\n\n### Join\n\nJoin operator $\\bowtie$ is a composition of a cartesian product followed by a selection operation.\n\nIt returns only those tuples that satisfy some predicate(s), among all possible combinations of tuples from the two relations.\n\nIt does *not* belong to the six basic operations.\n\n- $r_1\\bowtie_\\theta r_2 := \\sigma_\\theta(r_1\\times r_2)$, where $r_1(R_1)$, $r_2(R_2)$ are relations, and $\\theta$ is a predicate on attributes on the schema $R_1 \\cup R_2$.\n    - e.g., $\\texttt{Instructor} \\bowtie_{\\texttt{Instructor.ID=Teaches.ID}}\\texttt{Teaches}$\n\n## Union\n\nThe binary union operator $\\cup$ combines two relations.\n\nIt returns all tuples that are present in at least one of the relations.\n\nTwo relations *must* satisfy the [[notes/Relational algebra#Condition | condition]].\n\n- $r_1 \\cup r_2$, where $r_1$ and $r_2$ are relations.\n    - e.g., Find all courses taught in fall 2017, or in spring 2018, or in both:\n    $$\n        \\Pi_{\\texttt{courseID}}(\\sigma_{\\texttt{semester=\"Fall\"}\\wedge\\texttt{year=2017}}(\\texttt{Section})) \\cup \\\\\n        \\Pi_{\\texttt{courseID}}(\\sigma_{\\texttt{semester=\"Spring\"}\\wedge\\texttt{year=2018}}(\\texttt{Section})\n    $$\n\n### Intersection\n\nThe binary union operator $\\cap$ combines two relations.\n\nIt returns all tuples that are present in both of the relations.\n\nTwo relations *must* satisfy the [[notes/Relational algebra#Condition | condition]].\n\n- $r_1 \\cap r_2$, where $r_1$ and $r_2$ are relations.\n\n## Set Difference\n\nThe binary union operator $-$ combines two relations.\n\nIt returns all tuples that are present in the preceding relation, but not in the succeeding relation.\n\nTwo relations *must* satisfy the [[notes/Relational algebra#Condition | condition]].\n\n- $r_1 - r_2$, where $r_1$ and $r_2$ are relations.\n\n## Rename\n\nThe unary rename operator $\\rho$ assigns a name to the results of relational algebra expressions.\n\nIt returns the result of the expression under the given name.\n\n- $\\rho_{x(A_1, \\cdots, A_k)}(E)$, where $A_i$s are attributes, $E$ is a relational algebra expression, and $x$ is a name.\n\n### Assignment\n\nAssignment operation $\\leftarrow$ assigns a relational algebra expression to a temporary relation variable.\n\nIt acts similar as the assignment operation in general-purpose programming languages.\n\n- $x \\leftarrow E$, where $x$ is a name and $E$ is a relational algebra expression.\n    - e.g., Find all instructors in any of the Physics or Music departments:\n  \n    $\\texttt{PH} \\leftarrow \\sigma_{\\texttt{deptname=\"Physics\"}}(\\texttt{Instructor})$\n\n    $\\texttt{MU} \\leftarrow \\sigma_{\\texttt{deptname=\"Musics\"}}(\\texttt{Instructor})$\n    \n    $\\texttt{PH} \\cup \\texttt{MU}$\n- With the assignment operation, a query can be written as a sequential program consisting of a series of assignments, followed by an expression whose value is displayed as the result of the query.\n\n---\n\n#### Condition\n\u003e - Two relations must have the same arity.\n\u003e - The attributes of the two relations must be compatible.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Relational-query-language":{"title":"Relational query language","content":"\nA **query language** is a language in which a user requests information from the database.\n\nThere are some ‚Äòpure‚Äô query languages, equivalent in computing power.\n\n- [[notes/Relational algebra]]\n- Tuple relational calculus\n- Domain relational calculus","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Relationship-set":{"title":"Relationship set","content":"\nA **relationship** is an association among several entities. A **relationship instance** in an E-R schema represents an association between the named entities in the real-world enterprise that is being modeled.\n\n![relationship-example](/notes/images/relationship-example.png)\n\nA **relationship set** is a set of relationships of the same type. Formally, it is a [[notes/Relation|mathematical relation]] on $n \\geq 2$ [[notes/Entity set|entity sets]] that are not necessarily distinct.\n\nIf $E_1, \\cdots, E_n$ are entity sets, then a relationship set $R$ is a subset of\n$$\n\\lbrace (e_1, \\cdots, e_n) : e_i \\in E_i, i = 1, \\cdots, n \\rbrace\n$$\nwhere $(e_1, \\cdots, e_n)$ is a relationship.\n\nThe entity sets $E_1, \\cdots, E_n$ are said to **participate** in the relationship set $R$.\n\nThe function that an entity plays in a relationship is called that entity's **role**. Each occurrence of an entity set plays a role in the relationship. However, since entity sets participating in a relationship set are generally distinct, roles are implicit and are not usually specified.\n\nAn relationship may also have attributes called **descriptive attirbutes** that are associated with a relationship set.\n\n![descriptive-attribute-example](/notes/images/descriptive-attribute-example.png)\n\n## Nonbinary relationship sets\n\nThe number of entity sets that participate in a relationship set is the **degree** of the relationship set.\n- A binary set relationship set is of degree 2.\n- A ternary set relationship set is of degree 3.\n\nA relationship set with degree greater than 2 are uncommon in practice.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/RestrictionDatabase":{"title":"Restriction(Database)","content":"\n## Definition\n\n### Functional dependency\n\nLet $F$ be the set of [[notes/Functional dependency|functional dependencies]] on schema $R$, and let $R_1, \\cdots, R_n$ be a decomposition of $R$.\n\nThe **restriction** of $F$ to $R_i$, denoted as $F_i$, is the set of all functional dependencies in the **[[notes/Closure(Database)#Closure of functional dependencies|closure]]** $F^+$ (Note: **not** $F$) that include only attributes of $R_i$.\n\n### Multivalued dependency\n\nLet $D$ be the set of functional and [[notes/Multivalued dependency|multivalued dependencies]] on schema $R$, and let $R_1, \\cdots, R_n$ be a decomposition of $R$.\n\nThe **restriction** of $D$ to $R_i$, denoted as $D_i$, is the set of all functional and multivalued dependencies in the **[[notes/Closure(Database)#Closure of multivalued dependencies|closure]]** $D^+$ that include only attributes of $R_i$.\n\nThat is,\n- All functional dependencies in $D^+$ that include only attributes of $R_i$.\n- All multivalued dependencies of the form $\\alpha \\twoheadrightarrow (\\beta \\cap R_i)$, where $\\alpha \\subseteq R_i$ and $\\alpha \\twoheadrightarrow \\beta \\in D^+$.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Roles":{"title":"Roles","content":"\nA **role** is a way to distinguish among various as far as what these users can access / update in the database.\n\nA role can be thought of as a _set of [[notes/Authorisation | privileges]]_; with roles, privileges of multiple users can be managed at once.\n\nRoles can be created as following.\n```sql\nCREATE ROLE \u003cname\u003e\n```\nOnce a role is created, users can be assigned to the role as following.\n```sql\nGRANT   \u003crole\u003e\nTO      \u003cuser list\u003e\n```\nNote that\n- Privileges can be granted to roles.\n- Roles can be granted to users, as well as to other roles.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/SQL-data-definition":{"title":"SQL data definition","content":"\n## Domain types in SQL\n\n- **`CHAR(n)`**\n  \n    Fixed-length character string, with user-specified length `n`\n    \n- **`VARCHAR(n)`**\n  \n    Variable-length character string, with user-specified **maximum** length `n`\n    \n- **`INT`**\n  \n    Integer (machine-dependent)\n    \n- **`SMALLINT`**\n  \n    Small integer (machine-dependent)\n    \n- **`NUMERIC(p, d)`**\n  \n    Fixed-point  number, with user-specified precision of `p` digits (plus a sign), with `d` digits to the right of the decimal point\n    - `NUMERIC(3, 1)` allows `44.5` to be stored exactly, but neither `444.5` or `0.32` can be stored exactly.\n  \n- **`REAL`, `DOUBLE PRECISION`**\n  \n    Floating-point and double precision floating-point numbers (machine-dependent precision)\n    \n- **`FLOAT(n)`**\n  \n    Floating-point number, with user-specified precision of at least `n` digits\n    \n\n## Basic schema definition\n\nAn SQL relation is defined using the `CREATE TABLE` command.\n\n```sql\nCREATE TABLE r\n(\n\tA_1 D_1,\n\t... ,\n\tA_n D_n,\n\t[Integrity Constraint 1],\n\t... ,\n\t[Integrity Constraint k]\n)\n```\n\n- `r`: Name of the relation\n- `A_i`: Attribute name in the schema of the relation `r`\n- `D_i`: Data type of values in the domain of attribute `A_i`\n\n**Example**\n```sql\nCREATE TABLE instructor\n(\n\tID           CHAR(5),\n\tname         VARCHAR(20) NOT NULL,\n\tdept_name    VARCHAR(20),\n\tsalary       NUMERIC(8, 2),\n\tPRIMARY KEY(ID),\n\tFOREIGN KEY(dept_name) REFERENCES department\n);\n```\n    \n\n### Integrity Constraints\n\n- **`PRIMARY KEY(A_1, ... , A_n)`**\n    - Attributes `A_1`, ‚Ä¶ , `A_n` form the primary key for the relation.\n    - Required to be *non-null* and *unique*.\n    \n- **`FOREIGN KEY(A_1, ... , A_n) REFERENCES s`**\n    - Values of attributes `(A_1, ... , A_n)` for any tuple in the relation *must* correspond to values of the **primary key** attributes (or any attributes with `UNIQUE` constraint specified) of some tuple in relation `s`\n    \n- **`NOT NULL`**\n    - `NULL` value is not allowed for that attribute\n    \n\n### Updates to Tables\n\n- **`INSERT INTO s t`**\n    - Inserts tuple `t` into the relation `s`\n    - e.g., `INSERT INTO instructor VALUES('10211', 'Smith', 'Biology', 66000)`\n\n- **`DELETE FROM s t`**\n    - Deletes tuple `t` from the relation `r`\n    - e.g., `DELETE FROM student` deletes **all** tuples from the relation `student`\n    \n- **`DROP TABLE r`**\n    - Deletes all information of `r`, including the table itself, from the database\n    - After `r` is dropped, no tuples can be inserted into it unless it is re-created with the `CREATE TABLE` command\n    \n- **`ALTER`**\n    - **`ALTER TABLE r ADD A D`**\\\n        `A` is the name of the attribute to be added to relation `r`, and `D` is the domain of `A`\n        \n        All existing tuples in the relation are assigned `NULL` as the value for the new attribute\n        \n    - **`ALTER TABLE r DROP A`**\\\n        `A` is the name of an attribute of relation `r`","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/SQL-data-types-and-schemas":{"title":"SQL data types and schemas","content":"\n## Built-in data types in SQL\nIn addition to the [[notes/SQL data definition#Domain types in SQL | basic data types]], the SQL standard supports several data types:\n- `DATE`\n  \n  Dates in `YYYY-MM-DD` format\n  - e.g., `DATE '2001-11-15'`\n\n- `TIME`\n  \n  Time of day in hours, minutes, and seconds\n  - e.g., `TIME '09:00:30'`, `TIME '09:00:30.75'`\n\n- `TIMESTAMP`\n  \n  Date plus the time of day\n  - e.g., `TIMESTAMP '2001-11-15 09:00:30.75'`\n\n- `INTERVAL`\n  \n  Period of time\n  - e.g., `INTERVAL '1' day`\n  - Subtracting a `DATE` / `TIME` / `TIMESTAMP` from another gives an `INTERVAL` value\n  - `INTERVAL` values can be added to `DATE` / `TIME` / `TIMESTAMP` values\n\n## Large-object types\nMany current-generation database applications need to store attributes that can be large. SQL provides large-object data types for **character data** (`CLOB`) and **binary data** (`BLOB`). Here, 'lob' stands for 'Large OBject.'\n\nWhen a query returns a large object, a **pointer** is returned, rather than the large object itself.\n\n## User-defined types\nSQL provides the notion of **distinct types**. The `CREATE TYPE` clause can be used to define new types.\n```sql\nCREATE TYPE a AS t FINAL;\n```\n- `a`: Name of the new type\n- `t`: Pre-existing type\n\nBefore user-defined types were added to SQL, SQL had similar but subtly different notion of **domain**, which can add [[notes/Integrity constraints | integrity constraints]] to an underlying type.\n```sql\nCREATE DOMAIN d t\n    CONSTRAINT ...\n```\n- `d`: Name of the new domain\n- `t`: Pre-existing type\n\nThere are two significant differences between types and domains:\n- Domains can have constraints specified on them, and can have default values defined for variables of the domain type, whereas user defined types cannot have constraints of default values specified on them.\n- Domains are not strongly typed.\n\n## Index creation\nMany queries reference only a small proportion of the records in a table. Thus, it is inefficient for the system to read every record to find a record with particular value.\n\nAn **index** on an attribute of a relation is a data structure that allows the database system to find those tuples in the relation that have a specified value for that efficiently, _without_ scanning through all the tuples of the relation.\n```sql\nCREATE INDEX i ON r(A_1, ... , A_k)\n```\n- `i`: Name of the index\n- `r`: Relation\n- `A_i`: Attributes\n\n**Example**\n```sql\nCREATE INDEX studentID_idx ON student(ID);\n\nSELECT  *\nFROM    student\nWHERE   ID = '12345'\n```\nThe above query can be executed by using the index to find the required record, _without_ looking at all records of student.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Secure-system-call":{"title":"Secure system call","content":"\n## Importance\nThe kernel must implement its system calls in a way that protects itself from all errors and attacks that might be launched by the misuse of the interface. That is, the kernel should always assume that the parameters passed to a system call are intentionally designed to be as _malicious_ as possible.\n\n## Implementation of a Secure System Call\n\n![secure-syscall](/notes/images/secure-syscall.png)\n\n1. The user program calls the user stub in the normal way, oblivious to the fact the implementation of the procedure is in fact in the kernel.\n2. The user stub fills in the code for the system call and executes the trap instruction.\n3. The hardware transfers control to the kernel, vectoring to the system call handler. The handler acts as a stub on the kernel side, **copying** and checking arguments and then calling the kernel implementation of system call.\n4. After the system call completes, it returns to the handler.\n5. The handler returns to user level at the next instruction in the stub.\n6. The stub returns to the caller.\n\n## Tasks of the Kernel Stub\n### Locate system call arguments\nUnlike a regular kernel procedure, the arguments to a system call are stored in user memory. Since the user stack pointer may be corrupted, the stub must check the address to verify whether the pointer argument is a legal address within the user domain. If it is legal, the stub converts the virtual address into a physical address.\n\n### Validate parameters\nThe kernel must protect itself against malicious or accidental errors in the format or content of its arguments. If an error is detected, the kernel returns to the user program.\n\n### Copy before check\nAn application might modify the parameter _after_ the stub checks its value but _before_ the parameter is used in the actual implementation of the routine. This is called a **time of check vs. time of use (TOCTOU) attack**. To prevent this, kernel copies the system call parameters into kernel memory before performing the necessary checks.\n\n### Copy back any results\nFor the user program to access the results of the system call, the stub must copy the result from the kernel into user memory. The kernel must translate the physical address into virtual address before performing the copy.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Semantics":{"title":"Semantics","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Semaphore":{"title":"Semaphore","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Separation-of-mechanism-and-policy":{"title":"Separation of mechanism and policy","content":"\n## Definition\nThe separation of **mechanism** and **policy** is a design principle in computer science. According to the separation of mechanism and policy principle, mechanism should work no matter what policy is used.\n\n- **Mechanism** is a part of a system implementation that control the authorisation of operations and the allocation of resources.\n- **Policy** determines _which_ decisions are made about which operations to authorise, and which resources to allocate.\n\nFor example, when considering a [thread context switch](notes/Mode%20transfer.md), **mechanism** decides _how to switch between threads_, and **policy** determines _which thread to run next_.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Set-operations-in-SQL":{"title":"Set operations in SQL","content":"\n## `UNION` operation\n\nThe SQL operation `UNION` corresponds to the mathematical operation $\\cup$.\n\n```sql\nR1 UNION R2\n```\n\nThe `UNION` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `UNION ALL` operation instead.\n\n## `INTERSECT` operation\n\nThe SQL operation `INTERSECT` corresponds to the mathematical operation $\\cap$.\n\n```sql\nR1 INTERSECT R2\n```\n\nThe `INTERSECT` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `INTERSECT ALL` operation instead.\n\n## `EXCEPT` operation\n\nThe SQL operation `EXCEPT` corresponds to the mathematical operation $\\setminus$.\n\n```sql\nR1 EXCEPT R2\n```\n\nThe `EXCEPT` operation outputs all tuples from `R1` that do not occur in `R2`.\n\nThe `EXCEPT` operation automatically **eliminates duplicates**.\n\nTo retain duplicates, one must use `EXCEPT ALL` operation instead.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Set-theory":{"title":"Set theory","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Span":{"title":"Span","content":"\n## Definition\nLet $S$ be a nonempty subset of a vector space $V$.\\\nThe **span** of $S$, denoted $\\text{span}(S)$ or $\\langle S \\rangle$,\nis the set consisting of all linear combinations of the\nvectors in $S$.\n\nWe define $\\text{span}(\\emptyset) = \\lbrace 0 \\rbrace$ for convenience.\nA subset $S$ of a vector space $V$ **generates** (or **spans**) $V$\nif $\\text{span}(S) = V$.\\\nIn this case, we also say that the vectors of $S$ generate (or span)\n$V$.\n\n## Theorems\n### Theorem 1 *[^1]\n\u003eThe span of any subset $S$ of a vector space $V$ is a [subspace](notes/Subspace.md) of $V$ that contains $S$.\n\u003e\n\u003eMoreover, any [subspace](notes/Subspace.md) of $V$ that contains $S$ must also contain $\\text{span}(S)$.\n\n### Proof\nThis result is immediate if $S = \\emptyset$ because $\\text{span}(\\emptyset) = \\lbrace \\mathbf{0} \\rbrace$, which is a subspace that contains $S$ and is contained in any subspace of $V$.\n\nIf $S \\neq \\emptyset$, then $S$ contains some vector $\\mathbf{z}$; $0\\mathbf{z} = \\mathbf{0}$ is in $\\text{span}(S)$.\n\nLet $\\mathbf{x}, \\mathbf{y} \\in \\text{span}(S)$.\nThen there exists vectors $\\def\\v#1{\\mathbf{#1}} \\v{u}\\_1, \\cdots, \\v{u}\\_m, \\v{v}\\_1, \\cdots, \\v{v}\\_n$ in $S$ and scalars $a\\_1, \\cdots, a\\_m, b\\_1, \\cdots, b\\_n$\n\nsuch that\n\n$$\n\\def\\v#1{\\mathbf{#1}}\n\\begin{align*}\n\\v{x} = \\sum\\limits^m\\_{i=1} {a\\_i\\v{u}\\_i} \\quad\\text{and}\\quad \\v{y} = \\sum\\limits^n\\_{i=1}{b\\_i\\v{v}\\_i}.\n\\end{align*}\n$$\n\nThen, for any scalar $c$,\n\n$$\n\\def\\v#1{\\mathbf{#1}}\nc\\v{x}+\\v{y} = \\sum\\limits^m\\_{i=1} {(ca\\_i)\\v{u}\\_i} + \\sum\\limits^n\\_{i=1}{b\\_i\\v{v}\\_i}\n$$\n\nis clearly a linear combination of the vectors in $S$. Hence $c\\mathbf{x}+\\mathbf{y} \\in \\text{span}(S)$.\nThus $\\text{span}(S)$ is a subspace of $V$.\nFurthermore, if $\\mathbf{v} \\in S$, then $\\mathbf{v} = 1\\mathbf{v} \\in \\text{span}(S)$, so $S \\subseteq \\text{span}(S)$.\n\nNow let $W$ denote any subspace of $V$ that contains $S$.\nIf $\\mathbf{w} \\in \\text{span}(S)$, then $\\mathbf{w}$ is a linear combination of \nsome vectors $\\mathbf{w}_1, \\cdots, \\mathbf{w}_k$ of $S$.\nSince $S \\subseteq W$, $\\mathbf{w}_i \\in W$ for all $i = 1, \\cdots, k$. \nTherefore $\\mathbf{w}$ is a linear combination of vectors of $W$, hence $\\mathbf{w} \\in W$. Thus $\\text{span}(S) \\subseteq W$.\n$$\\tag*{$||$}$$\n\n\n[^1]: Linear Algebra, Fifth Edition, by Stephen Friedberg, Arnold Insel, and Lawrence Spence","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Statistics":{"title":"Statistics","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Structure-of-relational-databases":{"title":"Structure of relational databases","content":"\nA relational database consists of a collection of **tables**, each of which is assigned a unique name.\nIn general, a row in a table represents a *relationship* among a set of values.\n\n- In the relational model, the term **relation** is used to refer to a table, whilst the term **tuple** is used to refer to a row.\n- Similarly, the term **attribute** refers to a column of a table.\n    - Denoted as $A_1, \\cdots, A_n$.\n        \n        ![Screenshot 2022-10-10 at 6.53.06 PM.png](Structure%20of%20Relational%20Databases%209c04c2584af142379f668c5078a9d46d/Screenshot_2022-10-10_at_6.53.06_PM.png)\n        \n- A **relation schema** consists of a list of attributes and their corresponding domains.\n    - Denoted as $R = (A_1, \\cdots, A_n)$.\n- The term **relation instance** refers to a specific instance of a relation, i.e., containing a specific set of rows.\n    - Denoted as $r(R)$.\n- The **domain** of the attribute refers to the set of allowed values for each attribute.\n    - Attribute values are normally required to be **atomic**, i.e., elements of the domain are considered to be indivisible unit**s**.\n    - The special value **null** is a member of every domain, indicating that the value is *unknown*.\n- Relations are unordered, like sets in mathematics.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Subspace":{"title":"Subspace","content":"\n## Definition\n\u003e Let $V$ be a [vector space](notes/Vector%20space.md) over the [field](notes/Field.md) $F$. A **subspace** of $V$ is a subset $W \\subset V$ which itself is a vector space over $F$ with the same operations defined on $V$.\n\n## Observations\n### Observation 1\n\u003eIn any vector space $V$, $V$ and $\\lbrace \\mathbf{0} \\rbrace$ are subspaces of $V$.\n\u003eThe latter is called the **zero subspace** of $V$.\n\n## Theorems\n### Theorem 1 *[^1]\n\u003e A non-empty subset $W$ of $V$ is a subspace of $V$ _if and only if_ $\\forall \\mathbf{x}, \\mathbf{y} \\in W, \\forall c \\in F:$ $c\\mathbf{x} + \\mathbf{y} \\in W$.\n\n### Proof\n$(\\Rightarrow)$ Trivial.\n\n$(\\Leftarrow)$ Since $W \\neq \\emptyset$, $\\forall \\mathbf{v} \\in W:$ $(-1)\\mathbf{v} + \\mathbf{v} = \\mathbf{0} \\in W$.\n\n$\\forall \\mathbf{w} \\in W, \\forall c \\in F:$ $c\\mathbf{w} = c\\mathbf{w} + \\mathbf{0} \\in W$. In particular, $(-1)\\mathbf{w} = -\\mathbf{w} \\in W$.\n\nFinally, $\\forall \\mathbf{v}, \\mathbf{w} \\in W:$ $\\mathbf{v} + \\mathbf{w} = 1\\mathbf{v} + \\mathbf{w} \\in W$.\n\nTherefore, $W$ is a subspace of $V$.\n$$\\tag*{$||$}$$\n### Theorem 2 *[^1]\n\u003e The intersection of any collection of subspaces of a vector space $V$ is a subspace of $V$.\n\n### Proof\nLet $\\lbrace W\\_a \\rbrace$ be the collection of subspaces of $V$, and let $W = \\cap\\_{a}W\\_a$. Since $\\mathbf{0} \\in W\\_a$ for all $W\\_a$, $\\mathbf{0} \\in W$ and thus $W$ is nonempty.\n\nLet $\\mathbf{x}, \\mathbf{y} \\in W$ and $c$ be an arbitrary scalar. By definition of $W$, $\\mathbf{x},\\mathbf{y} \\in W\\_a$ for all $W\\_a$ and since they are all subspaces of $V$, $c\\mathbf{x} + \\mathbf{y} \\in W\\_a$ for all $W\\_a$. Thus $c\\mathbf{x} + \\mathbf{y} \\in W$. \n$$\\tag*{$||$}$$ \n\n[^1]: Linear Algebra, Second Edition, by Kenneth Hoffman and Ray Kunze","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Syntax":{"title":"Syntax","content":"\n**Syntax** of a programming language decides the apprearance of the language.\nIt allows us to know which strings are programs and what the structures of the programs are.\nIt consists of []","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/System-upcalls":{"title":"System upcalls","content":"\n## Necessity of System Upcalls\nTo allow applications to implement operating system-like functionality, more than [system call](notes/Mode%20transfer.md#System%20Calls) is required; applications can also benefit from being told when events occur that _need their immediate attention_. Such _virtualised_ interrupts and exceptions are called **upcalls**, also known as **signals** (in UNIX).\n\n## Uses of System Upcalls\n### Preemptive user-level threads\nAn application may run multiple tasks, or threads, in a process.\n\n### Asynchronous I/O notification (`async` / `await`)\nIn an asynchronous I/O, a system calls starts the request and returns immediately. Later, the application can poll the kernel for I/O completion, or a separate notification can be sent via an upcall to the application when the I/O completes.\n\n### Interprocess communication\nA kernel upcall is needed if a process generates an event that needs the instant attention of another process.\n\n### User-level exception handling\nApplications may have their own exception handling routines. For this, the operating system needs to inform the application when it receives a processor exception.\n\n### User-level resource allocation\nMany applications are able to optimise their behaviour to differing amounts of CPU time or memory.\n- e.g., Java garbage collection\n\n## Diagrams\n- The state of the user program and signal handler before a UNIX signal\n![upcall-before](/notes/images/upcall-before.png)\n\n- The state of the user program and signal handler during a UNIX signal\n![upcall-during](/notes/images/upcall-during.png)\n\n## Comparison with [interrupts](notes/Mode%20transfer.md#Interrupts)\n### Types of Signals\n- In place of hardware-defined interrupts and processor exceptions, the kernel defines a limited number of sifnal types that a process can receive.\n\n### Handlers\n- The kernel defines its own [interrupt vector](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Vector).\n- Each process defines its own signal handlers for each signal type.\n\n### Signal Stack\n- The kernel uses [interrupt stack](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Stack), a region of _kernel_ memory when handling interrupts.\n- Applications have the option to run UNIX signal handlers on the process's _normal execution stack_, or on a special **signal stack** allocated buy the user process in user memory.\n\n### Signal Masking\n- The kernel can defer the arrival of interrupts via [interrupt masking](notes/Implementation%20of%20mode%20transfer.md#Interrupt%20Masking).\n- UNIX defers signals for events that occur while the signal handler for those types of events is in progress.\n- The deferred signal is delivered once the handler returns to the kernel.\n\n### Processor State\n- The _kernel_ copies onto the signal stack the saved state of the program counter, stack pointer, and general-purpose registers at the point when the program stopped.\n- When the signal handler returns, the kernel reloads the saved state into the processor to resume program execution.\n- The signal handler can also _modify_ the saved state, so that the kernel resumes a different user-level task on return.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Third-normal-form":{"title":"Third normal form","content":"\n## Definition\n\nA relation schema $R$ is in **third normal form(3NF)** with respect to a set of [[notes/Functional dependency|functional dependencies]] $F$ if:\n\nFor all functional dependencies $\\alpha \\to \\beta \\in F^+$, where $\\alpha, \\beta \\subseteq R$, at least one of the following holds:\n- $\\alpha \\to \\beta$ is trivial. (i.e., $\\beta \\subseteq \\alpha$)\n- $\\alpha$ is a [[notes/Keys|superkey]] of $R$. (i.e., $\\alpha \\to R$)\n- Each attribute $A$ in $\\beta \\setminus \\alpha$ is contained in a candidate key for $R$.\n  - Note that each attribute may be in a different candidate key.\n\nIf a relation is in [[notes/Boyce-Codd normal form|BCNF]], then it is in 3NF also. The third condition is a minimal relaxation to BCNF to ensure **[[notes/Dependency preservation|dependency preservation]]**.\n\nNote that for any relation schema, there **always** exists a lossless, dependency preserving decomposition into 3NF.\n\n### Example\n\nConsider a schema $R = \\texttt{dept-advisor}(\\texttt{sID}, \\texttt{iID}, \\texttt{deptName})$ with the functional dependencies $\\texttt{iID} \\to \\texttt{deptName}$ and $\\texttt{sID}, \\texttt{deptName} \\to \\texttt{iID}$.\n\nThen, the candidate keys are $\\lbrace \\texttt{sID}, \\texttt{deptName} \\rbrace$ and $\\lbrace \\texttt{sID}, \\texttt{iID} \\rbrace$.\n\nAlthough $R$ is not in BCNF, $R$ is in 3NF.\n\n## Testing for 3NF\n\nUnlike [[notes/Boyce-Codd normal form#Testing for BCNF|testing for BCNF]], testing for 2NF need not check all functional dependencies in $F^+$; it only requires to check only functional dependencies in $F$ itself.\n\nLet $R$ be a relation schema, and let $F$ be the set of functional dependencies.\n\n1. For every functional dependency $\\alpha \\to \\beta \\in F$, compute $\\alpha^+$.\n2. If $\\alpha \\to R$, $\\alpha \\to \\beta$ does not violate 3NF.\n3. Otherwise if $\\alpha$ is not a superkey of $R$, verify if each attribute in $\\beta$ is contained in a candidate key of $R$.\n\nThis test is rather more expensive, since it involves finding candidate keys. This test is shown to be NP-hard.\n\n## Decomposition into 3NF\n\n![3nf-decompose-algorithm](notes/images/3nf-decompose-algorithm.png)\n\nThe above algorithm ensures that:\n- Each relation schema $R_i$ is in 3NF.\n- Decomposition is dependency preserving and lossless.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Thread":{"title":"Thread","content":"\nA **thread** is a _single execution sequence_ that represents _a separately schedulable task_. Doing so, threads provide the illusion of an infinite number of _processors_.\n\n- **Single execution sequence**: Each thread executes a sequence of instructions, just as in the familiar sequential programming model.\n- **Separately schedulable task**: The operating system can run, suspend (block), or resume a thread at any time.\n\nThreads can run either in a [process](notes/Process.md) or in the kernel; there is also _shared state_ that is not saved or restored when switching the processor between threads.\n\n## Advantages\nUsing threads to express and manage concurrency has several advantages.\n\n-  **Expressing logically concurrent tasks**: Threads eneable the expression of an application's natural concurrency by writing each concurrent task as a separate thread.\n- **Shifting work to run in the background**: To improve user responsiveness and performance, a common design pattern is to create threads to perform work that in the background, without the user waiting for the result.\n- **Exploiting multiple processors**: Programs can use threads on a multiprocessor to do work in parallel; they can do the same work in less time or more work in the same elapsed time.\n- **Managing I/O devices**: By running tasks as separate threads, when one task is waiting for I/O, the processor can make progress on a different task.\n\n## Comparison with [Processes](notes/Process.md)\n- [Comparison between processes and threads](notes/Comparison%20between%20processes%20and%20threads.md)\n\n## Thread Data Structures\n- [Thread data structures](notes/Thread%20data%20structures.md)\n\n## Thread Life Cycle\n- [Thread life cycle](notes/Thread%20life%20cycle.md)\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Thread-data-structures":{"title":"Thread data structures","content":"\n![thread-data-structure](/notes/images/thread-data-structure.png)\n\n## Per-Thread State and Thread Control Block (TCB)\nThe operating system needs a data structure to represent a threads's state. This data structure is called the **thread control block (TCB)**. For every thread the operating system creates, it creates one TCB.\n\nThe thread control block holds two types of per-thread information:\n- **Per-thread Computation State**\n- **Per-thread Metadata**\n\n### Per-thread Computation State\nTo create multiple threads and to be able to start/stop each thread as needed, the operating system must allocate space in the TCB for the _current state of each thread's computation_. This, in turn, is the **pointer to the thread's stack** and a **copy of its processor registers**.\n\n- **Stack**\n\t- A thread's stack is the same as the stack for a single-threaded computation. It stores information needed by the nested procedures the thread is currently running.\n\t- Each thread needs its own stack, because at any given time different threads can be in different states in their sequential computations.\n\t- When a new thread is created, the operating system allocates it a new stack and stores a pointer to that stack in the thread's TCB.\n\n- **Copy of processor registers**\n\t- A processor's registers include not only its general-purpose registers (for storing intermediate values for ongoing computations), but they also include special-purpose registers, such as the _instruction pointer_ and the _stack pointer_.\n\t- To be able to suspend/run/resume threads, the operating system needs a place to store a thread's registers when that thread is not actively running.\n\n### Per-thread Metadata\nThe TCB also includes **per-thread metadata**, information for managing the thread. This includes _thread ID (tid)_, _scheduling priority_, and _status_.\n\n## Shared State\nSome state is **shared** between threads running _in the same process_ or _within the operating system kernel_. The followings are examples of shared states between threads.\n\n- Program **code** is shared by all threads in a process (although each thread may be executing at a different place within that code).\n- Statically allocated **global variables** and dynamically allocated **heap variables** can store information accessible to all threads.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Thread-life-cycle":{"title":"Thread life cycle","content":"\n![thread-life-cycle](/notes/images/thread-life-cycle.png)\n\n## Init\n- Thread creation `thread_create()` puts a thread into its `init` state and allocates and initialises per-thread data structures.\n- Once that is done, thread creation code puts the thread in `ready` state by adding the thread to the _ready list_ (set of runnable threads that are waiting their turn to use a processor).\n\n## Ready\n- A thread in `ready` state is available to be run but is not currently running.\n- Its TCB is on the ready list, and the values of its registers are stored in its TCB.\n- At any time, the **scheduler** can cause a thread to transition from `ready` to `running` state, by copying its register values from its TCB to a processor's registers.\n\n## Running\n- A thread in `running` state is running on a processor. At this time, its register values are stored on the processor rather than in the TCB.\n- A `running` thread can transition to the `ready` state in two ways:\n\t- The **scheduler** can _preempt_ a `running` thread and move it to the `ready` state by saving the thread's registers to its TCB and switching the processor to run the next thread on the ready list.\n\t- A `running` thread can voluntarily relinquish the processor and go from `running` to `ready` by calling `thread_yield()`.\n\n## Waiting\n- A thread in the `waiting` state is waiting for some event.\n- While the scheduler can move a thread in the `ready` state to the `running` state, a thread in the `waiting` state cannot run until some action by another thread moves it from `waiting` to `ready`.\n- The TCB of a `waiting` thread is stored on the _waiting list_ of some synchronisation variable associated with the event. When the required event occurs, the operating system moves the TCB from the synchronisation variable's waiting list to the scheduler's ready list, transitioning the thread from `waiting` to `ready`.\n\n## Finished\n- A thread in `finished` state never runs again.\n- The system can free some or all of its state for other use. Some systems may store `finished` threads in a _finished list_.\n\n\nOne way to understand the states is to consider where a thread's TCB and registers are stored.\n\n| State of Thread | Location of TCB                            | Location of Registers |\n| --------------- | ------------------------------------------ | --------------------- |\n| `init`          | Being Created                              | TCB                   |\n| `ready`         | Ready List                                 | TCB                   |\n| `running`       | Running List                               | Processor             |\n| `waiting`       | Waiting List of a Synchronisation Variable | TCB                   |\n| `finished`      | Finished List / Deleted                    | TCB / Deleted         |\n\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Thread-models":{"title":"Thread models","content":"\nSupport for threads may be provided either at the user level, for **user threads**, or by the kernel, for **kernel threads**. **User threads** are supported above the kernel and are managed without kernel support, whereas **kernel threads** are supported and managed directly by the operating system. Accordingly, a _relationship_ must exist between user threads and kernel threads.\n\n## One-to-one Model\n![one-to-one-model](/notes/images/one-to-one-model.png)\nThe **one-to-one model** maps each user thread to a kernel thread.\n|             |                                                                                                                                      |\n| ----------- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| Advantages  | Provides _more concurrency_ than the many-to-one model by allowing another thread to run when a thread makes a blocking system call. |\n| Limitations | Every thread operation must go through the kernel; slower performance.                                                               |\n|             | One-size fits all thread implementation; maybe pay for fancy features that a thread doesn't need.                                    |\n|             | General heavy-weight memory requirements (e.g., requires a _fixed-size stack_ within kernel).                                        |\n \n## Many-to-one Model\n![many-to-one-model](/notes/images/many-to-one-model.png)\n\nThe **many-to-one model** maps many user-level threads to one kernel thread.\n|             |                                                                                               |\n| ----------- | --------------------------------------------------------------------------------------------- |\n| Advantages  | Thread scheduling is done in user space, so it is efficient.                                  |\n| Limitations | Can't take advantage of multicore systems.                                                    |\n|             | User-level threads are invisible to the OS and thus not well-integrated with the OS.          |\n|             | As a result, the OS can make poor decisions (e.g., a blocking system call blocks all threads) |\n\n## Many-to-many Model\n![many-to-many-model](/notes/images/many-to-many-model.png)\n\nThe **many-to-many model** multiplexes many user-level threads to a smaller or equal number of kernel threads. This is sometimes also called **n:m thread model**, where n is the number of user threads, and m is the number of kernel threads.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Too-much-milk-problem":{"title":"Too much milk problem","content":"\n## Definition\nThe **Too Much Milk** problem models two roommates who share a refrigerator and, who make sure the refrigerator is _always_ well stocked with milk.\n\n## Example Situation\n| Time | Roommate 1                   | Roommate 2                   |\n| ---- | ---------------------------- | ---------------------------- |\n| 3:00 | Look in fridge; out of milk. |                              |\n| 3:05 | Leave for store.             |                              |\n| 3:10 | Arrive at store.             | Look in fridge; out of milk. |\n| 3:15 | Buy milk.                    | Leave for store.             |\n| 3:20 | Arrive home; put milk away.  | Arrive at store.             |\n| 3:25 |                              | Buy milk.                    |\n| 3:30 |                              | Arrive home; put milk away.  |\n|      |                              | **Oh no, too much milk!**    |\n\nOne can model each roommate as a **thread** and the number of bottles of milk in the fridge with **a variable in memory**. Two properties needs to be met for a solution: **safety** and **liveliness**.\n\n### Safety\nA program never enters a bad state.\n- In the too much milk problem, never more than one person buys a milk.\n\n### Liveliness\nA program must, eventually, enter a good state.\n- In the too much milk problem, if milk is needed, someone eventually buys it.\n\n## Solutions\n### Solution 1: Leave a note\nThe basic idea is to leave a note on the fridge before going to the store. The simplest idea to implement this is to set a flag when going to buy milk and to check this flag before going to buy milk.\n\n```C\nif(milk == 0)   // If no milk\n{\n  if(!note)     // If no note\n  {\n    leave note;\n    buy milk;\n    remove note;\n  }\n}\n```\n\nHowever, this implementation can violate safety; it makes the problem worse since it fails intermittenly!\n\n| Thread A         | Thread B         |\n| ---------------- | ---------------- |\n| `if (milk == 0)` |                  |\n| `if (note == 0)` |                  |\n| _Interleaves_    | `if (milk == 0)` |\n|                  | `if (note == 0)` |\n| `note = 1;`      | _Interleaves_    |\n| `milk++;`        |                  |\n| `note = 0;`      |                  |\n| _Interleaves_    | `note = 1;`      |\n|                  | `milk++;`        |\n|                  | `note = 0;`      |\n\n### Solution 2: Using two notes\n- Thread A\n```C\nleave note A;\nif(!note B)\n{\n  if(milk == 0)\n\tbuy milk;\n}\nremove note A;\n```\n- Thread B\n```C\nleave note B;\nif(!note A)\n{\n  if(milk == 0)\n\tbuy milk;\n}\nremove note B;\n```\n\nThis solution is **safe**. However, this solution does not ensure **liveliness**. Although it is unlikely to happen, but it is possible at worst case.\n\n| Thread A              | Thread B              |\n| --------------------- | --------------------- |\n| `leave note A`        |                       |\n| _Interleaves_         | `leave note B`        |\n|                       | `if (!note A)`        |\n|                       | (PASS) `if (milk == 0)` |\n|                       | (PASS) `buy milk`       |\n| `if (!note B)`        | _Interleaves_         |\n| (PASS) `if (milk == 0)` |                       |\n| (PASS) `buy milk`       |                       |\n\n\n### Solution 3: Busy waiting\n- Thread A\n```C\nleave note A;\nwhile(note B)\n  ;\nif(milk == 0)\n  buy milk;\nremove note A;\n```\n\n- Thread B\n```C\nleave note B;\nif(!note A)\n{\n  if(milk == 0)\n    buy milk;\n}\nremove note B;\n```\n\nThis solution is both **safe** and **live**. Since thread B does not have a loop, it will eventually finish its execution.\n\nHowever, this solution is not very satisfying:\n\n- It is complex and requires caregul reasoning to be convinced that it works.\n- It is _inefficient_ because thread A is _busy waiting_, consuming CPU resources.\n- It may fail if the compiler or hardware reorders instructions.\n\n### Solution 4: [Locks](Lock.md)\n```C\nlock.acquire();\nif(milk == 0)\n  buy milk;\nlock.release();\n```\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Topology":{"title":"Topology","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Transactions":{"title":"Transactions","content":"\nA **transaction** consists of a sequence of query and/or update statements. It is a 'unit' of work.\n\nThe SQL standard specifies that a transaction begins implicitly when an SQL statement is executed.\n\nThe transaction must end with one of the following statements:\n- **Commit work**\n  \n  The updates performed by the transaction become permanent in the database.\n\n- **Rollback work**\n  \n  **All** the updates performed by the SQL statements in the transaction are undone.\n\nThe database provides an abstraction of a transaction as being [[notes/Atomic operation | atomic]], that is, indivisible. Either **all** the effects of the transaction are reflected in the database, or **none** are (after rollback).\n","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Triggers-in-SQL":{"title":"Triggers in SQL","content":"\nA **trigger** is a statement that is executed automatically by the system as a side effect of a modification to the database.\n\nThe two requirements of a trigger design are:\n- Specify the **conditions** under which the trigger is to be execute.\n- Specify the **actions** to be taken when the trigger executes.\n\n## Triggering events and actions in SQL\n- Triggering event can be an insert, a deletion, or an update.\n\n- Triggers on updates can be restricted to specific attributes.\n\n- Values of attributes before and after an update can be referenced.\n  - `REFERENCING OLD ROW AS`: For deletions and updates\n  - `REFERENCING NEW ROW AS`: For insertions and updates\n\n- Triggers can be activated before and after an event.\n  - `BEFORE UPDATE OF`: Serves as an extra constraint.\n  - `AFTER UPDATE OF`\n\n**Examples**\n- When the `grade` attribute is updated for a tuple in the `takes` relation, keep the `tot_cred` attribute value of `student` tuples up-to-date\n```sql\n-- When (Trigger Conditions)\nCREATE TRIGGER credits_earned\nAFTER UPDATE OF takes ON (grade)\n-- What (Trigger Actions)\nREFERENCING NEW ROW AS nrow\nREFERENCING OLD ROW AS orow\nFOR EACH ROW\nWHEN    (nrow.grade \u003c\u003e 'F' AND nrow.grade IS NOT NULL)\nAND     (orow.grade = 'F'  OR  orow.grade IS NULL)\nBEGIN ATOMIC\n    UPDATE  student\n    SET     tot_cred = tot_cred +\n    (\n        SELECT  credits\n        FROM    course\n        WHERE   course.course_id = nrow.course_id\n    )\n    WHERE   student.id = nrow.id;\nEND;\n```\n\n### Statement level triggers\nInstead of executing a separate action for each affected row, a single action can be executed for all rows affected by a transaction.\n- Instead of `FOR EACH ROW`, use `FOR EACH STATEMENT`.\n\n- Instead of `REFERENCING [OLD/NEW] ROW AS ...`, use `REFERENCING [OLD/NEW] TABLE AS ...` to refer to temporary tables (called **transition tables**).\n\nStatement level triggers can be more efficient when dealing with SQL statements that update a large number of rows.\n\n## When not to use triggers\nEarlier, triggers were used for tasks such as\n- Maintaining **summary data**.\n\n- Replicating databases by recording changes to special relations (called **change** or **delta** relations), and having a separate process that applies the changes over to a replica\n\nHowever, there are better ways of doing these nowadays.\n- Databases today provide built-in [[notes/Views#Materialised views | materialised view]] facilities to maintain summary data.\n\n- Databases provide built-in support for replication.\n\n- Encapsulation facilities can be used instead of triggers in many cases. It carries out actions as part of the update methods instead of through a trigger.\n\n### Risks of using triggers\nThere are some risks for using triggers. For example,\n- Risk of unintended execution of triggers.\n\n- Error leading to failure of critical transactions that set off the trigger.\n\n- Cascading execution of triggers.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Update-of-a-view":{"title":"Update of a view","content":"\nAlthough [[notes/Views | views]] are a useful tool for queries, they present serious problems when undergoing _updates_, _insertions_, or _deletions_.\n\n## Missing attribute\n**Example**\n- Add a new tuple to the view `faculty` defined earlier\n```sql\nINSERT INTO faculty VALUES\n    ('30765', 'Green', 'Music');\n```\nThis insertion must be represented by the insertion into the `instructor` relation, which must have a `salary` attribute.\nThere are two reasonable approaches to dealing with this insertion.\n- Reject the insertion.\n- Insert a tuple with the value of the non-existing attribute set to `NULL`.\n  - Will be rejected by the [[notes/Database systems | DBMS]] if that attribute has `NOT NULL` constraint.\n\n## Ambiguity\nAnother problem with modification of the database through views occurs when updates cannot be **translated uniquely**.\n\n**Examples**\n```sql\nCREATE VIEW instructor_info AS\n    SELECT  ID,\n            name,\n            building\n    FROM    instructor,\n            department\n    WHERE   instructor.dept_name = department.dept_name\n\nINSERT INTO instructor_info VALUES\n    ('69987', 'White', 'Taylor');\n```\n- Which department, if multiple departments exist in the `Taylor` building, should the value be inserted to?\n- What if there is no department in the `Taylor` building?\n  \nThere is no way to update the relations `instructor` and `department` by using `NULL` values to get the desired update on the view `instructor_info`.\n\nConsider another problematic scenario.\n```sql\nCREATE VIEW history_instructors AS\n    SELECT  *\n    FROM    instructor\n    WHERE   dept_name = 'History'\n\nINSERT INTO history_instructors VALUES\n    ('25566', 'Brown', 'Biology', 7000);\n```\n- Should the insertion be allowed?\n\n## View updates in SQL\nBecause of problems such as above, modifications are generally **not permitted** on view relations, except in limited cases.\n\nMost SQL implementations allow updates only on simple views:\n- The `FROM` clause has only one database relation.\n  \n- The `SELECT` clause contains only attributes of the relation, and does **not** have any expression, aggregates, or `DISTINCT` specification.\n  \n- Any attribute not listed in the `SELECT` clause can be set to `NULL`.\n  \n- The query does not have a `GROUP BY` or `HAVING` clause.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Vector-analysis":{"title":"Vector analysis","content":"","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Vector-space":{"title":"Vector space","content":"\n## Definition\n\nA vector space $V$ over a [field](notes/Field.md) $F$ consists of a set on which two operations $+$ (_addition_) and $\\cdot$ (_scalar multiplication_) are defined so that the followings hold.\n\nFor any $\\mathbf{x}, \\mathbf{y}, \\mathbf{z} \\in V$ and $c, d \\in F$:\n\u003e **(A1)** $\\mathbf{x}, \\mathbf{y} \\in V \\Rightarrow \\mathbf{x} + \\mathbf{y} \\in V$\n\u003e\n\u003e **(A2)** $\\mathbf{x} + \\mathbf{y} = \\mathbf{y} + \\mathbf{x} \\quad$ (Commutativity of addition)\n\u003e\n\u003e **(A3)** $(\\mathbf{x} + \\mathbf{y}) + \\mathbf{z} = \\mathbf{x} + (\\mathbf{y} + \\mathbf{z}) \\quad$ (Associativity of addition)\n\u003e\n\u003e **(A4)** $\\exists ! \\mathbf{0} \\in V$ such that $\\forall \\mathbf{x} \\in V: \\mathbf{x} + \\mathbf{0} = \\mathbf{x} \\quad$ (Existence of additive identity)\n\u003e\n\u003e **(A5)** $\\forall \\mathbf{x} \\in V: \\exists ! (-\\mathbf{x}) \\in V$ such that $\\mathbf{x} + (-\\mathbf{x}) = \\mathbf{0} \\quad$ (Existence of additive inverse)\n\u003e\n\u003e **(M1)** $\\mathbf{x} \\in V \\Rightarrow c\\mathbf{x} \\in V$\n\u003e\n\u003e **(M2)** $c(d\\mathbf{x}) = (cd)\\mathbf{x}$\n\u003e\n\u003e **(M3)** $c(\\mathbf{x} + \\mathbf{y}) = c\\mathbf{x} + c\\mathbf{y}$\n\u003e\n\u003e **(M4)** $(c + d)\\mathbf{x} = c\\mathbf{x} + d\\mathbf{x}$\n\u003e\n\u003e **(M5)** $\\forall \\mathbf{x} \\in V: 1\\mathbf{x} = \\mathbf{x}$\n\n## Examples\n### The space of $m \\times n$ matrices\nLet $F$ be any field and $m, n \\in \\mathbb{N}$. Define $F^{m\\times n}$ as the set of all $m\\times n$ matrices over the field $F$. Then, for any matrices $A, B \\in F^{m \\times n}$ and scalar $c \\in F$,\n- $(A + B)\\_{ij} = A\\_{ij} + B\\_{ij}$\n- $(cA)\\_{ij} = cA\\_{ij}$\n\n### The space of functions from a set to a field\nLet $F$ be any field, and $S$ be any nonempty set. Define $V$ as the set of all functions $S \\to F$. Then, for any functions $f, g \\in V$ and scalar $c \\in F$, $\\forall s \\in S$:\n- $(f + g)(s) = f(s) + g(s)$\n- $(cf)(s) = cf(s)$\n- The zero vector is the function $\\mathbf{0}: S \\to \\lbrace 0 \\rbrace$.\n- The inverse vector $(-f)$ of an arbitrary function $f \\in V$ is given as $(-f)(s) = -f(s)$.\n\n### The space of polynomial functions over a field\nLet $F$ be any field. Define $V$ as tje set of all polynomials $F \\to F$, that is, all functions $f: F \\to F$ in the form of\n$$f(x) = \\sum\\limits_{i=0}^n c_ix^i$$\nwhere $c_i \\in F$ $(i= 0, \\cdots, n)$ are independent of $x$.\n\n\n## Related Concepts\n- [Norm](notes/Norm.md): Defines a distance-like property in vector spaces\n- [Inner product](notes/Inner%20product.md): Allows the concept of 'direction' to be considered in vector spaces\n ","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/View-of-data":{"title":"View of data","content":"\nA major purpose of a [database system](notes/Database%20systems.md) is to provide users with an abstract view of the data. That is, the system hides certain details of how the data are stored and maintained.\n\n## Data models\nA **data model** is a collection of conceptual tools for describing _data_, _data relationships_, _data semantics_, and _consistency constraints_.\n\n- **Relational model**\n  \n  All the data is stored in various tables. Each table has multiple columns, and each column has a unique name. Tables are also known as _relations_.\n\n- **Entity-Relationship model**\n  \n  Uses a collection of basic objects, called _entities_, and relationships among these objects.\n\n- **Semi-structured data model**\n  \n- **Object-based data model**\n  \n  Allow procedures to be stored in the database system and executed by the database system.\n\n\n## Data abstraction\nThe complexity of the data structures to represent data in the database is hidden from users through several levels of **data abstraction**.\n\n- **Physical level**\n  \n  Describes _how_ the data are actually stored. It describes complex low-level data structures in detail.\n\n- **Logical level**\n  \n  Describes _what_ data are stored in the database, and what relationships exist among those data.\n\n- **View level**\n  \n  Describes only _part_ of the entire database. The view level of abstraction exists to simplify users' interaction with the system. The system may provide many views for the same database.\n\n![data-abstraction-levels](/notes/images/data-abstraction-levels.png)\n\n- **Physical data independence**\n  \n  The ability to modify the physical schema without changing the logical schema. In general, the interfaces between the various levels and components should be well defined, so that changes in some parts do not seriously influence others.\n\n## Instances and schemas\n- The collection of information stored in the database at a _particular moment_ is called an **instance** of the database.\n  \n- The _overall design_ of the database is called the database **schema**. Database systems have several schemas, partitioned according to the levels of abstraction.\n  \n\t- **Physical schema**\n\t\t\n\t\tDescribes the overall _physical_ structure of the database.\n\t\n\t- **Logical schema**\n\t\t\n\t\tDescribes the overall _logical_ structure of the database.\n\t\n\t- **Subschema**\n  \t\t\n\t\tDescribes different _views_ of the database.","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Views":{"title":"Views","content":"\nIn some cases, it is not desirable for all users to see the entire [[notes/View of data#Data models | logical model]] (i.e., all the actual [[notes/Structure of relational databases | relations]] stored in the database).\n\nAside from security concerns, one may wish to create personalised collection of relations that is better matched to a certain user's intuition than is the logical model.\n\nSQL allows a **virtual relation** to be defined by a query, and the relation conceptually contains the result of the query.\n\nAny such relation that is not part of the logical model, but is made visible to a user as a virtual relation, is called a **view**.\n\n## View definition\nA view is defined using the `CREATE VIEW` statement.\n```sql\nCREATE VIEW v AS Q\n```\n- `v`: The name of the view\n- `Q`: Any legal SQL expression\n\nOnce a view is defined, the view name can be used to refer to the virtual relation that the view generates.\n\nView denition is **not** the same as creating a new relation by evaluating the query expression. Rather, a view definition causes the _saving of an expression_; the expression is substituted into queries using the view.\n\n**Examples**\n- A view of instructors without their salary\n```sql\nCREATE VIEW faculty AS\n    SELECT  ID,\n            name,\n            dept_name\n    FROM    instructor;\n```\n- Find all instructors in the Biology department\n```sql\nSELECT  name\nFROM    faculty\n-- Views can be used like relations\nWHERE   dept_name = 'Biology';\n```\n- A view of department salary totals\n```sql\nCREATE VIEW \n    dept_total_salary\n    (\n        dept_name,\n        total_salary\n    ) AS\n    SELECT  dept_name,\n            SUM(salary)\n    FROM    instructor\n    GROUP BY dept_name;\n```\n\n### Views defined using other views\nA view can be used in the expression defining another view.\n\n- **Direct dependency**\n  \n  A view relation $v_1$ is said to **depend directly** on a view relation $v_2$, if $v_2$ is used in the expression defining $v_1$.\n\n- **Dependency**\n\n  A view relation $v_1$ is said to **depend** on a view relation $v_2$, if either $v_1$ depends directly to $v_2$, or there exists a path of dependencies from $v_1$ to $v_2$.\n\n- **Recursion**\n  \n  A view relation $v$ is said to be **recursive** if it depends on itself.\n\n## View expansion\n**View expansion** is a way to define the meaning of views defined in terms of other views.\n\nSuppose that a view $v_1$ is defined by an expression $e_1$ that may itself contain uses of view relations.\n\nIt follows the following replacement step:\n```\nREPEAT\n    Find any view relation v_i in e_1\n    Replace the view relation v_i by the expression defining v_i\nUNTIL nomore view relation are present in e_1\n```\nAs long as the view definitions are _not recursive_, the loop will terminate eventually.\n\n## Materialised views\nCertain [[notes/Database systems | database systems]] allow view relations to be physically stored, that is, a physical copy of the 'virtual' relation is created when the view is defined.\n\nSuch views are called **materialised views**. It is especially efficient for views that are very commonly used.\n\nIf relations used in the query are [[notes/Modification of the database | updated]], the materialised view reult becomes **out of date**; views must be maintained to date by updating the view whenever the underlying relations are updated.\n\n### Pros and cons of materialised views\n\n|      | Virtual Relation    | Materialisation             |\n|------|---------------------|-----------------------------|\n| Pros | No updated required | No query rewriting required |\n| Cons | Queries must be rewrited every time | Update required whenever the base relations are updated |","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/Weierstrass-approximation-theorem":{"title":"Weierstrass approximation theorem","content":"\n## Theorem\n\u003e Let $f: \\mathbb{R} \\to \\mathbb{R}$ be a continuous function on the interval $[a,b]$.\n\u003e Then, for any positive $\\varepsilon$, there exists $n \\in \\mathbb{N}$ where for some \n\u003e $n$-degree polynomial $p_n$,\n\u003e $\\lVert f - p_n \\rVert_{C^0} \\leq \\varepsilon$ holds.\n\n## Proof\nWithout loss of generality, let $a=0$ and $b=1$. Since $f$ is continuous on $[0,1]$, let $M$ as:\n$$\nM = \\sup\\limits_{x \\in [0,1]}|f(x)| := \\lVert f \\rVert_0.\n$$\n\nConsequently, for any $\\xi \\in [0,1]$, the following holds:\n$$\n|f(x)-f(\\xi)| \\leq\n\\begin{cases}\n\\dfrac{\\varepsilon}{2} \\qquad \u0026 \u0026\\text{if„ÄÄ} |x - \\xi| \u003c \\delta \\\\\n|f(x)| + |f(\\xi)| \u0026\\leq 2M\\\\\n\u0026\\leq 2M\\cdot 1\\\\\n\u0026\\leq 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2\\qquad \u0026\\text{otherwise.}\n\\end{cases}\n$$\nTherefore we can conclude that \n$$\n|f(x) - f(\\xi)| \\leq 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2 + \\dfrac{\\varepsilon}{2}.\n$$\n\nNow, we will prove that the polynomial of interest is actually the **[Bernstein polynomial](notes/Bernstein%20polynomial.md)**.\n\n$$\n\\begin{aligned}\n|B_n(x;f)-f(\\xi)| \u0026= |B_n(x;f) - B_n\\left(x;f(\\xi)\\right)| = |B_n\\left(x;f-f(\\xi)\\right)|\\\\\n\u0026= \\left|\\sum\\limits_{\\nu = 0}^n \\left(f\\left(\\dfrac{\\nu}{n}\\right)-f(\\xi)\\right)\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}\\right|\\\\\n\u0026\\leq \\sum\\limits_{\\nu = 0}^n \\left|\\,f\\left(\\dfrac{\\nu}{n}\\right)-f(\\xi)\\,\\right|\\binom{n}{\\nu}x^\\nu (1-x)^{n-\\nu}\\\\\n\u0026= B_n\\left(x;|f-f(\\xi)|\\right)\\\\\n\u0026\\leq B_n\\left(x; 2M\\left( \\dfrac{|x - \\xi|}{\\delta} \\right) ^2 + \\dfrac{\\varepsilon}{2}\\right)\\\\\n\u0026= \\dfrac{2M}{\\delta^2}\\left( x^2+\\dfrac{1}{n}(x - x^2) \\right) - \\dfrac{4M\\xi}{\\delta^2} + \\dfrac{2M\\xi^2}{\\delta^2} + \\dfrac{\\varepsilon}{2}\n\\end{aligned}\n$$\nThe last line is due to the [properties](notes/Bernstein%20polynomial.md###Properties) of Bernstein polynomials.\n\nNext, let $\\xi = x$. Then consequently,\n$$\n\\begin{aligned}\n|B_n(x;f) - f(x)|\n\u0026\\leq \\dfrac{2M}{\\delta^2}\\cdot\\dfrac{\\xi-\\xi^2}{n} + \\dfrac{\\varepsilon}{2}\\\\\n\u0026\\leq \\dfrac{M}{2\\delta^2}\\cdot\\dfrac{1}{n} + \\dfrac{\\varepsilon}{2}\n\\end{aligned}\n$$\nThe last line is due to the fact that the maximum value of the function $x - x^2$ on the interval $[0,1]$ is $\\dfrac{1}{4}$.\n\nFinally, choose $n$ such that it satisfies $n \\geq \\dfrac{M}{\\delta^2 \\varepsilon}$. Then for any $x \\in [0,1]$,\n$$\n|B_n(x;f)-f(x)| \\leq \\varepsilon\n$$\nand equivalently,\n$$\n\\lVert B_n(\\cdot;f) - f\\rVert_{C^0} \\leq \\varepsilon.\n$$\nThis completes the proof.\n$$\\tag*{$||$}$$","lastmodified":"2022-12-27T21:16:58.285027791Z","tags":null},"/notes/x86-Mode-Transfer":{"title":"x86 Mode Transfer","content":"\n## Background on x86 Architecture\nx86 is segmented, so pointers come in two parts.\n\n- **Segment**: A region of memory such as code, data, or stack\n- **Offset**: An offset within that segment\n\nThe current user-level instruction is a combination of the code segment (`cs`) and the instruction pointer (`eip` / `rip`) within the code segment. The current stack position is a combination of the stack segment (`ss`) and the stack pointer (`esp` / `rsp`) within the stack segment.\n\nThe current privilege level is stored as the low-order buts of the `cs` register. The `eflags` register has condition codes that are modified as a by-product of executing instructions, as well as other flags that control the processor's behaviour (such as whether interrupts are masked).\n\n## Mode Transfer in x86\nWhen a processor exception or a system call trap occurs, the following procedure takes place.\n\n1. **Mask interrupts**.\n\t- The hardware prevents any interrupts from occurring while the processor is in the middle of context switch.\n2. **Save three key values**. \n\t- The hardware saves the values of the stack pointer (`esp`/`rsp` and `ss`), the execution flags (`eflags`), and the instruction pointers (`eip`/`rip` and `cs`) to internal, temporary hardware registers.\n3. **Switch onto the kernel interrupt stack**.\n\t- The hardware switches the stack segment / stack pointer to the base of the kernel interrupt stack as specified in a special hardware register.\n4. **Push the three key values onto the new stack**.\n\t- The hardware stores the internally saved values onto the stack.\n5. **Optionally save an error code.**\n\t- The hardware pushes an error code (generated by certain types of exceptions, e.g., page fault) and make it the top item on the stack. For other types of events, the software interrupt handler pushes a dummy value onto the stack.\n6. **Invoke the interrupt handler**.\n\t- The hardware changes the code segment / program counter to the address of the interrupt handler procedure.\n\t- The handler pushes the rest of the registers, including the current stack pointer (but not the instruction pointer or `eflags` register), onto the stack.\n\n- State of the system before an interrupt handler is invoked\n![x86-mode-switch-1](/notes/images/x86-mode-switch-1.png)\n\n- State of the system after the jump to the interrupt handler\n![x86-mode-switch-2](/notes/images/x86-mode-switch-2.png)\n\n- State of the system after the interrupt handler has started executing\n![x86-mode-switch-3](/notes/images/x86-mode-switch-3.png)\n\nWhen the handler completes, it can resume the interrupted process. The handler executes the x86 `iret` instruction. It [atomically](notes/Atomic%20operation.md) restores the program counter, program stack pointer, the processor status word/condition codes, and switches the process back to user mode.","lastmodified":"2022-12-27T21:16:58.317028203Z","tags":null}}